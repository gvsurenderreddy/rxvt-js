/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of rxvtperl.xs. Do not edit this file, edit rxvtperl.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "rxvtperl.xs"
/*----------------------------------------------------------------------*
 * File:	rxvtperl.xs
 *----------------------------------------------------------------------*
 *
 * All portions of code are copyright by their respective author/s.
 * Copyright (c) 2005-2008 Marc Lehmann <pcg@goof.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *----------------------------------------------------------------------*/

#define line_t perl_line_t
#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>
#undef line_t

#include "../config.h"

#include <cstddef>
#include <cstdarg>

#include "unistd.h"

#include "ev_cpp.h"
#include "rxvt.h"
#include "keyboard.h"
#include "rxvtutil.h"
#include "rxvtperl.h"

#include "perlxsi.c"

#define GRAB_CURSOR THIS->scrollBar.leftptr_cursor

#undef LINENO
#define LINENO(n) MOD (THIS->term_start + int(n), THIS->total_rows)
#undef ROW
#define ROW(n) THIS->row_buf [LINENO (n)]

/////////////////////////////////////////////////////////////////////////////

static wchar_t *
sv2wcs (SV *sv)
{
  STRLEN len;
  char *str = SvPVutf8 (sv, len);
  return rxvt_utf8towcs (str, len);
}

static SV *
wcs2sv (wchar_t *wstr, int len = -1)
{
  char *str = rxvt_wcstoutf8 (wstr, len);

  SV *sv = newSVpv (str, 0);
  SvUTF8_on (sv);
  free (str);

  return sv;
}

static SV *
newSVptr (void *ptr, const char *klass)
{
  HV *hv = newHV ();
  sv_magic ((SV *)hv, 0, PERL_MAGIC_ext, (char *)ptr, 0);
  return sv_bless (newRV_noinc ((SV *)hv), gv_stashpv (klass, 1));
}

static void
clearSVptr (SV *sv)
{
  if (SvROK (sv))
    sv = SvRV (sv);

  hv_clear ((HV *)sv);
  sv_unmagic (sv, PERL_MAGIC_ext);
}

static long
SvPTR (SV *sv, const char *klass)
{
  if (!sv_derived_from (sv, klass))
    croak ("object of type %s expected", klass);

  MAGIC *mg = mg_find (SvRV (sv), PERL_MAGIC_ext);

  if (!mg)
    croak ("perl code used %s object, but C++ object is already destroyed, caught", klass);

  return (long)mg->mg_ptr;
}

#define newSVterm(term) SvREFCNT_inc ((SV *)(term)->perl.self)
#define SvTERM(sv) (rxvt_term *)SvPTR ((sv), "urxvt::term")

/////////////////////////////////////////////////////////////////////////////

#define SvOVERLAY(sv) (overlay *)SvPTR (sv, "urxvt::overlay")

class overlay : overlay_base
{
  rxvt_term *THIS;
  AV *overlay_av;
  int border;

public:
  HV *self;

  overlay (rxvt_term *THIS, int x_, int y_, int w_, int h_, rend_t rstyle, int border);
  ~overlay ();

  void show ();
  void hide ();

  void swap ();

  void set (int x, int y, SV *str, SV *rend);
};

overlay::overlay (rxvt_term *THIS, int x_, int y_, int w_, int h_, rend_t rstyle, int border)
: THIS(THIS), border(border == 2), overlay_av (0)
{
  x = x_;
  y = y_;
  w = w_;
  h = h_;

  if (w < 0) w = 0;
  if (h < 0) h = 0;

  if (border == 2)
    {
      w += 2;
      h += 2;
    }

  text = new text_t *[h];
  rend = new rend_t *[h];

  for (int y = 0; y < h; y++)
    {
      text_t *tp = text[y] = new text_t[w];
      rend_t *rp = rend[y] = new rend_t[w];

      text_t t0, t1, t2;
      rend_t r = rstyle;

      if (border == 2)
        {
          if (y == 0)
            t0 = 0x2554, t1 = 0x2550, t2 = 0x2557;
          else if (y < h - 1)
            t0 = 0x2551, t1 = 0x0020, t2 = 0x2551;
          else
            t0 = 0x255a, t1 = 0x2550, t2 = 0x255d;

          *tp++ = t0;
          *rp++ = r;

          for (int x = w - 2; x-- > 0; )
            {
              *tp++ = t1;
              *rp++ = r;
            }

          *tp = t2;
          *rp = r;
        }
      else
        for (int x = w; x-- > 0; )
          {
            *tp++ = 0x0020;
            *rp++ = r;
          }
    }

  show ();
}

overlay::~overlay ()
{
  hide ();

  for (int y = h; y--; )
    {
      delete [] text[y];
      delete [] rend[y];
    }

  delete [] text;
  delete [] rend;
}

void
overlay::show ()
{
  if (overlay_av)
    return;

  overlay_av = (AV *)SvREFCNT_inc (SvRV (
        *hv_fetch ((HV *)SvRV ((SV *)THIS->perl.self), "_overlay", 8, 0)
     ));
  av_push (overlay_av, newSViv ((long)this));

  THIS->want_refresh = 1;
  THIS->refresh_check ();
}

void
overlay::hide ()
{
  if (!overlay_av)
    return;

  int i;

  for (i = AvFILL (overlay_av); i >= 0; i--)
    if (SvIV (*av_fetch (overlay_av, i, 1)) == (long)this)
      break;

  for (; i < AvFILL (overlay_av); i++)
    av_store (overlay_av, i, SvREFCNT_inc (*av_fetch (overlay_av, i + 1, 0)));

  av_pop (overlay_av);

  SvREFCNT_dec (overlay_av);
  overlay_av = 0;

  THIS->want_refresh = 1;
  THIS->refresh_check ();
}

void overlay::swap ()
{
  int ov_x = max (0, min (MOD (x, THIS->ncol), THIS->ncol - w));
  int ov_y = max (0, min (MOD (y, THIS->nrow), THIS->nrow - h));

  int ov_w = min (w, THIS->ncol - ov_x);
  int ov_h = min (h, THIS->nrow - ov_y);

  // hide cursor if it is within the overlay area
  if (IN_RANGE_EXC (THIS->screen.cur.col - ov_x, 0, ov_w)
      && IN_RANGE_EXC (THIS->screen.cur.row - ov_y, 0, ov_h))
    THIS->screen.flags &= ~Screen_VisibleCursor;

  for (int y = ov_h; y--; )
    {
      text_t *t1 = text [y];
      rend_t *r1 = rend [y];

      text_t *t2 = ROW(y + ov_y + THIS->view_start).t + ov_x;
      rend_t *r2 = ROW(y + ov_y + THIS->view_start).r + ov_x;

      for (int x = ov_w; x--; )
        {
          text_t t = *t1; *t1++ = *t2; *t2++ = t;
          rend_t r = *r1; *r1++ = *r2; *r2++ = SET_FONT (r, THIS->fontset [GET_STYLE (r)]->find_font (t));
        }
    }

}

void overlay::set (int x, int y, SV *text, SV *rend)
{
  x += border;
  y += border;

  if (!IN_RANGE_EXC (y, 0, h - border))
    return;

  wchar_t *wtext = sv2wcs (text);

  for (int col = min (wcslen (wtext), w - x - border); col--; )
    this->text [y][x + col] = wtext [col];

  free (wtext);

  if (rend)
    {
      if (!SvROK (rend) || SvTYPE (SvRV (rend)) != SVt_PVAV)
        croak ("rend must be arrayref");

      AV *av = (AV *)SvRV (rend);

      for (int col = min (AvFILL (av) + 1, w - x - border); col--; )
        this->rend [y][x + col] = SvIV (*av_fetch (av, col, 1));
    }

  THIS->want_refresh = 1;
  THIS->refresh_check ();
}

/////////////////////////////////////////////////////////////////////////////

#define IOM_CLASS "urxvt"
#define IOM_WARN rxvt_warn
#include "iom_perl.h"

/////////////////////////////////////////////////////////////////////////////

struct rxvt_perl_interp rxvt_perl;

static PerlInterpreter *perl;

rxvt_perl_interp::~rxvt_perl_interp ()
{
  if (perl)
    {
      perl_destruct (perl);
      perl_free (perl);
      PERL_SYS_TERM ();
    }
}

void
rxvt_perl_interp::init (rxvt_term *term)
{
  if (!perl)
    {
      rxvt_push_locale (""); // perl init destroys current locale

      perl_environ = rxvt_environ;
      swap (perl_environ, environ);

      char *args[] = {
        "",
        "-e"
        "BEGIN {"
        "   urxvt->bootstrap;"
        "   unshift @INC, '" LIBDIR "';"
        "}"
        ""
        "use urxvt;"
      };
      int argc = sizeof (args) / sizeof (args[0]);
      char **argv = args;

      PERL_SYS_INIT3 (&argc, &argv, &environ);
      perl = perl_alloc ();
      perl_construct (perl);

      if (perl_parse (perl, xs_init, argc, argv, (char **)NULL)
          || perl_run (perl))
        {
          rxvt_warn ("unable to initialize perl-interpreter, continuing without.\n");

          perl_destruct (perl);
          perl_free (perl);
          perl = 0;
        }

      swap (perl_environ, environ);

      rxvt_pop_locale ();
    }

  if (perl)
    {
      // runs outside of perls ENV
      term->perl.self = (void *)newSVptr ((void *)term, "urxvt::term");
      hv_store ((HV *)SvRV ((SV *)term->perl.self), "_overlay", 8, newRV_noinc ((SV *)newAV ()), 0);
    }
}

static void
ungrab (rxvt_term *THIS)
{
  if (THIS->perl.grabtime)
    {
      XUngrabKeyboard (THIS->dpy, THIS->perl.grabtime);
      XUngrabPointer  (THIS->dpy, THIS->perl.grabtime);
      THIS->perl.grabtime = 0;
    }
}

bool
rxvt_perl_interp::invoke (rxvt_term *term, hook_type htype, ...)
{
  if (!perl || !term->perl.self)
    return false;

  // pre-handling of some events
  if (htype == HOOK_REFRESH_END)
    {
      AV *av = (AV *)SvRV (*hv_fetch ((HV *)SvRV ((SV *)term->perl.self), "_overlay", 8, 0));

      for (int i = 0; i <= AvFILL (av); i++)
        ((overlay *)SvIV (*av_fetch (av, i, 0)))->swap ();
    }

  swap (perl_environ, environ);

  bool event_consumed;

  if (htype == HOOK_INIT || htype == HOOK_DESTROY // must be called always
      || term->perl.should_invoke [htype])
    try
      {
        dSP;
        va_list ap;

        va_start (ap, htype);

        ENTER;
        SAVETMPS;

        PUSHMARK (SP);

        XPUSHs (sv_2mortal (newSVterm (term)));
        XPUSHs (sv_2mortal (newSViv (htype)));

        for (;;) {
          data_type dt = (data_type)va_arg (ap, int);

          switch (dt)
            {
              case DT_INT:
                XPUSHs (sv_2mortal (newSViv (va_arg (ap, int))));
                break;

              case DT_LONG:
                XPUSHs (sv_2mortal (newSViv (va_arg (ap, long))));
                break;

              case DT_STR:
                XPUSHs (sv_2mortal (newSVpv (va_arg (ap, char *), 0)));
                break;

              case DT_STR_LEN:
                {
                  char *str = va_arg (ap, char *);
                  int len   = va_arg (ap, int);

                  XPUSHs (sv_2mortal (newSVpvn (str, len)));
                }
                break;

              case DT_WCS_LEN:
                {
                  wchar_t *wstr = va_arg (ap, wchar_t *);
                  int wlen      = va_arg (ap, int);

                  XPUSHs (sv_2mortal (wcs2sv (wstr, wlen)));
                }
               break;

              case DT_LCS_LEN:
                {
                  long *lstr = va_arg (ap, long *);
                  int llen   = va_arg (ap, int);

                  XPUSHs (sv_2mortal (newSVpvn ((char *)lstr, llen * sizeof (long))));
                }
               break;

              case DT_XEVENT:
                {
                  XEvent *xe = va_arg (ap, XEvent *);
                  HV *hv = newHV ();

#                 define set(name, sv) hv_store (hv, # name,  sizeof (# name) - 1, sv, 0)
#                 define setiv(name, val) hv_store (hv, # name,  sizeof (# name) - 1, newSViv (val), 0)
#                 define setuv(name, val) hv_store (hv, # name,  sizeof (# name) - 1, newSVuv (val), 0)
#                 undef set

                  setiv (type,       xe->type);
                  setiv (send_event, xe->xany.send_event);
                  setiv (serial,     xe->xany.serial);

                  switch (xe->type)
                    {
                      case KeyPress:
                      case KeyRelease:
                      case ButtonPress:
                      case ButtonRelease:
                      case MotionNotify:
                        setuv (window,    xe->xmotion.window);
                        setuv (root,      xe->xmotion.root);
                        setuv (subwindow, xe->xmotion.subwindow);
                        setuv (time,      xe->xmotion.time);
                        setiv (x,         xe->xmotion.x);
                        setiv (y,         xe->xmotion.y);
                        setiv (row,       xe->xmotion.y / term->fheight + term->view_start);
                        setiv (col,       xe->xmotion.x / term->fwidth);
                        setiv (x_root,    xe->xmotion.x_root);
                        setiv (y_root,    xe->xmotion.y_root);
                        setuv (state,     xe->xmotion.state);

                        switch (xe->type)
                          {
                            case KeyPress:
                            case KeyRelease:
                              setuv (keycode, xe->xkey.keycode);
                              break;

                            case ButtonPress:
                            case ButtonRelease:
                              setuv (button,  xe->xbutton.button);
                              break;

                            case MotionNotify:
                              setiv (is_hint, xe->xmotion.is_hint);
                              break;
                          }

                        break;

                      case MapNotify:
                      case UnmapNotify:
                      case ConfigureNotify:
                        setuv (event,  xe->xconfigure.event);
                        setuv (window, xe->xconfigure.window);

                        switch (xe->type)
                          {
                            case ConfigureNotify:
                              setiv (x,      xe->xconfigure.x);
                              setiv (y,      xe->xconfigure.y);
                              setiv (width,  xe->xconfigure.width);
                              setiv (height, xe->xconfigure.height);
                              setuv (above,  xe->xconfigure.above);
                              break;
                          }

                        break;

                      case PropertyNotify:
                        setuv (window,       xe->xproperty.window);
                        setuv (atom,         xe->xproperty.atom);
                        setuv (time,         xe->xproperty.time);
                        setiv (state,        xe->xproperty.state);
                        break;

                      case ClientMessage:
                        setuv (window,       xe->xclient.window);
                        setuv (message_type, xe->xclient.message_type);
                        setuv (format,       xe->xclient.format);
                        setuv (l0,           xe->xclient.data.l[0]);
                        setuv (l1,           xe->xclient.data.l[1]);
                        setuv (l2,           xe->xclient.data.l[2]);
                        setuv (l3,           xe->xclient.data.l[3]);
                        setuv (l4,           xe->xclient.data.l[4]);
                        break;
                    }

                  XPUSHs (sv_2mortal (newRV_noinc ((SV *)hv)));
                }
                break;

              case DT_END:
                goto call;

              default:
                rxvt_fatal ("FATAL: unable to pass data type %d\n", dt);
            }
        }

      call:
        va_end (ap);

        PUTBACK;
        int count = call_pv ("urxvt::invoke", G_ARRAY | G_EVAL);
        SPAGAIN;

        if (count)
          {
            SV *status = POPs;
            count = SvTRUE (status);
          }

        PUTBACK;
        FREETMPS;
        LEAVE;

        if (SvTRUE (ERRSV))
          {
            rxvt_warn ("perl hook %d evaluation error: %s", htype, SvPV_nolen (ERRSV));
            ungrab (term); // better lose the grab than the session
          }

        event_consumed = !!count;
      }
    catch (...)
      {
        swap (perl_environ, environ);
        throw;
      }
  else
    event_consumed = false;

  // post-handling of some events
  if (htype == HOOK_REFRESH_BEGIN)
    {
      AV *av = (AV *)SvRV (*hv_fetch ((HV *)SvRV ((SV *)term->perl.self), "_overlay", 8, 0));

      for (int i = AvFILL (av); i >= 0; i--)
        ((overlay *)SvIV (*av_fetch (av, i, 0)))->swap ();
    }
  else if (htype == HOOK_DESTROY)
    {
      clearSVptr ((SV *)term->perl.self);
      SvREFCNT_dec ((SV *)term->perl.self);

      // don't allow further calls
      term->perl.self = 0;
    }

  swap (perl_environ, environ);

  return event_consumed;
}

/////////////////////////////////////////////////////////////////////////////

#line 637 "rxvtperl.c"

XS(XS_urxvt_warn); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_warn)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::warn(msg)");
    {
	const char *	msg = (const char *)SvPV_nolen(ST(0));
#line 779 "rxvtperl.xs"
        rxvt_warn ("%s", msg);
#line 649 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt_fatal); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_fatal)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::fatal(msg)");
    {
	const char *	msg = (const char *)SvPV_nolen(ST(0));
#line 784 "rxvtperl.xs"
        rxvt_fatal ("%s", msg);
#line 665 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__exit); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__exit)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::_exit(status)");
    {
	int	status = (int)SvIV(ST(0));

	_exit(status);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt_NOW); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_NOW)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: urxvt::NOW()");
    {
	NV	RETVAL;
	dXSTARG;
#line 792 "rxvtperl.xs"
        RETVAL = ev::now ();
#line 697 "rxvtperl.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_GET_BASEFG); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_GET_BASEFG)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::GET_BASEFG(rend)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
#line 799 "rxvtperl.xs"
        RETVAL = GET_BASEFG (rend);
#line 716 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_GET_BASEBG); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_GET_BASEBG)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::GET_BASEBG(rend)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
#line 806 "rxvtperl.xs"
        RETVAL = GET_BASEBG (rend);
#line 735 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_SET_FGCOLOR); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_SET_FGCOLOR)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::SET_FGCOLOR(rend, new_color)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
	int	new_color = (int)SvIV(ST(1));
#line 813 "rxvtperl.xs"
        RETVAL = SET_FGCOLOR (rend, clamp (new_color, 0, TOTAL_COLORS - 1));
#line 755 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_SET_BGCOLOR); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_SET_BGCOLOR)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::SET_BGCOLOR(rend, new_color)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
	int	new_color = (int)SvIV(ST(1));
#line 820 "rxvtperl.xs"
        RETVAL = SET_BGCOLOR (rend, clamp (new_color, 0, TOTAL_COLORS - 1));
#line 775 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_GET_CUSTOM); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_GET_CUSTOM)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::GET_CUSTOM(rend)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
#line 827 "rxvtperl.xs"
        RETVAL = (rend & RS_customMask) >> RS_customShift;
#line 794 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_SET_CUSTOM); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_SET_CUSTOM)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::SET_CUSTOM(rend, new_value)");
    {
	int	RETVAL;
	dXSTARG;
	int	rend = (int)SvIV(ST(0));
	int	new_value = (int)SvIV(ST(1));
#line 834 "rxvtperl.xs"
{
        if (!IN_RANGE_EXC (new_value, 0, RS_customCount))
          croak ("custom value out of range, must be 0..%d", RS_customCount - 1);

        RETVAL = (rend & ~RS_customMask)
               | ((new_value << RS_customShift) & RS_customMask);
}
#line 820 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt_termlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt_termlist)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: urxvt::termlist()");
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 847 "rxvtperl.xs"
{
        EXTEND (SP, rxvt_term::termlist.size ());

        for (rxvt_term **t = rxvt_term::termlist.begin (); t < rxvt_term::termlist.end (); t++)
          if ((*t)->perl.self)
            PUSHs (sv_2mortal (newSVterm (*t)));
}
#line 844 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term__new)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::_new(env, arg)");
    {
	SV *	RETVAL;
	AV *	env;
	AV *	arg;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVAV)
	    env = (AV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "env is not an array reference");

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV)
	    arg = (AV*)SvRV(ST(1));
	else
	    Perl_croak(aTHX_ "arg is not an array reference");
#line 860 "rxvtperl.xs"
{
        rxvt_term *term = new rxvt_term;

	stringvec *argv = new stringvec;
	stringvec *envv = new stringvec;

        for (int i = 0; i <= AvFILL (arg); i++)
          argv->push_back (strdup (SvPVbyte_nolen (*av_fetch (arg, i, 1))));

        for (int i = AvFILL (env) + 1; i--; )
          envv->push_back (strdup (SvPVbyte_nolen (*av_fetch (env, i, 1))));

        envv->push_back (0);

        try
          {
            term->init (argv, envv);
          }
        catch (const class rxvt_failure_exception &e)
          {
            term->destroy ();
            croak ("error while initializing new terminal instance");
          }

        RETVAL = term && term->perl.self
                 ? newSVterm (term) : &PL_sv_undef;
}
#line 899 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_destroy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::destroy(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));

	THIS->destroy();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_set_should_invoke); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_set_should_invoke)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::set_should_invoke(THIS, htype, inc)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	htype = (int)SvIV(ST(1));
	int	inc = (int)SvIV(ST(2));
#line 896 "rxvtperl.xs"
        THIS->perl.should_invoke [htype] += inc;
#line 934 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_grab_button); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_grab_button)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: urxvt::term::grab_button(THIS, button, modifiers, window= THIS->vt)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	button = (int)SvIV(ST(1));
	U32	modifiers = (unsigned long)SvUV(ST(2));
	Window	window;

	if (items < 4)
	    window = THIS->vt;
	else {
	    window = (Window)SvUV(ST(3));
	}
#line 901 "rxvtperl.xs"
        RETVAL = XGrabButton (THIS->dpy, button, modifiers, window, 1,
                              ButtonPressMask | ButtonReleaseMask | EnterWindowMask | LeaveWindowMask | PointerMotionMask,
                              GrabModeSync, GrabModeSync, None, GRAB_CURSOR);
#line 963 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_ungrab_button); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ungrab_button)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: urxvt::term::ungrab_button(THIS, button, modifiers, window= THIS->vt)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	button = (int)SvIV(ST(1));
	U32	modifiers = (unsigned long)SvUV(ST(2));
	Window	window;

	if (items < 4)
	    window = THIS->vt;
	else {
	    window = (Window)SvUV(ST(3));
	}
#line 909 "rxvtperl.xs"
        RETVAL = XUngrabButton (THIS->dpy, button, modifiers, window);
#line 991 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XGrabKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XGrabKey)
{
    dXSARGS;
    if (items < 3 || items > 7)
	Perl_croak(aTHX_ "Usage: urxvt::term::XGrabKey(THIS, keycode, modifiers, window= THIS->vt, owner_events= 1, pointer_mode= GrabModeAsync, keyboard_mode= GrabModeAsync)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	keycode = (int)SvIV(ST(1));
	U32	modifiers = (unsigned long)SvUV(ST(2));
	Window	window;
	int	owner_events;
	int	pointer_mode;
	int	keyboard_mode;

	if (items < 4)
	    window = THIS->vt;
	else {
	    window = (Window)SvUV(ST(3));
	}

	if (items < 5)
	    owner_events = 1;
	else {
	    owner_events = (int)SvIV(ST(4));
	}

	if (items < 6)
	    pointer_mode = GrabModeAsync;
	else {
	    pointer_mode = (int)SvIV(ST(5));
	}

	if (items < 7)
	    keyboard_mode = GrabModeAsync;
	else {
	    keyboard_mode = (int)SvIV(ST(6));
	}
#line 916 "rxvtperl.xs"
        XGrabKey (THIS->dpy, keycode, modifiers, window, owner_events, pointer_mode, keyboard_mode);
#line 1038 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XUngrabKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XUngrabKey)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: urxvt::term::XUngrabKey(THIS, keycode, modifiers, window= THIS->vt)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	keycode = (int)SvIV(ST(1));
	U32	modifiers = (unsigned long)SvUV(ST(2));
	Window	window;

	if (items < 4)
	    window = THIS->vt;
	else {
	    window = (Window)SvUV(ST(3));
	}
#line 921 "rxvtperl.xs"
	XUngrabKey (THIS->dpy, keycode, modifiers, window);
#line 1063 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XUngrabKeyboard); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XUngrabKeyboard)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XUngrabKeyboard(THIS, eventtime)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Time	eventtime = (Time)SvUV(ST(1));
#line 926 "rxvtperl.xs"
	XUngrabKeyboard (THIS->dpy, eventtime);
#line 1080 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_grab); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_grab)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::grab(THIS, eventtime, sync= 0)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	bool	RETVAL;
	Time	eventtime = (Time)SvUV(ST(1));
	int	sync;

	if (items < 3)
	    sync = 0;
	else {
	    sync = (int)SvIV(ST(2));
	}
#line 931 "rxvtperl.xs"
{
        int mode = sync ? GrabModeSync : GrabModeAsync;

        THIS->perl.grabtime = 0;

        if (!XGrabPointer (THIS->dpy, THIS->vt, 0,
                           ButtonPressMask | ButtonReleaseMask | EnterWindowMask | LeaveWindowMask | PointerMotionMask,
                           mode, mode, None, GRAB_CURSOR, eventtime))
          if (!XGrabKeyboard (THIS->dpy, THIS->vt, 0, mode, mode, eventtime))
            THIS->perl.grabtime = eventtime;
          else
            XUngrabPointer (THIS->dpy, eventtime);

        RETVAL = !!THIS->perl.grabtime;
}
#line 1119 "rxvtperl.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_allow_events_async); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_allow_events_async)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::allow_events_async(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 952 "rxvtperl.xs"
        XAllowEvents (THIS->dpy, AsyncBoth,      THIS->perl.grabtime);
#line 1137 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_allow_events_sync); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_allow_events_sync)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::allow_events_sync(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 957 "rxvtperl.xs"
        XAllowEvents (THIS->dpy, SyncBoth,       THIS->perl.grabtime);
#line 1153 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_allow_events_replay); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_allow_events_replay)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::allow_events_replay(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 962 "rxvtperl.xs"
        XAllowEvents (THIS->dpy, ReplayPointer,  THIS->perl.grabtime);
        XAllowEvents (THIS->dpy, ReplayKeyboard, THIS->perl.grabtime);
#line 1170 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_ungrab); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ungrab)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::ungrab(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 968 "rxvtperl.xs"
        ungrab (THIS);
#line 1186 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XStringToKeysym); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XStringToKeysym)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XStringToKeysym(THIS, string)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	char *	string = (char *)SvPV_nolen(ST(1));
#line 973 "rxvtperl.xs"
        RETVAL = XStringToKeysym (string);
#line 1205 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XKeysymToString); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XKeysymToString)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XKeysymToString(THIS, sym)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	char *	RETVAL;
	dXSTARG;
	int	sym = (int)SvIV(ST(1));
#line 979 "rxvtperl.xs"
        RETVAL = XKeysymToString (sym);
#line 1225 "rxvtperl.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XKeysymToKeycode); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XKeysymToKeycode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XKeysymToKeycode(THIS, sym)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	sym = (int)SvIV(ST(1));
#line 985 "rxvtperl.xs"
        RETVAL = XKeysymToKeycode (THIS->dpy, sym);
#line 1245 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XKeycodeToKeysym); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XKeycodeToKeysym)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::XKeycodeToKeysym(THIS, code, index)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	code = (int)SvIV(ST(1));
	int	index = (int)SvIV(ST(2));
#line 991 "rxvtperl.xs"
        RETVAL = XKeycodeToKeysym (THIS->dpy, code, index);
#line 1266 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_strwidth); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_strwidth)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::strwidth(THIS, str)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	SV *	str = ST(1);
#line 997 "rxvtperl.xs"
{
        wchar_t *wstr = sv2wcs (str);

	rxvt_push_locale (THIS->locale);
        RETVAL = 0;
        for (wchar_t *wc = wstr; *wc; wc++)
          {
            int w = WCWIDTH (*wc);

            if (w)
              RETVAL += max (w, 1);
          }
        rxvt_pop_locale ();

        free (wstr);
}
#line 1301 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_locale_encode); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_locale_encode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::locale_encode(THIS, str)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
	SV *	str = ST(1);
#line 1019 "rxvtperl.xs"
{
        wchar_t *wstr = sv2wcs (str);

	rxvt_push_locale (THIS->locale);
        char *mbstr = rxvt_wcstombs (wstr);
        rxvt_pop_locale ();

        free (wstr);

        RETVAL = newSVpv (mbstr, 0);
        free (mbstr);
}
#line 1331 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_locale_decode); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_locale_decode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::locale_decode(THIS, octets)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
	SV *	octets = ST(1);
#line 1037 "rxvtperl.xs"
{
	STRLEN len;
        char *data = SvPVbyte (octets, len);

	rxvt_push_locale (THIS->locale);
        wchar_t *wstr = rxvt_mbstowcs (data, len);
        rxvt_pop_locale ();

        RETVAL = wcs2sv (wstr);
        free (wstr);
}
#line 1361 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_locale); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_locale)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::locale(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	char *	RETVAL;
	dXSTARG;
#line 1054 "rxvtperl.xs"
        RETVAL = THIS->locale;
#line 1381 "rxvtperl.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#define TERM_OFFSET(sym) offsetof (TermWin_t, sym)
#define TERM_OFFSET_width      TERM_OFFSET(width)
#define TERM_OFFSET_height     TERM_OFFSET(height)
#define TERM_OFFSET_fwidth     TERM_OFFSET(fwidth)
#define TERM_OFFSET_fheight    TERM_OFFSET(fheight)
#define TERM_OFFSET_fbase      TERM_OFFSET(fbase)
#define TERM_OFFSET_nrow       TERM_OFFSET(nrow)
#define TERM_OFFSET_ncol       TERM_OFFSET(ncol)
#define TERM_OFFSET_focus      TERM_OFFSET(focus)
#define TERM_OFFSET_mapped     TERM_OFFSET(mapped)
#define TERM_OFFSET_int_bwidth TERM_OFFSET(int_bwidth)
#define TERM_OFFSET_ext_bwidth TERM_OFFSET(ext_bwidth)
#define TERM_OFFSET_lineSpace  TERM_OFFSET(lineSpace)
#define TERM_OFFSET_saveLines  TERM_OFFSET(saveLines)
#define TERM_OFFSET_total_rows TERM_OFFSET(total_rows)
#define TERM_OFFSET_top_row    TERM_OFFSET(top_row)

XS(XS_urxvt__term_width); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_width)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(THIS)", GvNAME(CvGV(cv)));
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
#line 1095 "rxvtperl.xs"
        RETVAL = *(int *)((char *)THIS + ix);
#line 1417 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_ModLevel3Mask); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ModLevel3Mask)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(THIS)", GvNAME(CvGV(cv)));
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	unsigned int	RETVAL;
	dXSTARG;
#line 1108 "rxvtperl.xs"
        switch (ix)
          {
            case 0: RETVAL = THIS->ModLevel3Mask;  break;
            case 1: RETVAL = THIS->ModMetaMask;    break;
            case 2: RETVAL = THIS->ModNumLockMask; break;
            case 3: RETVAL = THIS->current_screen; break;
#ifdef CURSOR_BLINK
            case 4: RETVAL = THIS->hidden_cursor;  break;
#endif
          }
#line 1446 "rxvtperl.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_display_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_display_id)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(THIS)", GvNAME(CvGV(cv)));
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	char *	RETVAL;
	dXSTARG;
#line 1127 "rxvtperl.xs"
        switch (ix)
          {
            case 0: RETVAL = THIS->display->id; break;
            case 1: RETVAL = THIS->locale;      break;
          }
#line 1470 "rxvtperl.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_envv); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_envv)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(THIS)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
#line 1140 "rxvtperl.xs"
{
	stringvec *vec = ix ? THIS->argv : THIS->envv;

        EXTEND (SP, vec->size ());

        for (char **i = vec->begin (); i != vec->end (); ++i)
          if (*i)
            PUSHs (sv_2mortal (newSVpv (*i, 0)));
}
#line 1498 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_pty_ev_events); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_pty_ev_events)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::pty_ev_events(THIS, events= ev::UNDEF)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	events;

	if (items < 2)
	    events = ev::UNDEF;
	else {
	    events = (int)SvIV(ST(1));
	}
#line 1153 "rxvtperl.xs"
        RETVAL = THIS->pty_ev.events;
        if (events != ev::UNDEF)
          THIS->pty_ev.set (events);
#line 1526 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_pty_fd); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_pty_fd)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::pty_fd(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
#line 1162 "rxvtperl.xs"
        RETVAL = THIS->pty->pty;
#line 1545 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_parent); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_parent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::parent(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	RETVAL;
	dXSTARG;
#line 1169 "rxvtperl.xs"
        RETVAL = THIS->parent [0];
#line 1564 "rxvtperl.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_vt); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_vt)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::vt(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	RETVAL;
	dXSTARG;
#line 1176 "rxvtperl.xs"
        RETVAL = THIS->vt;
#line 1583 "rxvtperl.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_vt_emask_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_vt_emask_add)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::vt_emask_add(THIS, emask)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	U32	emask = (unsigned long)SvUV(ST(1));
#line 1183 "rxvtperl.xs"
        THIS->vt_emask_perl |= emask;
        THIS->vt_select_input ();
#line 1602 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_rstyle); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_rstyle)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::rstyle(THIS, new_rstyle= THIS->rstyle)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	U32	RETVAL;
	dXSTARG;
	U32	new_rstyle;

	if (items < 2)
	    new_rstyle = THIS->rstyle;
	else {
	    new_rstyle = (unsigned long)SvUV(ST(1));
	}
#line 1189 "rxvtperl.xs"
        RETVAL = THIS->rstyle;
        THIS->rstyle = new_rstyle;
#line 1628 "rxvtperl.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_view_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_view_start)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::view_start(THIS, newval= 1)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	newval;

	if (items < 2)
	    newval = 1;
	else {
	    newval = (int)SvIV(ST(1));
	}
#line 1198 "rxvtperl.xs"
{
        RETVAL = THIS->view_start;

        if (newval <= 0)
          THIS->scr_changeview (max (newval, THIS->top_row));
}
#line 1659 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_focus_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_focus_in)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::focus_in(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));

	THIS->focus_in();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_focus_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_focus_out)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::focus_out(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));

	THIS->focus_out();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_key_press); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_key_press)
{
    dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(THIS, state, keycode, time= CurrentTime)", GvNAME(CvGV(cv)));
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	unsigned int	state = (unsigned int)SvUV(ST(1));
	unsigned int	keycode = (unsigned int)SvUV(ST(2));
	Time	time;

	if (items < 4)
	    time = CurrentTime;
	else {
	    time = (Time)SvUV(ST(3));
	}
#line 1218 "rxvtperl.xs"
{
        XKeyEvent xkey;

        memset (&xkey, 0, sizeof (xkey));

        xkey.time      = time;
        xkey.state     = state;
        xkey.keycode   = keycode;

        xkey.type      = ix ? KeyRelease : KeyPress;
        xkey.display   = THIS->dpy;
        xkey.window    = THIS->vt;
        xkey.root      = THIS->display->root;
        xkey.subwindow = THIS->vt;

        if (ix)
          THIS->key_release (xkey);
        else
          THIS->key_press (xkey);
}
#line 1735 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_want_refresh); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_want_refresh)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::want_refresh(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 1242 "rxvtperl.xs"
        THIS->want_refresh = 1;
	THIS->refresh_check ();
#line 1752 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_ROW_t); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ROW_t)
{
    dXSARGS;
    if (items < 2 || items > 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::ROW_t(THIS, row_number, new_text= 0, start_col= 0, start_ofs= 0, max_len= MAX_COLS)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	row_number = (int)SvIV(ST(1));
	SV *	new_text;
	int	start_col;
	int	start_ofs;
	int	max_len;

	if (items < 3)
	    new_text = 0;
	else {
	    new_text = ST(2);
	}

	if (items < 4)
	    start_col = 0;
	else {
	    start_col = (int)SvIV(ST(3));
	}

	if (items < 5)
	    start_ofs = 0;
	else {
	    start_ofs = (int)SvIV(ST(4));
	}

	if (items < 6)
	    max_len = MAX_COLS;
	else {
	    max_len = (int)SvIV(ST(5));
	}
#line 1248 "rxvtperl.xs"
{
        if (!IN_RANGE_EXC (row_number, THIS->top_row, THIS->nrow))
          XSRETURN_EMPTY;

        line_t &l = ROW(row_number);

        if (GIMME_V != G_VOID)
          {
            wchar_t *wstr = rxvt_temp_buf<wchar_t> (THIS->ncol);

            for (int col = 0; col < THIS->ncol; col++)
              wstr [col] = l.t [col];

            XPUSHs (sv_2mortal (wcs2sv (wstr, THIS->ncol)));
          }

        if (new_text)
          {
            wchar_t *wstr = sv2wcs (new_text);

            int len = min (wcslen (wstr) - start_ofs, max_len);

            if (start_col < 0 || start_col + len > THIS->ncol)
              {
                free (wstr);
                croak ("new_text extends beyond horizontal margins");
              }

            for (int col = start_col; col < start_col + len; col++)
              {
                l.t [col] = wstr [start_ofs + col - start_col];
                l.r [col] = SET_FONT (l.r [col], THIS->fontset [GET_STYLE (l.r [col])]->find_font (l.t [col]));
              }

            free (wstr);
          }
}
#line 1834 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_ROW_r); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ROW_r)
{
    dXSARGS;
    if (items < 2 || items > 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::ROW_r(THIS, row_number, new_rend= 0, start_col= 0, start_ofs= 0, max_len= MAX_COLS)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	row_number = (int)SvIV(ST(1));
	SV *	new_rend;
	int	start_col;
	int	start_ofs;
	int	max_len;

	if (items < 3)
	    new_rend = 0;
	else {
	    new_rend = ST(2);
	}

	if (items < 4)
	    start_col = 0;
	else {
	    start_col = (int)SvIV(ST(3));
	}

	if (items < 5)
	    start_ofs = 0;
	else {
	    start_ofs = (int)SvIV(ST(4));
	}

	if (items < 6)
	    max_len = MAX_COLS;
	else {
	    max_len = (int)SvIV(ST(5));
	}
#line 1289 "rxvtperl.xs"
{
        if (!IN_RANGE_EXC (row_number, THIS->top_row, THIS->nrow))
          XSRETURN_EMPTY;

        line_t &l = ROW(row_number);

        if (GIMME_V != G_VOID)
          {
            AV *av = newAV ();

            av_extend (av, THIS->ncol - 1);
            for (int col = 0; col < THIS->ncol; col++)
              av_store (av, col, newSViv (l.r [col]));

            XPUSHs (sv_2mortal (newRV_noinc ((SV *)av)));
          }

        if (new_rend)
          {
            if (!SvROK (new_rend) || SvTYPE (SvRV (new_rend)) != SVt_PVAV)
              croak ("new_rend must be arrayref");

            AV *av = (AV *)SvRV (new_rend);
            int len = min (AvFILL (av) + 1 - start_ofs, max_len);

            if (start_col < 0 || start_col + len > THIS->ncol)
              croak ("new_rend array extends beyond horizontal margins");

            for (int col = start_col; col < start_col + len; col++)
              {
                rend_t r = SvIV (*av_fetch (av, start_ofs + col - start_col, 1)) & ~RS_fontMask;

                l.r [col] = SET_FONT (r, THIS->fontset [GET_STYLE (r)]->find_font (l.t [col]));
              }
          }
}
#line 1916 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_ROW_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ROW_l)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::ROW_l(THIS, row_number, new_length= -1)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	int	row_number = (int)SvIV(ST(1));
	int	new_length;

	if (items < 3)
	    new_length = -1;
	else {
	    new_length = (int)SvIV(ST(2));
	}
#line 1329 "rxvtperl.xs"
{
        if (!IN_RANGE_EXC (row_number, THIS->top_row, THIS->nrow))
          XSRETURN_EMPTY;

        line_t &l = ROW(row_number);
        RETVAL = l.l;

        if (new_length >= 0)
          l.l = new_length;
}
#line 1952 "rxvtperl.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_ROW_is_longer); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_ROW_is_longer)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::ROW_is_longer(THIS, row_number, new_is_longer= -1)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	bool	RETVAL;
	int	row_number = (int)SvIV(ST(1));
	int	new_is_longer;

	if (items < 3)
	    new_is_longer = -1;
	else {
	    new_is_longer = (int)SvIV(ST(2));
	}
#line 1345 "rxvtperl.xs"
{
        if (!IN_RANGE_EXC (row_number, THIS->top_row, THIS->nrow))
          XSRETURN_EMPTY;

        line_t &l = ROW(row_number);
        RETVAL = l.is_longer ();

        if (new_is_longer >= 0)
          l.is_longer (new_is_longer);
}
#line 1987 "rxvtperl.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_special_encode); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_special_encode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::special_encode(THIS, string)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
	SV *	string = ST(1);
#line 1361 "rxvtperl.xs"
{
        wchar_t *wstr = sv2wcs (string);
        int wlen = wcslen (wstr);
        wchar_t *rstr = rxvt_temp_buf<wchar_t> (wlen * 2); // cannot become longer

	rxvt_push_locale (THIS->locale);

        wchar_t *r = rstr;
        for (wchar_t *s = wstr; *s; s++)
          {
            int w = WCWIDTH (*s);

            if (w == 0)
              {
                if (r == rstr)
                  croak ("leading combining character unencodable");

                unicode_t n = rxvt_compose (r[-1], *s);
                if (n == NOCHAR)
                  n = rxvt_composite.compose (r[-1], *s);

                r[-1] = n;
              }
#if !UNICODE_3
            else if (*s >= 0x10000)
              *r++ = rxvt_composite.compose (*s);
#endif
            else
              *r++ = *s;

            // the *2 above only allows wcwidth <= 2
            if (w > 1)
              *r++ = NOCHAR;
          }

	rxvt_pop_locale ();

        RETVAL = wcs2sv (rstr, r - rstr);
}
#line 2045 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_special_decode); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_special_decode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::special_decode(THIS, text)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
	SV *	text = ST(1);
#line 1406 "rxvtperl.xs"
{
        wchar_t *wstr = sv2wcs (text);
        int dlen = 0;

        // find length
        for (wchar_t *s = wstr; *s; s++)
          if (*s == NOCHAR)
            ;
          else if (IS_COMPOSE (*s))
            dlen += rxvt_composite.expand (*s, 0);
          else
            dlen++;

        wchar_t *rstr = rxvt_temp_buf<wchar_t> (dlen);

        // decode
        wchar_t *r = rstr;
        for (wchar_t *s = wstr; *s; s++)
          if (*s == NOCHAR)
            ;
          else if (IS_COMPOSE (*s))
            r += rxvt_composite.expand (*s, r);
          else
            *r++ = *s;

        RETVAL = wcs2sv (rstr, r - rstr);
}
#line 2091 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term__resource); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term__resource)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: urxvt::term::_resource(THIS, name, index, newval= 0)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	char *	name = (char *)SvPV_nolen(ST(1));
	int	index = (int)SvIV(ST(2));
	SV *	newval;

	if (items < 4)
	    newval = 0;
	else {
	    newval = ST(3);
	}
#line 1439 "rxvtperl.xs"
{
	static const struct resval { const char *name; int value; } *rs, rslist [] = {
#	  define def(name) { # name, Rs_ ## name },
#	  define reserve(name,count)
#	  include "rsinc.h"
#	  undef def
#	  undef reserve
        };

        rs = rslist + sizeof (rslist) / sizeof (rslist [0]);

        if (*name)
          {
            do {
              if (rs-- == rslist)
                croak ("no such resource '%s', requested", name);
            } while (strcmp (name, rs->name));

            index += rs->value;
          }
        else
          {
            --rs;
            name = "";
          }

        if (!IN_RANGE_EXC (index, 0, NUM_RESOURCES))
          croak ("requested out-of-bound resource %s+%d,", name, index - rs->value);

        if (GIMME_V != G_VOID)
          XPUSHs (THIS->rs [index] ? sv_2mortal (newSVpv (THIS->rs [index], 0)) : &PL_sv_undef);

        if (newval)
          {
            if (SvOK (newval))
              {
                char *str = strdup (SvPVbyte_nolen (newval));
                THIS->rs [index] = str;
                THIS->allocated.push_back (str);
              }
            else
              THIS->rs [index] = 0;
          }
}
#line 2162 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_x_resource); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_x_resource)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::x_resource(THIS, name)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	const char *	RETVAL;
	dXSTARG;
	const char *	name = (const char *)SvPV_nolen(ST(1));

	RETVAL = THIS->x_resource(name);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_option)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::option(THIS, optval, set= -1)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	bool	RETVAL;
	U8	optval = (U8)SvUV(ST(1));
	int	set;

	if (items < 3)
	    set = -1;
	else {
	    set = (int)SvIV(ST(2));
	}
#line 1490 "rxvtperl.xs"
{
	RETVAL = THIS->option (optval);

        if (set >= 0)
          {
            THIS->set_option (optval, set);

            if (THIS->env_colorfgbg [0]) // avoid doing this before START
              switch (optval)
                {
                  case Opt_skipBuiltinGlyphs:
                    THIS->set_fonts ();
                    THIS->scr_remap_chars ();
                    THIS->scr_touch (true);
                    THIS->want_refresh = 1;
                    THIS->refresh_check ();
                    break;

                  case Opt_cursorUnderline:
                    THIS->want_refresh = 1;
                    THIS->refresh_check ();
                    break;

                }
          }
}
#line 2232 "rxvtperl.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_parse_keysym); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_parse_keysym)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::parse_keysym(THIS, keysym, str)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	bool	RETVAL;
	char *	keysym = (char *)SvPV_nolen(ST(1));
	char *	str = (char *)SvPV_nolen(ST(2));
#line 1526 "rxvtperl.xs"
        RETVAL = 0 < THIS->parse_keysym (keysym, str);
        THIS->keyboard->register_done ();
#line 2254 "rxvtperl.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_screen_cur); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_screen_cur)
{
    dXSARGS;
    dXSI32;
    if (items < 1)
       Perl_croak(aTHX_ "Usage: %s(THIS, ...)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
#line 1540 "rxvtperl.xs"
{
        row_col_t &rc = ix == 0 ? THIS->screen.cur
                      : ix == 1 ? THIS->selection.beg
                      : ix == 2 ? THIS->selection.end
                      :           THIS->selection.mark;

        if (GIMME_V != G_VOID)
          {
            EXTEND (SP, 2);
            PUSHs (sv_2mortal (newSViv (rc.row)));
            PUSHs (sv_2mortal (newSViv (rc.col)));
          }

        if (items == 3)
          {
            rc.row = SvIV (ST (1));
            rc.col = SvIV (ST (2));

            if (ix == 2)
              {
                if (rc.col == 0)
                  {
                    // col == 0 means end of previous line
                    rc.row--;
                    rc.col = THIS->ncol;
                  }
                else if (IN_RANGE_EXC (rc.row, THIS->top_row, THIS->nrow)
                         && rc.col > ROW(rc.row).l)
                  {
                    // col >= length means while line and add newline
                    rc.col = THIS->ncol;
                  }
              }

            clamp_it (rc.col, 0, THIS->ncol);
            clamp_it (rc.row, THIS->top_row, THIS->nrow - 1);

            if (ix)
              {
                THIS->want_refresh = 1;
                THIS->refresh_check ();
              }
          }
}
#line 2317 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_cur_charset); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_cur_charset)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::cur_charset(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	char	RETVAL;
	dXSTARG;
#line 1588 "rxvtperl.xs"
        RETVAL = THIS->charsets [THIS->screen.charset];
#line 2336 "rxvtperl.c"
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_selection_clear); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_selection_clear)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::selection_clear(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));

	THIS->selection_clear();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_selection_make); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_selection_make)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::selection_make(THIS, eventtime, rect= false)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Time	eventtime = (Time)SvUV(ST(1));
	bool	rect;

	if (items < 3)
	    rect = false;
	else {
	    rect = (bool)SvTRUE(ST(2));
	}
#line 1598 "rxvtperl.xs"
        THIS->selection.op = SELECTION_CONT;
        THIS->selection.rect = rect;
        THIS->selection_make (eventtime);
#line 2378 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_selection_grab); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_selection_grab)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::selection_grab(THIS, eventtime)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	RETVAL;
	dXSTARG;
	Time	eventtime = (Time)SvUV(ST(1));

	RETVAL = THIS->selection_grab(eventtime);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_selection); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_selection)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::selection(THIS, newtext= 0)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	newtext;

	if (items < 2)
	    newtext = 0;
	else {
	    newtext = ST(1);
	}
#line 1608 "rxvtperl.xs"
{
        if (GIMME_V != G_VOID)
          XPUSHs (THIS->selection.text
                  ? sv_2mortal (wcs2sv (THIS->selection.text, THIS->selection.len))
                  : &PL_sv_undef);

        if (newtext)
          {
            free (THIS->selection.text);

            THIS->selection.text = sv2wcs (newtext);
            THIS->selection.len = wcslen (THIS->selection.text);
          }
}
#line 2434 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_scr_xor_rect); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_scr_xor_rect)
{
    dXSARGS;
    if (items < 5 || items > 7)
	Perl_croak(aTHX_ "Usage: urxvt::term::scr_xor_rect(THIS, beg_row, beg_col, end_row, end_col, rstyle1= RS_RVid, rstyle2= RS_RVid | RS_Uline)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	beg_row = (int)SvIV(ST(1));
	int	beg_col = (int)SvIV(ST(2));
	int	end_row = (int)SvIV(ST(3));
	int	end_col = (int)SvIV(ST(4));
	U32	rstyle1;
	U32	rstyle2;

	if (items < 6)
	    rstyle1 = RS_RVid;
	else {
	    rstyle1 = (unsigned long)SvUV(ST(5));
	}

	if (items < 7)
	    rstyle2 = RS_RVid | RS_Uline;
	else {
	    rstyle2 = (unsigned long)SvUV(ST(6));
	}

	THIS->scr_xor_rect(beg_row, beg_col, end_row, end_col, rstyle1, rstyle2);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_scr_xor_span); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_scr_xor_span)
{
    dXSARGS;
    if (items < 5 || items > 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::scr_xor_span(THIS, beg_row, beg_col, end_row, end_col, rstyle= RS_RVid)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	beg_row = (int)SvIV(ST(1));
	int	beg_col = (int)SvIV(ST(2));
	int	end_row = (int)SvIV(ST(3));
	int	end_col = (int)SvIV(ST(4));
	U32	rstyle;

	if (items < 6)
	    rstyle = RS_RVid;
	else {
	    rstyle = (unsigned long)SvUV(ST(5));
	}

	THIS->scr_xor_span(beg_row, beg_col, end_row, end_col, rstyle);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_scr_bell); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_scr_bell)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::scr_bell(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));

	THIS->scr_bell();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_scr_change_screen); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_scr_change_screen)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::scr_change_screen(THIS, screen)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	int	screen = (int)SvIV(ST(1));

	THIS->scr_change_screen(screen);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_scr_add_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_scr_add_lines)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::scr_add_lines(THIS, string)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	string = ST(1);
#line 1638 "rxvtperl.xs"
{
        wchar_t *wstr = sv2wcs (string);
        THIS->scr_add_lines (wstr, wcslen (wstr));
        free (wstr);
}
#line 2546 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_tt_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_tt_write)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::tt_write(THIS, octets)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	octets = ST(1);
#line 1647 "rxvtperl.xs"
          STRLEN len;
          char *str = SvPVbyte (octets, len);
#line 2564 "rxvtperl.c"

	THIS->tt_write(str, len);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_cmd_parse); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_cmd_parse)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::cmd_parse(THIS, octets)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	octets = ST(1);
#line 1655 "rxvtperl.xs"
{
	STRLEN len;
        char *str = SvPVbyte (octets, len);

        char *old_cmdbuf_ptr  = THIS->cmdbuf_ptr;
        char *old_cmdbuf_endp = THIS->cmdbuf_endp;

        THIS->cmdbuf_ptr  = str;
        THIS->cmdbuf_endp = str + len;

	rxvt_push_locale (THIS->locale);
        THIS->cmd_parse ();
	rxvt_pop_locale ();

        THIS->cmdbuf_ptr  = old_cmdbuf_ptr;
        THIS->cmdbuf_endp = old_cmdbuf_endp;
}
#line 2599 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_overlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_overlay)
{
    dXSARGS;
    if (items < 5 || items > 7)
	Perl_croak(aTHX_ "Usage: urxvt::term::overlay(THIS, x, y, w, h, rstyle= OVERLAY_RSTYLE, border= 2)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	SV *	RETVAL;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	w = (int)SvIV(ST(3));
	int	h = (int)SvIV(ST(4));
	int	rstyle;
	int	border;

	if (items < 6)
	    rstyle = OVERLAY_RSTYLE;
	else {
	    rstyle = (int)SvIV(ST(5));
	}

	if (items < 7)
	    border = 2;
	else {
	    border = (int)SvIV(ST(6));
	}
#line 1676 "rxvtperl.xs"
{
        overlay *o = new overlay (THIS, x, y, w, h, rstyle, border);
        RETVAL = newSVptr ((void *)o, "urxvt::overlay");
        o->self = (HV *)SvRV (RETVAL);
}
#line 2638 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XListProperties); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XListProperties)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XListProperties(THIS, window)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
#line 1691 "rxvtperl.xs"
{
	int count;
	Atom *props = XListProperties (THIS->dpy, window, &count);

        EXTEND (SP, count);
        while (count--)
          PUSHs (newSVuv ((U32)props [count]));

        XFree (props);
}
#line 2667 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_XGetWindowProperty); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XGetWindowProperty)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::XGetWindowProperty(THIS, window, property)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	Atom	property = (Atom)SvUV(ST(2));
#line 1705 "rxvtperl.xs"
{
        Atom type;
        int format;
        unsigned long nitems;
        unsigned long bytes_after;
        unsigned char *prop;

	XGetWindowProperty (THIS->dpy, window, property,
                            0, 1<<24, 0, AnyPropertyType,
                            &type, &format, &nitems, &bytes_after, &prop);

        if (type != None)
          {
            int elemsize = format == 16 ? sizeof (short)
                         : format == 32 ? sizeof (long)
                         :                1;

            EXTEND (SP, 3);
            PUSHs (newSVuv ((U32)type));
            PUSHs (newSViv (format));
            PUSHs (newSVpvn ((char *)prop, nitems * elemsize));
            XFree (prop);
          }
}
#line 2710 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__term_XChangeProperty); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XChangeProperty)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::XChangeProperty(THIS, window, property, type, format, data)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	Atom	property = (Atom)SvUV(ST(2));
	Atom	type = (Atom)SvUV(ST(3));
	int	format = (int)SvIV(ST(4));
	SV *	data = ST(5);
#line 1733 "rxvtperl.xs"
{
	STRLEN len;
        char *data_ = SvPVbyte (data, len);

        int elemsize = format == 16 ? sizeof (short)
                     : format == 32 ? sizeof (long)
                     :                1;

	XChangeProperty (THIS->dpy, window, property,
                         type, format, PropModeReplace,
                         (unsigned char *)data_, len / elemsize);
}
#line 2743 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XInternAtom); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XInternAtom)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::XInternAtom(term, atom_name, only_if_exists= FALSE)");
    {
	Atom	RETVAL;
	dXSTARG;
	rxvt_term *	term = SvTERM (ST(0));
	char *	atom_name = (char *)SvPV_nolen(ST(1));
	int	only_if_exists;

	if (items < 3)
	    only_if_exists = FALSE;
	else {
	    only_if_exists = (int)SvIV(ST(2));
	}

	RETVAL = XInternAtom(term->dpy, atom_name, only_if_exists);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XGetAtomName); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XGetAtomName)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XGetAtomName(term, atom)");
    {
	char *	RETVAL;
	dXSTARG;
	rxvt_term *	term = SvTERM (ST(0));
	Atom	atom = (Atom)SvUV(ST(1));

	RETVAL = XGetAtomName(term->dpy, atom);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 1754 "rxvtperl.xs"
        XFree (RETVAL);
#line 2791 "rxvtperl.c"
    }
    XSRETURN(1);
}


XS(XS_urxvt__term_XDeleteProperty); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XDeleteProperty)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: urxvt::term::XDeleteProperty(term, window, property)");
    {
	rxvt_term *	term = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	Atom	property = (Atom)SvUV(ST(2));

	XDeleteProperty(term->dpy, window, property);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_DefaultRootWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_DefaultRootWindow)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::term::DefaultRootWindow(THIS)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	RETVAL;
	dXSTARG;
#line 1763 "rxvtperl.xs"
        RETVAL = THIS->display->root;
#line 2826 "rxvtperl.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if 0
#define XSubPPtmpAAAA 1


XS(XS_urxvt__term_XCreateSimpleWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XCreateSimpleWindow)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::XCreateSimpleWindow(term, parent, x, y, width, height)");
    {
	Window	RETVAL;
	dXSTARG;
	rxvt_term *	term = SvTERM (ST(0));
	Window	parent = (Window)SvUV(ST(1));
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	unsigned int	width = (unsigned int)SvUV(ST(4));
	unsigned int	height = (unsigned int)SvUV(ST(5));

	RETVAL = XCreateSimpleWindow(term->dpy, (Window)parent,
                x, y, width, height, 0,
                term->pix_colors_focused[Color_border],
                term->pix_colors_focused[Color_border]);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_urxvt__term_XReparentWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XReparentWindow)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: urxvt::term::XReparentWindow(term, window, parent, x= 0, y= 0)");
    {
	rxvt_term *	term = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	Window	parent = (Window)SvUV(ST(2));
	int	x;
	int	y;

	if (items < 4)
	    x = 0;
	else {
	    x = (int)SvIV(ST(3));
	}

	if (items < 5)
	    y = 0;
	else {
	    y = (int)SvIV(ST(4));
	}

	XReparentWindow(term->dpy, window, parent, x, y);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XMapWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XMapWindow)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XMapWindow(term, window)");
    {
	rxvt_term *	term = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));

	XMapWindow(term->dpy, window);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XUnmapWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XUnmapWindow)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::term::XUnmapWindow(term, window)");
    {
	rxvt_term *	term = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));

	XUnmapWindow(term->dpy, window);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XMoveResizeWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XMoveResizeWindow)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: urxvt::term::XMoveResizeWindow(term, window, x, y, width, height)");
    {
	rxvt_term *	term = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	unsigned int	width = (unsigned int)SvUV(ST(4));
	unsigned int	height = (unsigned int)SvUV(ST(5));

	XMoveResizeWindow(term->dpy, window, x, y, width, height);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XChangeInput); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XChangeInput)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: urxvt::term::XChangeInput(THIS, window, add_events, del_events= 0)");
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	window = (Window)SvUV(ST(1));
	U32	add_events = (unsigned long)SvUV(ST(2));
	U32	del_events;

	if (items < 4)
	    del_events = 0;
	else {
	    del_events = (unsigned long)SvUV(ST(3));
	}
#line 1797 "rxvtperl.xs"
{
	XWindowAttributes attr;
        XGetWindowAttributes (THIS->dpy, window, &attr);
        XSelectInput (THIS->dpy, window, attr.your_event_mask | add_events & ~del_events);
}
#line 2969 "rxvtperl.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__term_XTranslateCoordinates); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__term_XTranslateCoordinates)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: urxvt::term::XTranslateCoordinates(THIS, src, dst, x, y)");
    SP -= items;
    {
	rxvt_term *	THIS = SvTERM (ST(0));
	Window	src = (Window)SvUV(ST(1));
	Window	dst = (Window)SvUV(ST(2));
	int	x = (int)SvIV(ST(3));
	int	y = (int)SvIV(ST(4));
#line 1806 "rxvtperl.xs"
{
        int dx, dy;
        Window child;

        if (XTranslateCoordinates (THIS->dpy, src, dst, x, y, &dx, &dy, &child))
          {
            EXTEND (SP, 3);
            PUSHs (newSViv (dx));
            PUSHs (newSViv (dy));
            PUSHs (newSVuv (child));
          }
}
#line 3001 "rxvtperl.c"
	PUTBACK;
	return;
    }
}


XS(XS_urxvt__overlay_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__overlay_set)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: urxvt::overlay::set(THIS, x, y, text, rend= 0)");
    {
	overlay *	THIS = SvOVERLAY (ST(0));
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	SV *	text = ST(3);
	SV *	rend;

	if (items < 5)
	    rend = 0;
	else {
	    rend = ST(4);
	}

	THIS->set(x, y, text, rend);
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__overlay_show); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__overlay_show)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::overlay::show(THIS)");
    {
	overlay *	THIS = SvOVERLAY (ST(0));

	THIS->show();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__overlay_hide); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__overlay_hide)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::overlay::hide(THIS)");
    {
	overlay *	THIS = SvOVERLAY (ST(0));

	THIS->hide();
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__overlay_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__overlay_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::overlay::DESTROY(THIS)");
    {
	overlay *	THIS = SvOVERLAY (ST(0));

	delete THIS;
    }
    XSRETURN_EMPTY;
}


/* INCLUDE:  Including '$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |' from 'rxvtperl.xs' */


XS(XS_urxvt__watcher_cb); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__watcher_cb)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::watcher::cb(THIS, cb)");
    {
	perl_watcher *	THIS = SvWATCHER (ST(0));
	IOM_CHAINED	RETVAL;
	SV *	cb = ST(1);
#line 45 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->cb (cb);
#line 3093 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_new)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::timer::new(CLASS)");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 58 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        timer *w =  new timer;
        w->start (0);
        RETVAL = newSVptr ((void *)(perl_watcher *)w, "urxvt::timer");
        w->self = (HV *)SvRV (RETVAL);
#line 3116 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_at); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_at)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::timer::at(THIS)");
    {
	timer *	THIS = SvTIMER (ST(0));
	NV	RETVAL;
	dXSTARG;
#line 68 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        RETVAL = THIS->at;
#line 3136 "rxvtperl.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_interval); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_interval)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::timer::interval(THIS, repeat)");
    {
	timer *	THIS = SvTIMER (ST(0));
	IOM_CHAINED	RETVAL;
	NV	repeat = (NV)SvNV(ST(1));
#line 75 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->repeat = repeat;
#line 3155 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_set)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::timer::set(THIS, tstamp)");
    {
	timer *	THIS = SvTIMER (ST(0));
	IOM_CHAINED	RETVAL;
	NV	tstamp = (NV)SvNV(ST(1));
#line 82 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->set (tstamp);
#line 3176 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_start)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: urxvt::timer::start(THIS, tstamp= ev::now ())");
    {
	timer *	THIS = SvTIMER (ST(0));
	IOM_CHAINED	RETVAL;
	NV	tstamp;

	if (items < 2)
	    tstamp = ev::now ();
	else {
	    tstamp = (NV)SvNV(ST(1));
	}
#line 89 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->start (tstamp - ev::now ());
#line 3203 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_after); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_after)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::timer::after(THIS, delay)");
    {
	timer *	THIS = SvTIMER (ST(0));
	IOM_CHAINED	RETVAL;
	NV	delay = (NV)SvNV(ST(1));
#line 96 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->start (delay);
#line 3224 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_stop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::timer::stop(THIS)");
    {
	timer *	THIS = SvTIMER (ST(0));
	IOM_CHAINED	RETVAL;
#line 103 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->stop ();
#line 3244 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__timer_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__timer_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::timer::DESTROY(THIS)");
    {
	timer *	THIS = SvTIMER (ST(0));

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__iow_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_new)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iow::new(CLASS)");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 119 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        iow *w =  new iow;
        RETVAL = newSVptr ((void *)(perl_watcher *)w, "urxvt::iow");
        w->self = (HV *)SvRV (RETVAL);
#line 3281 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iow_fd); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_fd)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::iow::fd(THIS, fd)");
    {
	iow *	THIS = SvIOW (ST(0));
	IOM_CHAINED	RETVAL;
	int	fd = (int)SvIV(ST(1));
#line 128 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->fd = fd;
#line 3301 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iow_events); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_events)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::iow::events(THIS, events)");
    {
	iow *	THIS = SvIOW (ST(0));
	IOM_CHAINED	RETVAL;
	short	events = (short)SvIV(ST(1));
#line 135 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->events = events;
#line 3322 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iow_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_start)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iow::start(THIS)");
    {
	iow *	THIS = SvIOW (ST(0));
	IOM_CHAINED	RETVAL;
#line 142 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->start ();
#line 3342 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iow_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_stop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iow::stop(THIS)");
    {
	iow *	THIS = SvIOW (ST(0));
	IOM_CHAINED	RETVAL;
#line 149 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->stop ();
#line 3362 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iow_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iow_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iow::DESTROY(THIS)");
    {
	iow *	THIS = SvIOW (ST(0));

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__iw_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iw_new)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iw::new(CLASS)");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 165 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        iw *w =  new iw;
        RETVAL = newSVptr ((void *)(perl_watcher *)w, "urxvt::iw");
        w->self = (HV *)SvRV (RETVAL);
#line 3399 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iw_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iw_start)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iw::start(THIS)");
    {
	iw *	THIS = SvIW (ST(0));
	IOM_CHAINED	RETVAL;
#line 174 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->start ();
#line 3418 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iw_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iw_stop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iw::stop(THIS)");
    {
	iw *	THIS = SvIW (ST(0));
	IOM_CHAINED	RETVAL;
#line 181 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->stop ();
#line 3438 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__iw_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__iw_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::iw::DESTROY(THIS)");
    {
	iw *	THIS = SvIW (ST(0));

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS(XS_urxvt__pw_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__pw_new)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::pw::new(CLASS)");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 197 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        pw *w =  new pw;
        RETVAL = newSVptr ((void *)(perl_watcher *)w, "urxvt::pw");
        w->self = (HV *)SvRV (RETVAL);
#line 3475 "rxvtperl.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__pw_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__pw_start)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: urxvt::pw::start(THIS, pid)");
    {
	pw *	THIS = SvPW (ST(0));
	IOM_CHAINED	RETVAL;
	int	pid = (int)SvIV(ST(1));
#line 206 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->start (pid);
#line 3495 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__pw_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__pw_stop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::pw::stop(THIS)");
    {
	pw *	THIS = SvPW (ST(0));
	IOM_CHAINED	RETVAL;
#line 213 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
        THIS->stop ();
#line 3515 "rxvtperl.c"
	ST(0) = newSVsv (ST(0));

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_urxvt__pw_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_urxvt__pw_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: urxvt::pw::DESTROY(THIS)");
    {
	pw *	THIS = SvPW (ST(0));

	delete THIS;
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'rxvtperl.xs' from '$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |' */

#ifdef __cplusplus
extern "C"
#endif
XS(boot_urxvt); /* prototype to pass -Wmissing-prototypes */
XS(boot_urxvt)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXSproto("urxvt::warn", XS_urxvt_warn, file, "$");
        newXSproto("urxvt::fatal", XS_urxvt_fatal, file, "$");
        newXSproto("urxvt::_exit", XS_urxvt__exit, file, "$");
        newXSproto("urxvt::NOW", XS_urxvt_NOW, file, "");
        newXSproto("urxvt::GET_BASEFG", XS_urxvt_GET_BASEFG, file, "$");
        newXSproto("urxvt::GET_BASEBG", XS_urxvt_GET_BASEBG, file, "$");
        newXSproto("urxvt::SET_FGCOLOR", XS_urxvt_SET_FGCOLOR, file, "$$");
        newXSproto("urxvt::SET_BGCOLOR", XS_urxvt_SET_BGCOLOR, file, "$$");
        newXSproto("urxvt::GET_CUSTOM", XS_urxvt_GET_CUSTOM, file, "$");
        newXSproto("urxvt::SET_CUSTOM", XS_urxvt_SET_CUSTOM, file, "$$");
        newXSproto("urxvt::termlist", XS_urxvt_termlist, file, "");
        newXSproto("urxvt::term::_new", XS_urxvt__term__new, file, "$$");
        newXSproto("urxvt::term::destroy", XS_urxvt__term_destroy, file, "$");
        newXSproto("urxvt::term::set_should_invoke", XS_urxvt__term_set_should_invoke, file, "$$$");
        newXSproto("urxvt::term::grab_button", XS_urxvt__term_grab_button, file, "$$$;$");
        newXSproto("urxvt::term::ungrab_button", XS_urxvt__term_ungrab_button, file, "$$$;$");
        newXSproto("urxvt::term::XGrabKey", XS_urxvt__term_XGrabKey, file, "$$$;$$$$");
        newXSproto("urxvt::term::XUngrabKey", XS_urxvt__term_XUngrabKey, file, "$$$;$");
        newXSproto("urxvt::term::XUngrabKeyboard", XS_urxvt__term_XUngrabKeyboard, file, "$$");
        newXSproto("urxvt::term::grab", XS_urxvt__term_grab, file, "$$;$");
        newXSproto("urxvt::term::allow_events_async", XS_urxvt__term_allow_events_async, file, "$");
        newXSproto("urxvt::term::allow_events_sync", XS_urxvt__term_allow_events_sync, file, "$");
        newXSproto("urxvt::term::allow_events_replay", XS_urxvt__term_allow_events_replay, file, "$");
        newXSproto("urxvt::term::ungrab", XS_urxvt__term_ungrab, file, "$");
        newXSproto("urxvt::term::XStringToKeysym", XS_urxvt__term_XStringToKeysym, file, "$$");
        newXSproto("urxvt::term::XKeysymToString", XS_urxvt__term_XKeysymToString, file, "$$");
        newXSproto("urxvt::term::XKeysymToKeycode", XS_urxvt__term_XKeysymToKeycode, file, "$$");
        newXSproto("urxvt::term::XKeycodeToKeysym", XS_urxvt__term_XKeycodeToKeysym, file, "$$$");
        newXSproto("urxvt::term::strwidth", XS_urxvt__term_strwidth, file, "$$");
        newXSproto("urxvt::term::locale_encode", XS_urxvt__term_locale_encode, file, "$$");
        newXSproto("urxvt::term::locale_decode", XS_urxvt__term_locale_decode, file, "$$");
        newXSproto("urxvt::term::locale", XS_urxvt__term_locale, file, "$");
        cv = newXS("urxvt::term::height", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_height ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::saveLines", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_saveLines ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::top_row", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_top_row ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::total_rows", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_total_rows ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::fwidth", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_fwidth ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::ncol", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_ncol ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::ext_bwidth", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_ext_bwidth ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::width", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_width ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::lineSpace", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_lineSpace ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::fheight", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_fheight ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::fbase", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_fbase ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::focus", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_focus ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::mapped", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_mapped ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::int_bwidth", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_int_bwidth ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::nrow", XS_urxvt__term_width, file);
        XSANY.any_i32 = TERM_OFFSET_nrow ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::ModLevel3Mask", XS_urxvt__term_ModLevel3Mask, file);
        XSANY.any_i32 = 0 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::hidden_cursor", XS_urxvt__term_ModLevel3Mask, file);
        XSANY.any_i32 = 4 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::ModNumLockMask", XS_urxvt__term_ModLevel3Mask, file);
        XSANY.any_i32 = 2 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::current_screen", XS_urxvt__term_ModLevel3Mask, file);
        XSANY.any_i32 = 3 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::ModMetaMask", XS_urxvt__term_ModLevel3Mask, file);
        XSANY.any_i32 = 1 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::display_id", XS_urxvt__term_display_id, file);
        XSANY.any_i32 = 0 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::locale", XS_urxvt__term_display_id, file);
        XSANY.any_i32 = 1 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::argv", XS_urxvt__term_envv, file);
        XSANY.any_i32 = 1 ;
        sv_setpv((SV*)cv, "$") ;
        cv = newXS("urxvt::term::envv", XS_urxvt__term_envv, file);
        XSANY.any_i32 = 0 ;
        sv_setpv((SV*)cv, "$") ;
        newXSproto("urxvt::term::pty_ev_events", XS_urxvt__term_pty_ev_events, file, "$;$");
        newXSproto("urxvt::term::pty_fd", XS_urxvt__term_pty_fd, file, "$");
        newXSproto("urxvt::term::parent", XS_urxvt__term_parent, file, "$");
        newXSproto("urxvt::term::vt", XS_urxvt__term_vt, file, "$");
        newXSproto("urxvt::term::vt_emask_add", XS_urxvt__term_vt_emask_add, file, "$$");
        newXSproto("urxvt::term::rstyle", XS_urxvt__term_rstyle, file, "$;$");
        newXSproto("urxvt::term::view_start", XS_urxvt__term_view_start, file, "$;$");
        newXSproto("urxvt::term::focus_in", XS_urxvt__term_focus_in, file, "$");
        newXSproto("urxvt::term::focus_out", XS_urxvt__term_focus_out, file, "$");
        cv = newXS("urxvt::term::key_press", XS_urxvt__term_key_press, file);
        XSANY.any_i32 = 0 ;
        sv_setpv((SV*)cv, "$$$;$") ;
        cv = newXS("urxvt::term::key_release", XS_urxvt__term_key_press, file);
        XSANY.any_i32 = 1 ;
        sv_setpv((SV*)cv, "$$$;$") ;
        newXSproto("urxvt::term::want_refresh", XS_urxvt__term_want_refresh, file, "$");
        newXSproto("urxvt::term::ROW_t", XS_urxvt__term_ROW_t, file, "$$;$$$$");
        newXSproto("urxvt::term::ROW_r", XS_urxvt__term_ROW_r, file, "$$;$$$$");
        newXSproto("urxvt::term::ROW_l", XS_urxvt__term_ROW_l, file, "$$;$");
        newXSproto("urxvt::term::ROW_is_longer", XS_urxvt__term_ROW_is_longer, file, "$$;$");
        newXSproto("urxvt::term::special_encode", XS_urxvt__term_special_encode, file, "$$");
        newXSproto("urxvt::term::special_decode", XS_urxvt__term_special_decode, file, "$$");
        newXSproto("urxvt::term::_resource", XS_urxvt__term__resource, file, "$$$;$");
        newXSproto("urxvt::term::x_resource", XS_urxvt__term_x_resource, file, "$$");
        newXSproto("urxvt::term::option", XS_urxvt__term_option, file, "$$;$");
        newXSproto("urxvt::term::parse_keysym", XS_urxvt__term_parse_keysym, file, "$$$");
        cv = newXS("urxvt::term::selection_beg", XS_urxvt__term_screen_cur, file);
        XSANY.any_i32 = 1 ;
        sv_setpv((SV*)cv, "$;$$") ;
        cv = newXS("urxvt::term::screen_cur", XS_urxvt__term_screen_cur, file);
        XSANY.any_i32 = 0 ;
        sv_setpv((SV*)cv, "$;$$") ;
        cv = newXS("urxvt::term::selection_end", XS_urxvt__term_screen_cur, file);
        XSANY.any_i32 = 2 ;
        sv_setpv((SV*)cv, "$;$$") ;
        cv = newXS("urxvt::term::selection_mark", XS_urxvt__term_screen_cur, file);
        XSANY.any_i32 = 3 ;
        sv_setpv((SV*)cv, "$;$$") ;
        newXSproto("urxvt::term::cur_charset", XS_urxvt__term_cur_charset, file, "$");
        newXSproto("urxvt::term::selection_clear", XS_urxvt__term_selection_clear, file, "$");
        newXSproto("urxvt::term::selection_make", XS_urxvt__term_selection_make, file, "$$;$");
        newXSproto("urxvt::term::selection_grab", XS_urxvt__term_selection_grab, file, "$$");
        newXSproto("urxvt::term::selection", XS_urxvt__term_selection, file, "$;$");
        newXSproto("urxvt::term::scr_xor_rect", XS_urxvt__term_scr_xor_rect, file, "$$$$$;$$");
        newXSproto("urxvt::term::scr_xor_span", XS_urxvt__term_scr_xor_span, file, "$$$$$;$");
        newXSproto("urxvt::term::scr_bell", XS_urxvt__term_scr_bell, file, "$");
        newXSproto("urxvt::term::scr_change_screen", XS_urxvt__term_scr_change_screen, file, "$$");
        newXSproto("urxvt::term::scr_add_lines", XS_urxvt__term_scr_add_lines, file, "$$");
        newXSproto("urxvt::term::tt_write", XS_urxvt__term_tt_write, file, "$$");
        newXSproto("urxvt::term::cmd_parse", XS_urxvt__term_cmd_parse, file, "$$");
        newXSproto("urxvt::term::overlay", XS_urxvt__term_overlay, file, "$$$$$;$$");
        newXSproto("urxvt::term::XListProperties", XS_urxvt__term_XListProperties, file, "$$");
        newXSproto("urxvt::term::XGetWindowProperty", XS_urxvt__term_XGetWindowProperty, file, "$$$");
        newXSproto("urxvt::term::XChangeProperty", XS_urxvt__term_XChangeProperty, file, "$$$$$$");
        newXSproto("urxvt::term::XInternAtom", XS_urxvt__term_XInternAtom, file, "$$;$");
        newXSproto("urxvt::term::XGetAtomName", XS_urxvt__term_XGetAtomName, file, "$$");
        newXSproto("urxvt::term::XDeleteProperty", XS_urxvt__term_XDeleteProperty, file, "$$$");
        newXSproto("urxvt::term::DefaultRootWindow", XS_urxvt__term_DefaultRootWindow, file, "$");
#if XSubPPtmpAAAA
        newXSproto("urxvt::term::XCreateSimpleWindow", XS_urxvt__term_XCreateSimpleWindow, file, "$$$$$$");
#endif
        newXSproto("urxvt::term::XReparentWindow", XS_urxvt__term_XReparentWindow, file, "$$$;$$");
        newXSproto("urxvt::term::XMapWindow", XS_urxvt__term_XMapWindow, file, "$$");
        newXSproto("urxvt::term::XUnmapWindow", XS_urxvt__term_XUnmapWindow, file, "$$");
        newXSproto("urxvt::term::XMoveResizeWindow", XS_urxvt__term_XMoveResizeWindow, file, "$$$$$$");
        newXSproto("urxvt::term::XChangeInput", XS_urxvt__term_XChangeInput, file, "$$$;$");
        newXSproto("urxvt::term::XTranslateCoordinates", XS_urxvt__term_XTranslateCoordinates, file, "$$$$$");
        newXSproto("urxvt::overlay::set", XS_urxvt__overlay_set, file, "$$$$;$");
        newXSproto("urxvt::overlay::show", XS_urxvt__overlay_show, file, "$");
        newXSproto("urxvt::overlay::hide", XS_urxvt__overlay_hide, file, "$");
        newXSproto("urxvt::overlay::DESTROY", XS_urxvt__overlay_DESTROY, file, "$");
        newXSproto("urxvt::watcher::cb", XS_urxvt__watcher_cb, file, "$$");
        newXSproto("urxvt::timer::new", XS_urxvt__timer_new, file, "$");
        newXSproto("urxvt::timer::at", XS_urxvt__timer_at, file, "$");
        newXSproto("urxvt::timer::interval", XS_urxvt__timer_interval, file, "$$");
        newXSproto("urxvt::timer::set", XS_urxvt__timer_set, file, "$$");
        newXSproto("urxvt::timer::start", XS_urxvt__timer_start, file, "$;$");
        newXSproto("urxvt::timer::after", XS_urxvt__timer_after, file, "$$");
        newXSproto("urxvt::timer::stop", XS_urxvt__timer_stop, file, "$");
        newXSproto("urxvt::timer::DESTROY", XS_urxvt__timer_DESTROY, file, "$");
        newXSproto("urxvt::iow::new", XS_urxvt__iow_new, file, "$");
        newXSproto("urxvt::iow::fd", XS_urxvt__iow_fd, file, "$$");
        newXSproto("urxvt::iow::events", XS_urxvt__iow_events, file, "$$");
        newXSproto("urxvt::iow::start", XS_urxvt__iow_start, file, "$");
        newXSproto("urxvt::iow::stop", XS_urxvt__iow_stop, file, "$");
        newXSproto("urxvt::iow::DESTROY", XS_urxvt__iow_DESTROY, file, "$");
        newXSproto("urxvt::iw::new", XS_urxvt__iw_new, file, "$");
        newXSproto("urxvt::iw::start", XS_urxvt__iw_start, file, "$");
        newXSproto("urxvt::iw::stop", XS_urxvt__iw_stop, file, "$");
        newXSproto("urxvt::iw::DESTROY", XS_urxvt__iw_DESTROY, file, "$");
        newXSproto("urxvt::pw::new", XS_urxvt__pw_new, file, "$");
        newXSproto("urxvt::pw::start", XS_urxvt__pw_start, file, "$$");
        newXSproto("urxvt::pw::stop", XS_urxvt__pw_stop, file, "$");
        newXSproto("urxvt::pw::DESTROY", XS_urxvt__pw_DESTROY, file, "$");
    }

    /* Initialisation Section */

#line 632 "rxvtperl.xs"
{
  sv_setsv (get_sv ("urxvt::LIBDIR",   1), newSVpvn (LIBDIR,   sizeof (LIBDIR)   - 1));
  sv_setsv (get_sv ("urxvt::RESNAME",  1), newSVpvn (RESNAME,  sizeof (RESNAME)  - 1));
  sv_setsv (get_sv ("urxvt::RESCLASS", 1), newSVpvn (RESCLASS, sizeof (RESCLASS) - 1));
  sv_setsv (get_sv ("urxvt::RXVTNAME", 1), newSVpvn (RXVTNAME, sizeof (RXVTNAME) - 1));

  AV *hookname = get_av ("urxvt::HOOKNAME", 1);
# define def(sym) av_store (hookname, HOOK_ ## sym, newSVpv (# sym, 0));
# include "hookinc.h"
# undef def

  HV *option = get_hv ("urxvt::OPTION", 1);
# define def(name,val) hv_store (option, # name, sizeof (# name) - 1, newSVuv (Opt_ ## name), 0);
# define nodef(name)
# include "optinc.h"
# undef nodef
# undef def

  HV *stash = gv_stashpv ("urxvt", 1);
  static const struct {
    const char *name;
    IV iv;
  } *civ, const_iv[] = {
#   define const_iv(name) { # name, (IV)name }
    const_iv (NUM_RESOURCES),
    const_iv (DEFAULT_RSTYLE),
    const_iv (OVERLAY_RSTYLE),
    const_iv (RS_Bold),
    const_iv (RS_Italic),
    const_iv (RS_Blink),
    const_iv (RS_RVid),
    const_iv (RS_Uline),

    const_iv (CurrentTime),
    const_iv (ShiftMask),
    const_iv (LockMask),
    const_iv (ControlMask),
    const_iv (Mod1Mask),
    const_iv (Mod2Mask),
    const_iv (Mod3Mask),
    const_iv (Mod4Mask),
    const_iv (Mod5Mask),
    const_iv (Button1Mask),
    const_iv (Button2Mask),
    const_iv (Button3Mask),
    const_iv (Button4Mask),
    const_iv (Button5Mask),
    const_iv (AnyModifier),

    const_iv (NoSymbol),
    const_iv (GrabModeSync),
    const_iv (GrabModeAsync),

    const_iv (NoEventMask),
    const_iv (KeyPressMask),
    const_iv (KeyReleaseMask),
    const_iv (ButtonPressMask),
    const_iv (ButtonReleaseMask),
    const_iv (EnterWindowMask),
    const_iv (LeaveWindowMask),
    const_iv (PointerMotionMask),
    const_iv (PointerMotionHintMask),
    const_iv (Button1MotionMask),
    const_iv (Button2MotionMask),
    const_iv (Button3MotionMask),
    const_iv (Button4MotionMask),
    const_iv (Button5MotionMask),
    const_iv (ButtonMotionMask),
    const_iv (KeymapStateMask),
    const_iv (ExposureMask),
    const_iv (VisibilityChangeMask),
    const_iv (StructureNotifyMask),
    const_iv (ResizeRedirectMask),
    const_iv (SubstructureNotifyMask),
    const_iv (SubstructureRedirectMask),
    const_iv (FocusChangeMask),
    const_iv (PropertyChangeMask),
    const_iv (ColormapChangeMask),
    const_iv (OwnerGrabButtonMask),

    const_iv (KeyPress),
    const_iv (KeyRelease),
    const_iv (ButtonPress),
    const_iv (ButtonRelease),
    const_iv (MotionNotify),
    const_iv (EnterNotify),
    const_iv (LeaveNotify),
    const_iv (FocusIn),
    const_iv (FocusOut),
    const_iv (KeymapNotify),
    const_iv (Expose),
    const_iv (GraphicsExpose),
    const_iv (NoExpose),
    const_iv (VisibilityNotify),
    const_iv (CreateNotify),
    const_iv (DestroyNotify),
    const_iv (UnmapNotify),
    const_iv (MapNotify),
    const_iv (MapRequest),
    const_iv (ReparentNotify),
    const_iv (ConfigureNotify),
    const_iv (ConfigureRequest),
    const_iv (GravityNotify),
    const_iv (ResizeRequest),
    const_iv (CirculateNotify),
    const_iv (CirculateRequest),
    const_iv (PropertyNotify),
    const_iv (SelectionClear),
    const_iv (SelectionRequest),
    const_iv (SelectionNotify),
    const_iv (ColormapNotify),
    const_iv (ClientMessage),
    const_iv (MappingNotify),
#   if ENABLE_XIM_ONTHESPOT
    const_iv (XIMReverse),
    const_iv (XIMUnderline),
    const_iv (XIMHighlight),
    const_iv (XIMPrimary),
    const_iv (XIMSecondary),
    const_iv (XIMTertiary),
    const_iv (XIMVisibleToForward),
    const_iv (XIMVisibleToBackword),
    const_iv (XIMVisibleToCenter),
#   if 0
    const_iv (XIMForwardChar),
    const_iv (XIMBackwardChar),
    const_iv (XIMForwardWord),
    const_iv (XIMBackwardWord),
    const_iv (XIMCaretUp),
    const_iv (XIMCaretDown),
    const_iv (XIMNextLine),
    const_iv (XIMPreviousLine),
    const_iv (XIMLineStart),
    const_iv (XIMLineEnd),
    const_iv (XIMAbsolutePosition),
    const_iv (XIMDontChange),
#   endif
#   endif
  };

  for (civ = const_iv + sizeof (const_iv) / sizeof (const_iv [0]); civ-- > const_iv; )
    newCONSTSUB (stash, (char *)civ->name, newSViv (civ->iv));
}

#if XSubPPtmpAAAA
#endif
#line 6 "$PERL <iom_perl.xs -pe s/IOM_MODULE/urxvt/g,s/IOM_CLASS/urxvt/g |"
{
  {
    HV *stash     = gv_stashpv ("urxvt", 1);
    SV *baseclass = newSVpv ("urxvt::watcher", 0);

    static const struct {
      const char *name;
      IV iv;
    } *civ, iom_const_iv[] = {
#   define iom_const_iv(name) { # name, (IV)name }
      iom_const_iv (EV_NONE),
      iom_const_iv (EV_READ),
      iom_const_iv (EV_WRITE),
#   undef iom_const
    };

    for (civ = iom_const_iv + sizeof (iom_const_iv) / sizeof (iom_const_iv [0]); civ-- > iom_const_iv; )
      newCONSTSUB (stash, (char *)civ->name, newSViv (civ->iv));

    /* slightly dirty to put the same scalar into all those arrays, but */
    /* we do not expect users to modify them anyways */
    av_push (get_av ("urxvt" "::timer::ISA", 1), SvREFCNT_inc (baseclass));
    av_push (get_av ("urxvt"   "::iow::ISA", 1), SvREFCNT_inc (baseclass));
    av_push (get_av ("urxvt"    "::pw::ISA", 1), SvREFCNT_inc (baseclass));
    av_push (get_av ("urxvt"    "::iw::ISA", 1), SvREFCNT_inc (baseclass));

    SvREFCNT_dec (baseclass);
  }
}

#line 3935 "rxvtperl.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

