

namespace std
{
  using ::sig_atomic_t;
  using ::signal;
  using ::raise;
}
      //     # 60 "command.C" 2





/*----------------------------------------------------------------------*/
      //     # 78 "command.C"
//CMNT: c_keyword ^|       static unsigned short iso14755_symtab[] = {
   iso14755_symtab[] = {
  // keysym,		unicode
  0xff51 /* Move left, left arrow */, 0x2190,
  0xff96, 0x2190,
  0xff52 /* Move up, up arrow */, 0x2191,
  0xff97, 0x2191,
  0xff53 /* Move right, right arrow */, 0x2192,
  0xff98, 0x2192,
  0xff54 /* Move down, down arrow */, 0x2193,
  0xff99, 0x2193,
  0xff0a /* Linefeed, LF */, 0x21b4,
  0xff0d /* Return, enter */, 0x21b5,
  0xff8d /* Enter */, 0x21b5,

  0xff55 /* Prior, previous */, 0x21de,
  0xff56 /* Next */, 0x21df,
  0xff09, 0x21e5,
  0xfe20, 0x21e6,
  0xffe1 /* Left shift */, 0x21e7,
  0xffe2 /* Right shift */, 0x21e7,

  0xffe6 /* Shift lock */, 0x21eb,
  0xfe01, 0x21eb,
  0xffe5 /* Caps lock */, 0x21ec,
  0xff7f, 0x21ed,
  0xfe03, 0x21ee,
  0xfe05, 0x21ef,
  0xfe07, 0x21f0,
  0xff50, 0x21f1,
  0xff57 /* EOL */, 0x21f2,

  0xff62 /* Execute, run, do */, 0x2318,
  0xff58 /* BOL */, 0x2320,
  0xffff /* Delete, rubout */, 0x2326,
  0xff0b, 0x2327,
//CMNT: c_keyword ^|         0xff08 /* Back space, back char */, 0x232b,
  0xff08 /* Back space, back  */, 0x232b,
  0xff63 /* Insert, insert here */, 0x2380,
  0xffe3 /* Left control */, 0x2388,
  0xffe4 /* Right control */, 0x2388,
  0xff13 /* Pause, hold */, 0x2389,
  0xff6b, 0x238a,
  0xff1b, 0x238b,
  0xff65, 0x238c,
  0xff61, 0x2399,

  0x0020 /* U+0020 SPACE */, 0x2423,


  0xff9a, 0x21de,
  0xff9b, 0x21df,
  0xff9d, 0x2320,
  0xff9e, 0x2380,
  0xff9f, 0x2326,
  0xff80 /* Space */, 0x2422,

  0,
};

//CMNT: c_keyword ^|       void

//CMNT: c_keyword ^|       rxvt_term::iso14755_54 (int x, int y){
rxvt_term::iso14755_54 ( x,  y){
//CMNT: c_keyword ^|         x = ((int32_t)((int32_t)(x)) / (int32_t)fwidth);
  x = ((32_t)((32_t)(x)) / (32_t)fwidth);
//CMNT: c_keyword ^|         y = ((int32_t)((int32_t)(y)) / (int32_t)fheight);
  y = ((32_t)((32_t)(y)) / (32_t)fheight);

//CMNT: c_keyword ^|         if (!((unsigned int)(x) - (unsigned int)(0) < (unsigned int)(ncol) - (unsigned int)(0))
  if (!(( )(x) - ( )(0) < ( )(ncol) - ( )(0))
//CMNT: c_keyword ^|             || !((unsigned int)(y) - (unsigned int)(0) < (unsigned int)(nrow) - (unsigned int)(0)))
      || !(( )(y) - ( )(0) < ( )(nrow) - ( )(0)))
    return;

  for (;;){
//CMNT: c_keyword ^|             const line_t &l = (this)->row_buf [(((((this))->term_start + int(y + view_start)) + (((this))->total_rows)) % (((this))->total_rows))];
       line_t &l = (this)->row_buf [(((((this))->term_start + (y + view_start)) + (((this))->total_rows)) % (((this))->total_rows))];

      text_t t = l.t[x];

      if (t != NOCHAR || !x){
          iso14755_51 (l.t[x], l.r[x], x, y);
          iso14755buf = 0x10000000UL /* code feedback (section 5.4)*/;
          break;
        }

      x--;
    }
}

//CMNT: c_keyword ^|       void

//CMNT: c_keyword ^|       rxvt_term::iso14755_51 (unicode_t ch, rend_t r, int x, int y){
rxvt_term::iso14755_51 (ch,  r,  x,  y){
//CMNT: possible_pointer ^|         rxvt_fontset *fs = (this)->fontset[0];
  rxvt_fontset  f s = (this)->fontset[0];
//CMNT: possible_pointer ^|         rxvt_font *f = (*fs)[fs->find_font (ch)];
  rxvt_font  f  = ( f s)[fs->find_font (ch)];
//CMNT: c_keyword possible_pointer ^|         wchar_t *chr, *alloc, ch2, *fname;
    c hr,  a lloc, ch2,  f name;
//CMNT: c_keyword ^|         int len;
   len;

  fname = rxvt_utf8towcs (f->name);
      //     # 182 "command.C"
    {
      ch2 = ch;

      alloc = 0;
      chr = &ch2;
      len = 1;
    }

//CMNT: c_keyword ^|         char attr[80]; // plenty
   attr[80]; // plenty

//CMNT: c_keyword ^|         sprintf (attr, "%08x = fg %d bg %d%s%s%s%s%s%s",
  sprf (attr, "%08x = fg %d bg %d%s%s%s%s%s%s",
//CMNT: remove_casts ^|                  (int)r,
           r,
           fgcolor_of (r), bgcolor_of (r),
           r & 0x00004000UL /* value 1*/ ? " bold" : "",
           r & 0x00008000UL /* value 2*/ ? " italic" : "",
           r & 0x00010000UL /* blink*/ ? " blink" : "",
           r & 0x00020000UL /* reverse video*/ ? " rvid" : "",
           r & 0x00040000UL /* underline*/ ? " uline" : "",
           r & 0x80000000UL /* be careful when drawing these */ ? " careful" : "");

//CMNT: js_style_variables ^|         int width = wcswidth (fname, wcslen (fname));
 var width= wcswidth (fname, wcslen (fname));

//CMNT: c_keyword ^|         max_it (width, 8+5); // for char + hex
  max_it (width, 8+5); // for  + hex
  max_it (width, (strlen)(attr));

  if (y >= 0){
      y = (y >= nrow - len - 4 && x < width + 2) ? 0 : -1;
      x = 0;
    }

  scr_overlay_new (x, y, width, len + 2);

  r = ((((0 | Color_Black | (Color_Yellow << 7 /* 0 .. maxTermCOLOR*/))) & ~(0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) | (((((r) & (0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) >> 14)) << 14));

//CMNT: c_keyword ^|         for (int y = 0; y < len; y++){
  for ( y = 0; y < len; y++){
//CMNT: c_keyword ^|             char buf[9];
       buf[9];

//CMNT: possible_pointer ^|             ch = *chr++;
      ch =  c hr++;

//CMNT: c_keyword ^|             sprintf (buf, "%8x", ch);
      sprf (buf, "%8x", ch);
      scr_overlay_set (0, y, buf);
      scr_overlay_set (9, y, '=');

      if (ch >= 0x10000)
        ch = 0xfffd;

      scr_overlay_set (11, y, ch, r);

//CMNT: c_keyword ^|             if ((((unsigned int)(ch) - (unsigned int)(0x20) <= (unsigned int)(0x7e) - (unsigned int)(0x20)) ? 1 : wcwidth (ch)) >= 2)
      if (((( )(ch) - ( )(0x20) <= ( )(0x7e) - ( )(0x20)) ? 1 : wcwidth (ch)) >= 2)
        scr_overlay_set (12, y, NOCHAR, r);
    }

//  {
//CMNT: c_keyword ^|       //    char buf[4+4+3+1];
//     buf[4+4+3+1];
//CMNT: c_keyword ^|       //    snprintf (buf, sizeof (buf), "(%.4d|%.4d)", x, y);
//    snprf (buf, sizeof (buf), "(%.4d|%.4d)", x, y);
//    scr_overlay_set (0, 0, buf);
//  }
  scr_overlay_set (0, len , attr);
  scr_overlay_set (0, len + 1, fname);

  free (fname);





}


//CMNT: c_keyword ^|       void

rxvt_term::commit_iso14755 (){
//CMNT: c_keyword ^|         wchar_t ch[2];
   ch[2];

  ch[0] = iso14755buf & 0x0fffffffUL;
  ch[1] = 0;

  if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/){
//CMNT: c_keyword ^|             char mb[16];
       mb[16];
//CMNT: c_keyword ^|             int len;
       len;

      // allow verbatim 0-bytes and control-bytes to be entered
      if (ch[0] >= 0x20)
        len = wcstombs (mb, ch, 16);
      else{
          mb[0] = ch[0];
          len = 1;
        }

      if (len > 0)
        tt_write (mb, len);
      else
        scr_bell ();
    }

  iso14755buf = 0;
}

//CMNT: c_keyword ^|       static int

hex_keyval (XKeyEvent &ev){
  // check wether this event corresponds to a hex digit
  // if the modifiers had not been pressed.
//CMNT: c_keyword ^|         for (int index = 0; index < 8; index++){
  for (var  index = 0; index < 8; index++){
      KeySym k = XLookupKeysym (&ev, index);

      if (k >= 0xffb0 && k <= 0xffb9) return k - 0xffb0;
      else if (k >= 0x0030 /* U+0030 DIGIT ZERO */ && k <= 0x0039 /* U+0039 DIGIT NINE */) return k - 0x0030 /* U+0030 DIGIT ZERO */;
      else if (k >= 0x0061 /* U+0061 LATIN SMALL LETTER A */ && k <= 0x0066 /* U+0066 LATIN SMALL LETTER F */) return k - 0x0061 /* U+0061 LATIN SMALL LETTER A */ + 10;
      else if (k >= 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ && k <= 0x0046 /* U+0046 LATIN CAPITAL LETTER F */) return k - 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ + 10;
    }

  return -1;
}


//CMNT: c_keyword ^|       static inline KeySym
inline KeySym
translate_keypad (KeySym keysym, bool kp){

//CMNT: c_keyword ^|         static const KeySym keypadtrans[] = {
    KeySym keypadtrans[] = {
    0xffb7, // XK_KP_Home
    0xffb4, // XK_KP_Left
    0xffb8, // XK_KP_Up
    0xffb6, // XK_KP_Right
    0xffb2, // XK_KP_Down

    0xffb9, // XK_KP_Prior
    0xffb3, // XK_KP_Next




    0xffb1, // XK_KP_End
    0xffb5, // XK_KP_Begin
  };

//CMNT: c_keyword ^|         if (((unsigned int)(keysym) - (unsigned int)(0xff95) <= (unsigned int)(0xff9d) - (unsigned int)(0xff95))){
  if ((( )(keysym) - ( )(0xff95) <= ( )(0xff9d) - ( )(0xff95))){
//CMNT: c_keyword ^|             unsigned int index = keysym - 0xff95;
        index = keysym - 0xff95;
      keysym = kp ? keypadtrans[index] : 0xff50 + index;
    }
  else if (keysym == 0xff9e)
    keysym = kp ? 0xffb0 : 0xff63 /* Insert, insert here */;





  return keysym;
}

//CMNT: c_keyword ^|       static inline int
 inline
map_function_key (KeySym keysym){
//CMNT: js_style_variables ^|         int param = 0;
 var param= 0;

//CMNT: c_keyword ^|         if (((unsigned int)(keysym) - (unsigned int)(0xffbe) <= (unsigned int)(0xffe0) - (unsigned int)(0xffbe))){
  if ((( )(keysym) - ( )(0xffbe) <= ( )(0xffe0) - ( )(0xffbe))){
      param = 11 + keysym - 0xffbe;
      if (keysym >= 0xffce)
        param += 4;
      else if (keysym >= 0xffcc)
        param += 3;
      else if (keysym >= 0xffc8)
        param += 2;
      else if (keysym >= 0xffc3)
        param += 1;
    }
  else
    switch (keysym){
        case 0xff68 /* Find, search */:
          param = 1;
          break;
        case 0xff63 /* Insert, insert here */:
          param = 2;
          break;



        case 0xff62 /* Execute, run, do */:
          param = 3;
          break;
        case 0xff60 /* Select, mark */:
          param = 4;
          break;

        case 0xff55 /* Prior, previous */:
          param = 5;
          break;
        case 0xff56 /* Next */:
          param = 6;
          break;
        case 0xff50:
          param = 7;
          break;
        case 0xff57 /* EOL */:
          param = 8;
          break;

        case 0xff6a /* Help */:
          param = 28;
          break;
        case 0xff67:
          param = 29;
          break;
      }
  return param;
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::key_press (XKeyEvent &ev){
rxvt_term.key_press =function(XKeyEvent &ev){
//CMNT: c_keyword ^|         int ctrl, meta, shft, len;
   ctrl, meta, shft, len;
  KeySym keysym;
//CMNT: c_keyword ^|         int valid_keysym;
   valid_keysym;
//CMNT: c_keyword ^|         char kbuf[512 /* size of keyboard mapping buffer*/];
   kbuf[512 /* size of keyboard mapping buffer*/];


  if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/)
    return;


  /*
//CMNT: possible_pointer ^|          * use Num_Lock to toggle Keypad on/off.  If Num_Lock is off, allow an
      use Num_Lock to toggle Keypad on/off.  If Num_Lock is off, allow an
//CMNT: possible_pointer ^|          * escape sequence to toggle the Keypad.
      escape sequence to toggle the Keypad.
   *
//CMNT: possible_pointer ^|          * Always permit `shift' to override the current setting
      Always permit `shift' to override the current setting
   */
  shft = ev.state & (1<<0);
  ctrl = ev.state & (1<<2);
  meta = ev.state & ModMetaMask;

  if (numlock_state || (ev.state & ModNumLockMask)){
      numlock_state = (ev.state & ModNumLockMask);
      set_privmode ((1UL<<7), !numlock_state);
    }

  kbuf[0] = 0;
      //     # 483 "command.C"
    {
      len = XLookupString (&ev, kbuf, 512 /* size of keyboard mapping buffer*/, &keysym, &compose);
      valid_keysym = keysym != 0L /* special KeySym */;
    }

  if (valid_keysym){





      if (saveLines){



          if ((((shft) || 0 || 0) && (!0 && !(ctrl) && !(meta))))

            {
//CMNT: c_keyword ^|                     int lnsppg;
               lnsppg;


              lnsppg = nrow - 1;



              if (keysym == 0xff55 /* Prior, previous */){
                  scr_page (UP, lnsppg);
                  return;
                }
              else if (keysym == 0xff56 /* Next */){
                  scr_page (DN, lnsppg);
                  return;
                }
            }
      //     # 551 "command.C"
        }

      if (shft){
          /* Shift + F1 - F10 generates F11 - F20 */
          if (keysym >= 0xffbe && keysym <= 0xffc7){
              keysym += (0xffc8 - 0xffbe);
              shft = 0; /* turn off Shift */
            }
          else if (!ctrl && !meta && (priv_modes & (1UL<<10))){
              switch (keysym){
                    /* normal XTerm key bindings */
                  case 0xff63 /* Insert, insert here */: /* Shift+Insert = paste mouse selection */
                    selection_request (ev.time);
                    return;
      //     # 578 "command.C"
                }
            }
        }


      // ISO 14755 support
      if (shft && ctrl){
//CMNT: c_keyword ^|                 int hv;
           hv;

          if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/
              && (keysym == 0x0020 /* U+0020 SPACE */ || keysym == 0xff80 /* Space */
                  || keysym == 0xff0d /* Return, enter */ || keysym == 0xff8d /* Enter */)){
              commit_iso14755 ();
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (0);

              return;
            }
//CMNT: c_keyword ^|                 else if (keysym == 0xff08 /* Back space, back char */){
          else if (keysym == 0xff08 /* Back space, back  */){
              iso14755buf = ((iso14755buf & 0x0fffffffUL) >> 4) | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else if ((hv = hex_keyval (ev)) >= 0){
              iso14755buf = ((iso14755buf << 4) & 0x0fffffffUL)
                          | hv | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else{

              scr_overlay_off ();

              iso14755buf = 0;
            }
        }
      else if ((ctrl && (keysym == 0xffe1 /* Left shift */ || keysym == 0xffe2 /* Right shift */))
               || (shft && (keysym == 0xffe3 /* Left control */ || keysym == 0xffe4 /* Right control */)))
        if (!(iso14755buf & 0x80000000UL)){
            iso14755buf |= 0x80000000UL;

            scr_overlay_new (0, -1, sizeof ("ISO 14755 mode") - 1, 1);
            scr_overlay_set (0, 0, "ISO 14755 mode");

          }



      if (keysym == 0xff61){
//CMNT: c_keyword ^|                 scr_printscreen (ctrl | shft);
          scr_prscreen (ctrl | shft);
          return;
        }


      if (keysym >= 0xFF00 && keysym <= 0xFFFF){
          bool kp = priv_modes & (1UL<<7) ? !shft : shft;
//CMNT: c_keyword ^|                 unsigned int newlen = 1;
            newlen = 1;

          switch (translate_keypad (keysym, kp)){
      //     # 668 "command.C"
              case 0xff09:
                if (shft)
                  (strcpy)(kbuf,"\033[Z");
                else{
      //     # 681 "command.C"
                    newlen = 0;
                  }
                break;

              case 0xff52 /* Move up, up arrow */: /* "\033[A" */
              case 0xff54 /* Move down, down arrow */: /* "\033[B" */
              case 0xff53 /* Move right, right arrow */: /* "\033[C" */
              case 0xff51 /* Move left, left arrow */: /* "\033[D" */
                (strcpy)(kbuf,"\033[Z");
                kbuf[2] = "DACB"[keysym - 0xff51 /* Move left, left arrow */];
                /* do Shift first */
                if (shft)
                  kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                else if (ctrl){
                    kbuf[1] = 'O';
                    kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                  }
                else if (priv_modes & (1UL<<6))
                  kbuf[1] = 'O';
                break;

              case 0xff8d /* Enter */:
                /* allow shift to override */
                if (kp){
                    (strcpy)(kbuf,"\033OM");
                    break;
                  }

                /* FALLTHROUGH */

              case 0xff0d /* Return, enter */:
                if (priv_modes & (1UL<<19)){
                    kbuf[0] = '\015';
                    kbuf[1] = '\012';
                    kbuf[2] = '\0';
                  }
                else{
                    kbuf[0] = '\015';
                    kbuf[1] = '\0';
                  }
                break;

              case 0xff91 /* PF1, KP_A, ... */: /* "\033OP" */
              case 0xff92: /* "\033OQ" */
              case 0xff93: /* "\033OR" */
              case 0xff94: /* "\033OS" */
                (strcpy)(kbuf,"\033OP");
                kbuf[2] += (keysym - 0xff91 /* PF1, KP_A, ... */);
                break;

//CMNT: possible_pointer ^|                     case 0xffaa: /* "\033Oj" : "*" */
              case 0xffaa: /* "\033Oj" : " "  */
              case 0xffab: /* "\033Ok" : "+" */
              case 0xffac /* Separator, often comma */: /* "\033Ol" : "," */
              case 0xffad: /* "\033Om" : "-" */
              case 0xffae: /* "\033On" : "." */
              case 0xffaf: /* "\033Oo" : "/" */
              case 0xffb0: /* "\033Op" : "0" */
              case 0xffb1: /* "\033Oq" : "1" */
              case 0xffb2: /* "\033Or" : "2" */
              case 0xffb3: /* "\033Os" : "3" */
              case 0xffb4: /* "\033Ot" : "4" */
              case 0xffb5: /* "\033Ou" : "5" */
              case 0xffb6: /* "\033Ov" : "6" */
              case 0xffb7: /* "\033Ow" : "7" */
              case 0xffb8: /* "\033Ox" : "8" */
              case 0xffb9: /* "\033Oy" : "9" */
                /* allow shift to override */
                if (kp){
                    (strcpy)(kbuf,"\033Oj");
                    kbuf[2] += (keysym - 0xffaa);
                  }
                else{
//CMNT: possible_pointer ^|                           kbuf[0] = ('*' + (keysym - 0xffaa));
                    kbuf[0] = (' '  + (keysym - 0xffaa));
                    kbuf[1] = '\0';
                  }
                break;

              default:
                {
//CMNT: js_style_variables ^|                         int param = map_function_key (keysym);
 var param= map_function_key (keysym);
                  if (param > 0)
//CMNT: c_keyword ^|                           sprintf (kbuf,"\033[%d~", param);
                    sprf (kbuf,"\033[%d~", param);
                  else
                    newlen = 0;
                }
                break;
            }

          if (newlen)
            len = (strlen)(kbuf);

          /*
//CMNT: possible_pointer ^|                  * Pass meta for all function keys, if 'meta' option set
              Pass meta for all function keys, if 'meta' option set
           */

//CMNT: c_keyword ^|                 if (meta && (meta_char == 0x80) && len > 0)
          if (meta && (meta_ == 0x80) && len > 0)
            kbuf[len - 1] |= 0x80;


        }
      else if (ctrl && keysym == 0x002d /* U+002D HYPHEN-MINUS */){
          len = 1;
          kbuf[0] = '\037'; /* Ctrl-Minus generates ^_ (31) */
        }
      else if (keysym == 0xfe20){
          (strcpy)(kbuf,"\033[Z");
          len = 3;
        }
      else{

          /* set 8-bit on */
//CMNT: c_keyword ^|                 if (meta && (meta_char == 0x80)){
          if (meta && (meta_ == 0x80)){
//CMNT: c_keyword possible_pointer ^|                     char *ch;
                c h;

              for (ch = kbuf; ch < kbuf + len; ch++)
//CMNT: possible_pointer ^|                       *ch |= 0x80;
                 c h |= 0x80;

              meta = 0;
            }

          /* nil */ ;
        }
    }

  if (false)
    return;

  if (len <= 0)
    return; /* not mapped */

  if (option (Opt_scrollTtyKeypress))
    if (view_start){
        view_start = 0;
        want_refresh = 1;
      }

  /*
//CMNT: c_keyword possible_pointer ^|          * these modifications only affect the static keybuffer
      these modifications only affect the  keybuffer
//CMNT: possible_pointer ^|          * pass Shift/Control indicators for function keys ending with `~'
      pass Shift/Control indicators for function keys ending with `~'
   *
//CMNT: possible_pointer ^|          * eg,
      eg,
//CMNT: possible_pointer ^|          *   Prior = "ESC[5~"
        Prior = "ESC[5~"
//CMNT: possible_pointer ^|          *   Shift+Prior = "ESC[5$"
        Shift+Prior = "ESC[5$"
//CMNT: possible_pointer ^|          *   Ctrl+Prior = "ESC[5^"
        Ctrl+Prior = "ESC[5^"
//CMNT: possible_pointer ^|          *   Ctrl+Shift+Prior = "ESC[5@"
        Ctrl+Shift+Prior = "ESC[5@"
//CMNT: possible_pointer ^|          * Meta adds an Escape prefix (with META8_OPTION, if meta == <escape>).
      Meta adds an Escape prefix (with META8_OPTION, if meta == <escape>).
   */
  if (kbuf[0] == C0_ESC && kbuf[1] == '[' && kbuf[len - 1] == '~')
    kbuf[len - 1] = (shft ? (ctrl ? '@' : '$') : (ctrl ? '^' : '~'));

  /* escape prefix */
  if (meta

//CMNT: c_keyword ^|             && meta_char == C0_ESC
      && meta_ == C0_ESC

     ){
//CMNT: c_keyword ^|             const char ch = C0_ESC;
        ch = C0_ESC;
      tt_write (&ch, 1);
    }

//CMNT: c_keyword ^|         tt_write (kbuf, (unsigned int)len);
  tt_write (kbuf, ( )len);
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::key_release (XKeyEvent &ev){
rxvt_term.key_release =function(XKeyEvent &ev){

  KeySym keysym;

  keysym = XLookupKeysym (&ev, ev.state & (1<<0) ? 1 : 0); // sorry, only shift supported :/



  // ISO 14755 support
  if (iso14755buf)
    if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/){

        scr_overlay_off ();


        // iso14755 part 5.2 handling: release time
        // first: controls
        if ((ev.state & (1<<2))
             && ((keysym >= 0x40 && keysym <= 0x5f)
                 || (keysym >= 0x61 && keysym <= 0x7f))){
            iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | 0x2400 | (keysym & 0x1f);
            commit_iso14755 ();

            return;
          }

//CMNT: c_keyword possible_pointer ^|               for (unsigned short *i = iso14755_symtab; i[0]; i+= 2)
        for (var   i  = iso14755_symtab; i[0]; i+= 2)
          if (i[0] == keysym){
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | i[1];
              commit_iso14755 ();

              return;
            }

        scr_bell ();

        iso14755buf = 0;

        return;
      }
    else if ((ev.state & ((1<<0) | (1<<2))) != ((1<<0) | (1<<2))){

        scr_overlay_off ();

        if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/)
          commit_iso14755 ();

        else if (option (Opt_iso14755_52) && iso14755buf & 0x80000000UL){
            iso14755buf = 0x20000000UL /* keycap (section 5.2)*/; // iso14755 part 5.2: remember empty begin/end pair

            scr_overlay_new (0, -1, sizeof ("KEYCAP PICTURE INSERT MODE") - 1, 1);
            scr_overlay_set (0, 0, "KEYCAP PICTURE INSERT MODE");
          }

        else
          iso14755buf = 0;
      }


  if (false)
    return;







}
      //     # 966 "command.C"
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::flush (){
rxvt_term.flush =function(){
  flush_ev.stop ();
      //     # 979 "command.C"
  if (want_refresh){
      if (false){
//CMNT: js_style_variables ^|                 int row = view_start;
 var row= view_start;
//CMNT: js_style_variables ^|                 int end_row = row + nrow;
 var end_row= row + nrow;

//CMNT: c_keyword ^|                 while (row > top_row && (this)->row_buf [(((((this))->term_start + int(row - 1)) + (((this))->total_rows)) % (((this))->total_rows))].is_longer ())
          while (row > top_row && (this)->row_buf [(((((this))->term_start + (row - 1)) + (((this))->total_rows)) % (((this))->total_rows))].is_longer ())
            --row;

          do
            {
//CMNT: js_style_variables ^|                     int start_row = row;
 var start_row= row;
//CMNT: possible_pointer ^|                     line_t *l;
              line_t  l ;

              do
                {
//CMNT: c_keyword ^|                         l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];
                  l = &(this)->row_buf [(((((this))->term_start + (row++)) + (((this))->total_rows)) % (((this))->total_rows))];

                  if (!(l->f & 0x0002 /* line has been filtered*/)){
                      // line not filtered, mark it as filtered
                      l->f |= 0x0002 /* line has been filtered*/;
                      while (l->is_longer ()){
//CMNT: c_keyword ^|                                 l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];
                          l = &(this)->row_buf [(((((this))->term_start + (row++)) + (((this))->total_rows)) % (((this))->total_rows))];
                          l->f |= 0x0002 /* line has been filtered*/;
                        }

                      // and filter it
                      false;

                      break;
                    }
                }
              while (l->is_longer () && row < end_row);
            }
          while (row < end_row);
        }

      scr_refresh ();
      scrollBar.show (1);



    }

  display->flush ();
}

/* checks wether a refresh is requested and starts the refresh timer */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::refresh_check (){
rxvt_term.refresh_check =function(){
  if (want_refresh && !flush_ev.is_active ())
    flush_ev.start (1. / 60.); // refresh at max. 60 Hz normally

  display->flush ();
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::flush_cb (ev::timer &w, int revents){
rxvt_term.flush_cb =function(ev::timer &w,  revents){
  make_current ();

  refresh_count = 0;
  flush ();
}
      //     # 1059 "command.C"
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::text_blink_cb (ev::timer &w, int revents){
rxvt_term.text_blink_cb =function(ev::timer &w,  revents){
  if (scr_refresh_rend (0x00010000UL /* blink*/, 0x00010000UL /* blink*/)){
      hidden_text = !hidden_text;
      want_refresh = 1;
      refresh_check ();
    }
  else
    w.stop ();
}
      //     # 1149 "command.C"
//CMNT: js_style_functions ^|       bool rxvt_term::pty_fill (){
boolrxvt_term.pty_fill =function(){
  ssize_t n = cmdbuf_endp - cmdbuf_ptr;

  if (2048 /* size of command buffer*/ == n){
      rxvt_warn ("PLEASE REPORT: pty_fill on full buffer, draining input, continuing.\n");
      n = 0;
    }

  memmove (cmdbuf_base, cmdbuf_ptr, n);
  cmdbuf_ptr = cmdbuf_base;
  cmdbuf_endp = cmdbuf_ptr + n;

  ssize_t r = read (pty->pty, cmdbuf_endp, 2048 /* size of command buffer*/ - n);

  if (r > 0){
      cmdbuf_endp += r;
      return true;
    }
//CMNT: possible_pointer ^|         else if (r < 0 && ((*__error()) == 35 /* Resource temporarily unavailable */ || (*__error()) == 4 /* Interrupted system call */)){
  else if (r < 0 && (( _ _error()) == 35 /* Resource temporarily unavailable */ || ( _ _error()) == 4 /* Interrupted system call */)){




    }
  else{
      pty_ev.stop ();

      if (!option (Opt_hold))
        destroy ();
    }

  return false;
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::pty_cb (ev::io &w, int revents){
rxvt_term.pty_cb =function(ev::io &w,  revents){
  make_current ();

  if (revents & ev::READ)
    // loop, but don't allow a single term to monopolize us
//CMNT: c_keyword ^|           for (int i = 8 /* never call pty_fill/cmd_parse more than this often in a row*/; i-- && pty_fill (); )
    for ( var i = 8 /* never call pty_fill/cmd_parse more than this often in a row*/; i-- && pty_fill (); )
      cmd_parse ();

  if (revents & ev::WRITE)
    pty_write ();

  refresh_check ();
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::pointer_unblank (){
rxvt_term.poer_unblank =function(){
  XDefineCursor (dpy, vt, TermWin_cursor);
  recolour_cursor ();







}
      //     # 1241 "command.C"
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::mouse_report (XButtonEvent &ev){
rxvt_term.mouse_report =function(XButtonEvent &ev){
//CMNT: c_keyword ^|         int button_number, key_state = 0;
   button_number, key_state = 0;
//CMNT: c_keyword ^|         int x, y;
   x, y;
//CMNT: js_style_variables ^|         int code = 32;
 var code= 32;

//CMNT: c_keyword ^|         x = ((int32_t)((int32_t)(ev.x)) / (int32_t)fwidth);
  x = ((32_t)((32_t)(ev.x)) / (32_t)fwidth);
//CMNT: c_keyword ^|         y = ((int32_t)((int32_t)(ev.y)) / (int32_t)fheight);
  y = ((32_t)((32_t)(ev.y)) / (32_t)fheight);
  if (ev.type == 6){
      if (x == mouse_row && y == mouse_col)
        return;
      mouse_row = x;
      mouse_col = y;
      code += 32;
    }

  if (MEvent.button == 0L /* special Button Code, passed to GrabButton */)
    button_number = 3;
  else{
      button_number = MEvent.button - 1;
      /* add 0x3D for wheel events, like xterm does */
      if (button_number >= 3)
        button_number += (64 - 3);
    }

  if (priv_modes & (1UL<<12)){
      /*
//CMNT: possible_pointer ^|              * do not report ButtonRelease
          do not report ButtonRelease
//CMNT: possible_pointer ^|              * no state info allowed
          no state info allowed
       */
      key_state = 0;
      if (button_number == 3)
        return;
    }
  else{
      /* XTerm mouse reporting needs these values:
//CMNT: possible_pointer ^|              *   4 = Shift
            4 = Shift
//CMNT: possible_pointer ^|              *   8 = Meta
            8 = Meta
//CMNT: possible_pointer ^|              *  16 = Control
           16 = Control
//CMNT: possible_pointer ^|              * plus will add in our own Double-Click reporting
          plus will add in our own Double-Click reporting
//CMNT: possible_pointer ^|              *  32 = Double Click
           32 = Double Click
       */
      key_state = ((MEvent.state & (1<<0)) ? 4 : 0)
                  + ((MEvent.state & ModMetaMask) ? 8 : 0)
                  + ((MEvent.state & (1<<2)) ? 16 : 0);



    }
      //     # 1312 "command.C"
//CMNT: c_keyword ^|         tt_printf ("\033[M%c%c%c",
  tt_prf ("\033[M%c%c%c",
            (code + button_number + key_state),
            (32 + x + 1),
            (32 + y + 1));
}

/*{{{ process an X event */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::x_cb (XEvent &ev){
rxvt_term.x_cb =function(XEvent &ev){
  make_current ();

//CMNT: c_keyword possible_pointer ^|         Display * const dpy = this->dpy;
  Display     dpy = this->dpy;

  if (ev.xany.window == vt
      && false
      && false)
    return;

//CMNT: c_keyword ^|         // for XQueryPointer
  // for XQueryPoer
  Window unused_root, unused_child;
//CMNT: c_keyword ^|         int unused_root_x, unused_root_y;
   unused_root_x, unused_root_y;
//CMNT: c_keyword ^|         unsigned int unused_mask;
    unused_mask;

  switch (ev.type){
      case 2:
        key_press (ev.xkey);
        break;

      case 3:
        key_release (ev.xkey);
        break;

      case 4:
        button_press (ev.xbutton);
        break;

      case 5:
        button_release (ev.xbutton);
        break;

      case 33:
        if (ev.xclient.format == 32
            && !false){
            if (ev.xclient.message_type == xa[XA_WM_PROTOCOLS]){
                if (!false){
                    if (ev.xclient.data.l[0] == xa[XA_WM_DELETE_WINDOW]){
                        if (!false)
                          destroy ();
                      }






                  }
              }
      //     # 1384 "command.C"
          }
        break;

        /*
//CMNT: possible_pointer ^|                * XXX: this is not the _current_ arrangement
            XXX: this is not the _current_ arrangement
//CMNT: possible_pointer ^|                * Here's my conclusion:
            Here's my conclusion:
//CMNT: possible_pointer ^|                * If the window is completely unobscured, use bitblt's
            If the window is completely unobscured, use bitblt's
//CMNT: possible_pointer ^|                * to scroll. Even then, they're only used when doing partial
            to scroll. Even then, they're only used when doing partial
//CMNT: possible_pointer ^|                * screen scrolling. When partially obscured, we have to fill
            screen scrolling. When partially obscured, we have to fill
//CMNT: possible_pointer ^|                * in the GraphicsExpose parts, which means that after each refresh,
            in the GraphicsExpose parts, which means that after each refresh,
//CMNT: possible_pointer ^|                * we need to wait for the graphics expose or Noexpose events,
            we need to wait for the graphics expose or Noexpose events,
//CMNT: possible_pointer ^|                * which ought to make things real slow!
            which ought to make things real slow!
         */
      case 15:
        switch (ev.xvisibility.state){
            case 0:
              refresh_type = FAST_REFRESH;
              break;
            case 1:
              refresh_type = SLOW_REFRESH;
              break;
            default:
              refresh_type = NO_REFRESH;
              break;
          }
        break;

      case 9:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_in ();
        break;

      case 10:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_out ();
        break;

      case 22:
//CMNT: c_keyword ^|               /*fprintf (stderr, "ConfigureNotify for %X, parent is %X, geom is %dx%d%+d%+d, old geom was %dx%d\n",
        /*fprf (stderr, "ConfigureNotify for %X, parent is %X, geom is %dx%d%+d%+d, old geom was %dx%d\n",
              ev.xconfigure.window, parent[0], ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y,
//CMNT: c_keyword ^|                     szHint.width, szHint.height);*/
              szH.width, szH.height);*/
        if (ev.xconfigure.window == parent[0]){
            while (XCheckTypedWindowEvent (dpy, ev.xconfigure.window, 22, &ev))
              ;

//CMNT: c_keyword ^|                   if (szHint.width != ev.xconfigure.width || szHint.height != ev.xconfigure.height){
            if (szH.width != ev.xconfigure.width || szH.height != ev.xconfigure.height){
                seen_resize = 1;
                resize_all_windows (ev.xconfigure.width, ev.xconfigure.height, 1);
              }
            else{
      //     # 1451 "command.C"
              }

            false;
          }
        break;

      case 28:
        if (!false)
          if (ev.xproperty.atom == xa[XA_VT_SELECTION]
              && ev.xproperty.state == 0)
            selection_property (ev.xproperty.window, ev.xproperty.atom);

        break;

      case 29:
        selection_clear ();
        break;

      case 31:
        if (selection_wait == 0x01 /* normal selection */)
          selection_paste (ev.xselection.requestor, ev.xselection.property, true);
        break;

      case 30:
        selection_send (ev.xselectionrequest);
        break;

      case 19:
      //     # 1495 "command.C"
        mapped = 1;

        text_blink_ev.start ();

        false;
        break;

      case 18:
        mapped = 0;

        text_blink_ev.stop ();

        false;
        break;

      case 13:
      case 12:
        if (ev.xany.window == vt){
            do
              {
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }
            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev));

            ev.xany.type = ev.xany.type == 12 ? 13 : 12;

            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev)){
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }

            want_refresh = 1;
          }
        else{
            XEvent unused_event;

            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 12, &unused_event))
              ;
            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 13, &unused_event))
              ;

            if (scrollBar.state && ev.xany.window == scrollBar.win){
                scrollBar.state = STATE_IDLE;
                scrollBar.show (0);
              }
          }
        break;

      case 6:




        if ((priv_modes & (1UL<<20) && ev.xbutton.state & ((1<<8)|(1<<9)|(1<<10)))
            || priv_modes & (1UL<<21))
          mouse_report (ev.xbutton);
        if ((priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))) && !bypass_keystate)
          break;

        if (ev.xany.window == vt){
            if (false
                && false)
              ; // nop
            else if (ev.xbutton.state & ((1<<8) | (1<<10))){
                while (XCheckTypedWindowEvent (dpy, vt, 6, &ev))
                  ;

//CMNT: c_keyword ^|                       XQueryPointer (dpy, vt,
                XQueryPoer (dpy, vt,
                               &unused_root, &unused_child,
                               &unused_root_x, &unused_root_y,
                               &ev.xbutton.x, &ev.xbutton.y,
                               &ev.xbutton.state);

                /* deal with a `jumpy' mouse */
                if ((ev.xmotion.time - MEvent.time) > 50){


                    // 5.4
                    if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/)){
                        iso14755_54 (ev.xbutton.x, ev.xbutton.y);
                        break;
                      }

                    selection_extend (ev.xbutton.x, ev.xbutton.y,
                                      ev.xbutton.state & (1<<10) ? 2 : 0);
      //     # 1636 "command.C"
                  }

              }
          }
        else if (scrollBar.state == STATE_MOTION && ev.xany.window == scrollBar.win){
            while (XCheckTypedWindowEvent (dpy, scrollBar.win,
                                           6, &ev))
              ;

//CMNT: c_keyword ^|                   XQueryPointer (dpy, scrollBar.win,
            XQueryPoer (dpy, scrollBar.win,
                          &unused_root, &unused_child,
                          &unused_root_x, &unused_root_y,
                          &ev.xbutton.x, &ev.xbutton.y,
                          &unused_mask);
            scr_move_to (((ev.xbutton.y) - scrollBar.beg) - csrO,
                         scrollBar.size ());
            want_refresh = 1;
            scrollBar.show (1);
          }
        break;
    }
      //     # 1686 "command.C"
  refresh_check ();
}
      //     # 1705 "command.C"
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::focus_in (){
rxvt_term.focus_in =function(){
  if (!focus){
      focus = 1;
      want_refresh = 1;
      //     # 1736 "command.C"
      false;
    }
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::focus_out (){
rxvt_term.focus_out =function(){
  if (focus){
      focus = 0;
      want_refresh = 1;






      if (iso14755buf){
          iso14755buf = 0;

          scr_overlay_off ();

        }
      //     # 1779 "command.C"
      false;
    }
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::update_fade_color (unsigned int idx){
rxvt_term.update_fade_color =function(  idx){
      //     # 1794 "command.C"
}
      //     # 1829 "command.C"
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::button_press (XButtonEvent &ev){
rxvt_term.button_press =function(XButtonEvent &ev){
//CMNT: c_keyword js_style_variables ^|         int reportmode = 0, clickintime;
 var reportmode= 0, clickime;

  bypass_keystate = ev.state & (ModMetaMask | (1<<0));

  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  /*
//CMNT: possible_pointer ^|          * VT window processing of button press
      VT window processing of button press
   */
  if (ev.window == vt){
      if (false)
        return;


      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/)){
          iso14755_54 (ev.x, ev.y);
          return;
        }


//CMNT: c_keyword ^|             clickintime = ev.time - MEvent.time < 500;
      clickime = ev.time - MEvent.time < 500;

      if (reportmode){
          /* mouse report from vt window */
          /* save the xbutton state (for ButtonRelease) */
          MEvent.state = ev.state;
      //     # 1888 "command.C"
          MEvent.button = ev.button;
          mouse_report (ev);


        }
      else{
          if (ev.button != MEvent.button)
            MEvent.clicks = 0;

          switch (ev.button){
              case 1:
                /* allow meta + click to select rectangular areas */
                /* should be done in screen.C */



                selection.rect = false;


                /* allow shift+left click to extend selection */
                if (ev.state & (1<<0) && !(priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)))){
//CMNT: c_keyword ^|                           if (MEvent.button == 1 && clickintime)
                    if (MEvent.button == 1 && clickime)
                      selection_rotate (ev.x, ev.y);
                    else
                      selection_extend (ev.x, ev.y, 1);
                  }
                else{
//CMNT: c_keyword ^|                           if (MEvent.button == 1 && clickintime)
                    if (MEvent.button == 1 && clickime)
                      MEvent.clicks++;
                    else
                      MEvent.clicks = 1;

                    selection_click (MEvent.clicks, ev.x, ev.y);
                  }

                MEvent.button = 1;
                break;

              case 3:
//CMNT: c_keyword ^|                       if (MEvent.button == 3 && clickintime)
                if (MEvent.button == 3 && clickime)
                  selection_rotate (ev.x, ev.y);
                else
                  selection_extend (ev.x, ev.y, 1);

                MEvent.button = 3;
                break;
            }
        }

      MEvent.time = ev.time;
      return;
    }

  /*
//CMNT: possible_pointer ^|          * Scrollbar window processing of button press
      Scrollbar window processing of button press
   */
  if (scrollBar.state && ev.window == scrollBar.win){
      page_dirn direction = NO_DIR;

      if (scrollBar.upButton (ev.y))
        direction = UP; /* up */
      else if (scrollBar.dnButton (ev.y))
        direction = DN; /* down */

      scrollBar.state = STATE_IDLE;
      /*
//CMNT: possible_pointer ^|              * Rxvt-style scrollbar:
          Rxvt-style scrollbar:
//CMNT: possible_pointer ^|              * move up if mouse is above slider
          move up if mouse is above slider
//CMNT: possible_pointer ^|              * move dn if mouse is below slider
          move dn if mouse is below slider
       *
//CMNT: possible_pointer ^|              * XTerm-style scrollbar:
          XTerm-style scrollbar:
//CMNT: c_keyword possible_pointer ^|              * Move display proportional to pointer location
          Move display proportional to poer location
//CMNT: c_keyword possible_pointer ^|              * pointer near top -> scroll one line
          poer near top -> scroll one line
//CMNT: c_keyword possible_pointer ^|              * pointer near bot -> scroll full page
          poer near bot -> scroll full page
       */

      if (reportmode){
          /*
//CMNT: possible_pointer ^|                  * Mouse report disabled scrollbar:
              Mouse report disabled scrollbar:
//CMNT: possible_pointer ^|                  * arrow buttons - send up/down
              arrow buttons - send up/down
//CMNT: possible_pointer ^|                  * click on scrollbar - send pageup/down
              click on scrollbar - send pageup/down
           */
          if (direction == UP)
//CMNT: c_keyword ^|                   tt_printf ("\033[A");
            tt_prf ("\033[A");
          else if (direction == DN)
//CMNT: c_keyword ^|                   tt_printf ("\033[B");
            tt_prf ("\033[B");
          else
            switch (ev.button){
                case 2:
//CMNT: c_keyword ^|                         tt_printf ("\014");
                  tt_prf ("\014");
                  break;
                case 1:
//CMNT: c_keyword ^|                         tt_printf ("\033[6~");
                  tt_prf ("\033[6~");
                  break;
                case 3:
//CMNT: c_keyword ^|                         tt_printf ("\033[5~");
                  tt_prf ("\033[5~");
                  break;
              }
        }
      else

        {
          if (direction != NO_DIR){




              if (scr_page (direction, 1)){
                  if (direction == UP)
                    scrollBar.state = STATE_UP;
                  else
                    scrollBar.state = STATE_DOWN;
                }
            }
          else
            switch (ev.button){
                case 2:
                  switch (scrollBar.align){
                      case 1:
                        csrO = 0;
                        break;
                      case 0:
                        csrO = (scrollBar.bot - scrollBar.top) / 2;
                        break;
                      case 2:
                        csrO = scrollBar.bot - scrollBar.top;
                        break;
                    }

                  if (scrollBar.style == 2
                      || ((ev.y) < scrollBar.top)
                      || ((ev.y) > scrollBar.bot))
                    scr_move_to (((ev.y) - scrollBar.beg) - csrO, scrollBar.size ());

                  scrollBar.state = STATE_MOTION;
                  break;

                case 1:
                  if (scrollBar.align == 0)
                    csrO = ev.y - scrollBar.top;
                  /* FALLTHROUGH */

                case 3:
                  if (scrollBar.style != 2){
                      if (((ev.y) < scrollBar.top))

                        scr_page (UP, nrow - 1);



                      else if (((ev.y) > scrollBar.bot))

                        scr_page (DN, nrow - 1);



                      else
                        scrollBar.state = STATE_MOTION;
                    }
                  else{
                      scr_page ((ev.button == 1 ? DN : UP),
                                (nrow
//CMNT: possible_pointer ^|                                        * ((ev.y) - scrollBar.beg)
                                    ((ev.y) - scrollBar.beg)
                                 / scrollBar.size ()));
                    }

                  break;
              }
        }

      return;
    }
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::button_release (XButtonEvent &ev){
rxvt_term.button_release =function(XButtonEvent &ev){
//CMNT: js_style_variables ^|         int reportmode = 0;
 var reportmode= 0;

  csrO = 0; /* reset csr Offset */
  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  if (scrollBar.state == STATE_UP || scrollBar.state == STATE_DOWN){
      scrollBar.state = STATE_IDLE;
      scrollBar.show (0);
    }



  if (ev.window == vt){
      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
        return;


      if (reportmode){
          /* mouse report from vt window */
          /* don't report release of wheel "buttons" */
          if (ev.button >= 4)
            return;
      //     # 2123 "command.C"
          MEvent.button = 0L /* special Button Code, passed to GrabButton */;
          mouse_report (ev);

          return;
        }

      /*
//CMNT: possible_pointer ^|              * dumb hack to compensate for the failure of click-and-drag
          dumb hack to compensate for the failure of click-and-drag
//CMNT: possible_pointer ^|              * when overriding mouse reporting
          when overriding mouse reporting
       */
      if (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))
          && bypass_keystate
          && ev.button == 1 && MEvent.clicks <= 1)
        selection_extend (ev.x, ev.y, 0);

      switch (ev.button){
          case 1:
          case 3:
            selection_make (ev.time);
            break;

          case 2:
//CMNT: c_keyword ^|                   if (((unsigned int)(ev.x) - (unsigned int)(0) < (unsigned int)(width) - (unsigned int)(0)) && ((unsigned int)(ev.y) - (unsigned int)(0) < (unsigned int)(height) - (unsigned int)(0))) // inside window?
            if (((ev.x)  < (width) ) && ((ev.y)  < (height) )) // inside window?
       selection_request (ev.time, ev.state & ModMetaMask ? 0x03 : 0x01);
            break;
      //     # 2185 "command.C"
        }
    }
};

/*}}} */

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::cmd_parse (){
rxvt_term.cmd_parse =function(){
//CMNT: js_style_variables ^|         wchar_t ch = NOCHAR;
 var ch= NOCHAR;
//CMNT: c_keyword possible_pointer ^|         char *seq_begin; // remember start of esc-sequence here
    s eq_begin; // remember start of esc-sequence here

  for (;;){
      if (__builtin_expect (((ch == NOCHAR) != 0),(0))){
          seq_begin = cmdbuf_ptr;
//CMNT: c_keyword ^|                 ch = next_char ();
          ch = next_ ();

          if (ch == NOCHAR)
            break;
        }

      if (__builtin_expect (((!!((ch) & 0xffffff60UL) || ch == C0_LF || ch == C0_CR || ch == C0_HT) != 0),(1))){
          if (__builtin_expect (((!seen_input) != 0),(0))){
              seen_input = 1;
              // many badly-written programs (e.g. jed) contain a race condition:
              // they first read the screensize and then install a SIGWINCH handler.
              // some window managers resize the window early, and these programs
              // then sometimes get the size wrong.
              // unfortunately other programs are even more buggy and dislike
              // being sent SIGWINCH, so only do it when we were in fact being
              // resized.
              if (seen_resize && cmd_pid)
                kill (-cmd_pid, 28 /* window size changes */);
            }

          /* Read a text string from the input buffer */
//CMNT: c_keyword ^|                 wchar_t buf[2048 /* character buffer*/];
           buf[2048 /* acter buffer*/];
          bool refreshnow = false;
//CMNT: js_style_variables ^|                 int nlines = 0;
 var nlines= 0;
//CMNT: c_keyword possible_pointer ^|                 wchar_t *str = buf;
            s tr = buf;
//CMNT: c_keyword possible_pointer ^|                 wchar_t *eol = str + min (ncol, 2048 /* character buffer*/);
            e ol = str + min (ncol, 2048 /* acter buffer*/);

          for (;;){
              if (__builtin_expect (((ch == NOCHAR || (!((ch) & 0xffffff60UL) && ch != C0_LF && ch != C0_CR && ch != C0_HT)) != 0),(0)))
                break;

//CMNT: possible_pointer                      *str++ = ch;
               str++ = ch;

              if (__builtin_expect (((ch == C0_LF || str >= eol) != 0),(0))){
                  if (ch == C0_LF)
                    nlines++;

                  refresh_count++;

                  if (!option (Opt_jumpScroll) || refresh_count >= nrow - 1){
                      refresh_count = 0;

//CMNT: js_style_functions ^|                             if (!option (Opt_skipScroll) || ev_time () > ev::now () + 1. / 60.){
                      if (!option (Opt_skipScroll) || ev_time () >ev.now =function() + 1. / 60.){
                          refreshnow = true;
                          ch = NOCHAR;
                          break;
                        }
                    }

                  // scr_add_lines only works for nlines <= nrow - 1.
                  if (nlines >= nrow - 1){
                      if (!(false
                            && false))
                        scr_add_lines (buf, str - buf, nlines);

                      nlines = 0;
                      str = buf;
//CMNT: c_keyword ^|                             eol = str + min (ncol, 2048 /* character buffer*/);
                      eol = str + min (ncol, 2048 /* acter buffer*/);
                    }

                  if (str >= eol){
//CMNT: c_keyword ^|                             if (eol >= buf + 2048 /* character buffer*/){
                      if (eol >= buf + 2048 /* acter buffer*/){
                          ch = NOCHAR;
                          break;
                        }
                      else
//CMNT: c_keyword ^|                               eol = min (eol + ncol, buf + 2048 /* character buffer*/);
                        eol = min (eol + ncol, buf + 2048 /* acter buffer*/);
                    }

                }

              seq_begin = cmdbuf_ptr;
//CMNT: c_keyword ^|                     ch = next_char ();
              ch = next_ ();
            }

          if (!(false
                && false))
            scr_add_lines (buf, str - buf, nlines);

          /*
//CMNT: possible_pointer ^|                  * If there have been a lot of new lines, then update the screen
              If there have been a lot of new lines, then update the screen
//CMNT: possible_pointer ^|                  * What the heck we'll cheat and only refresh less than every page-full.
              What the heck we'll cheat and only refresh less than every page-full.
//CMNT: possible_pointer ^|                  * if skipScroll is enabled.
              if skipScroll is enabled.
           */
          if (refreshnow){
              scr_refresh ();
              want_refresh = 1;
            }
        }
      else{
          try
            {
//CMNT: c_keyword ^|                     process_nonprinting (ch);
              process_nonpring (ch);
            }
//CMNT: c_keyword ^|                 catch (const class out_of_input &o){
          catch ( class out_of_input &o){
              // we ran out of input, retry later
              cmdbuf_ptr = seq_begin;
              break;
            }

          ch = NOCHAR;
        }
    }
}

//CMNT: c_keyword ^|       // read the next character
// read the next acter
//CMNT: js_style_functions c_keyword ^|       wchar_t rxvt_term::next_char (){
rxvt_term.next_ =function(){
  while (cmdbuf_ptr < cmdbuf_endp){
      // assume 7-bit to be ascii ALWAYS
//CMNT: c_keyword possible_pointer ^|             if (__builtin_expect ((((unsigned char)*cmdbuf_ptr <= 0x7f && *cmdbuf_ptr != 0x1b) != 0),(1)))
      if (__builtin_expect (((( ) c mdbuf_ptr <= 0x7f &&  c mdbuf_ptr != 0x1b) != 0),(1)))
//CMNT: possible_pointer ^|               return *cmdbuf_ptr++;
        return  c mdbuf_ptr++;

//CMNT: c_keyword ^|             wchar_t wc;
       wc;
      size_t len = mbrtowc (&wc, cmdbuf_ptr, cmdbuf_endp - cmdbuf_ptr, mbstate);

      if (len == (size_t)-2){
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }

      if (len == (size_t)-1){
          mbrtowc (0, 0, 0, mbstate); // reset now undefined conversion state
//CMNT: c_keyword possible_pointer ^|                 return (unsigned char)*cmdbuf_ptr++; // the _occasional_ latin1 character is allowed to slip through
          return ( ) c mdbuf_ptr++; // the _occasional_ latin1 acter is allowed to slip through
        }

//CMNT: c_keyword ^|             // assume wchar == unicode
      // assume w == unicode
      cmdbuf_ptr += len;
      return wc & 0x1fffffUL;
    }

  return NOCHAR;
}

// read the next octet
//CMNT: c_keyword ^|       uint32_t
u32_t
//CMNT: js_style_functions ^|       rxvt_term::next_octet (){
rxvt_term.next_octet =function(){
  return cmdbuf_ptr < cmdbuf_endp
//CMNT: c_keyword possible_pointer ^|                ? (unsigned char)*cmdbuf_ptr++
         ? ( ) c mdbuf_ptr++
         : NOCHAR;
}

//CMNT: c_keyword ^|       static class out_of_input out_of_input;
 class out_of_input out_of_input;

//CMNT: c_keyword ^|       /* rxvt_cmd_getc () - Return next input character */
/* rxvt_cmd_getc () - Return next input acter */
/*
//CMNT: c_keyword possible_pointer ^|        * Return the next input character after first passing any keyboard input
    Return the next input acter after first passing any keyboard input
//CMNT: possible_pointer ^|        * to the command.
    to the command.
 */
//CMNT: js_style_functions c_keyword ^|       wchar_t rxvt_term::cmd_getc (){
rxvt_term.cmd_getc =function(){
//CMNT: c_keyword js_style_variables ^|         wchar_t c = next_char ();
 var c= next_ ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

//CMNT: c_keyword ^|       uint32_t
u32_t
rxvt_term::cmd_get8 (){
//CMNT: c_keyword ^|         uint32_t c = next_octet ();
  u32_t c = next_octet ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

//CMNT: c_keyword ^|       /*{{{ print pipe */
/*{{{ pr pipe */
/*----------------------------------------------------------------------*/

FILE *
//CMNT: js_style_functions c_keyword ^|       rxvt_term::popen_printer (){
rxvt_term.popen_prer =function(){
//CMNT: c_keyword possible_pointer ^|         FILE *stream = popen (rs[Rs_print_pipe] ? rs[Rs_print_pipe] : "lpr", "w");
  FILE  s tream = popen (rs[Rs_pr_pipe] ? rs[Rs_pr_pipe] : "lpr", "w");

  if (stream == __null)
//CMNT: c_keyword ^|           rxvt_warn ("can't open printer pipe, not printing.\n");
    rxvt_warn ("can't open prer pipe, not pring.\n");

  return stream;
}

//CMNT: js_style_functions c_keyword possible_pointer ^|       int rxvt_term::pclose_printer (FILE *stream){
rxvt_term.pclose_prer =function(FILE  s tream){
  fflush (stream);
  return pclose (stream);
}

/*
//CMNT: c_keyword possible_pointer ^|        * simulate attached vt100 printer
    simulate attached vt100 prer
 */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_print_pipe (){
rxvt_term.process_pr_pipe =function(){
//CMNT: c_keyword possible_pointer ^|         FILE *fd = popen_printer ();
  FILE  f d = popen_prer ();

  if (!fd)
    return;

  /*
//CMNT: c_keyword possible_pointer ^|          * Send all input to the printer until either ESC[4i or ESC[?4i
      Send all input to the prer until either ESC[4i or ESC[?4i
//CMNT: possible_pointer ^|          * is received.
      is received.
   */
//CMNT: c_keyword ^|         for (int done = 0; !done; ){
  for ( done = 0; !done; ){
//CMNT: c_keyword ^|             unsigned char buf[8];
        buf[8];
//CMNT: c_keyword ^|             unicode_t ch;
      ch;
//CMNT: c_keyword ^|             unsigned int i, len;
        var i, len;

      if ((ch = cmd_getc ()) != C0_ESC){
          if (putc (ch, fd) == (-1))
            break; /* done = 1 */
        }
      else{
          len = 0;
          buf[len++] = ch;
          var  quest="?";
          if ((buf[len++] = cmd_getc ()) == '['){ //]
              if(ch= cmd_getc()){

              }

/*              if ((ch = cmd_getc()) == '?'){
                  buf[len++] = '?';
                  ch = cmd_getc();
                }
*/              if ((buf[len++] = ch) == '4'){
                  if ((buf[len++] = cmd_getc ()) == 'i')
                    break; /* done = 1 */
                }
            }

          for (i = 0; i < len; i++)
            if (putc (buf[i], fd) == (-1)){
                done = 1;
                break;
              }
        }
    }

//CMNT: c_keyword ^|         pclose_printer (fd);
  pclose_prer (fd);
}

/*}}} */

//CMNT: possible_pointer ^|       /* *INDENT-OFF* */
/*  I NDENT-OFF   */
enum {
  C1_40 = 0x40,
          C1_41 , C1_BPH, C1_NBH, C1_44 , C1_NEL, C1_SSA, C1_ESA,
  C1_HTS, C1_HTJ, C1_VTS, C1_PLD, C1_PLU, C1_RI , C1_SS2, C1_SS3,
  C1_DCS, C1_PU1, C1_PU2, C1_STS, C1_CCH, C1_MW , C1_SPA, C1_EPA,
  C1_SOS, C1_59 , C1_SCI, C1_CSI, CS_ST , C1_OSC, C1_PM , C1_APC,
};
//CMNT: possible_pointer ^|       /* *INDENT-ON* */
/*  I NDENT-ON   */

//CMNT: c_keyword ^|       /*{{{ process non-printing single characters */
/*{{{ process non-pring single acters */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_nonprinting (unicode_t ch){
rxvt_term.process_nonpring =function(ch){
  switch (ch){
      case C0_ESC:
        process_escape_seq ();
        break;
      case C0_ENQ: /* terminal Status */
        if (rs[Rs_answerbackstring])
          tt_write (rs [Rs_answerbackstring], (strlen)(rs [Rs_answerbackstring]));
        else
          tt_write ("\033[?1;2c" /* vt100 answerback */, (strlen)("\033[?1;2c" /* vt100 answerback */));
        break;
      case C0_BEL: /* bell */
        scr_bell ();
        break;
      case C0_BS: /* backspace */
        scr_backspace ();
        break;
      case C0_HT: /* tab */
        scr_tab (1);
        break;
      case C0_CR: /* carriage return */
        scr_gotorc (0, 0, R_RELATIVE);
        break;
      case C0_VT: /* vertical tab, form feed */
      case C0_FF:
      case C0_LF: /* line feed */
        scr_index (UP);
        break;
      case C0_SO: /* shift out - acs */
//CMNT: c_keyword ^|               scr_charset_choose (1);
        scr_set_choose (1);
        break;
      case C0_SI: /* shift in - acs */
//CMNT: c_keyword ^|               scr_charset_choose (0);
        scr_set_choose (0);
        break;
      //     # 2532 "command.C"
    }
}
/*}}} */


/*{{{ process VT52 escape sequences */
//CMNT: c_keyword ^|       void

//CMNT: c_keyword ^|       rxvt_term::process_escape_vt52 (unicode_t ch){
rxvt_term::process_escape_vt52 (ch){
//CMNT: c_keyword ^|         int row, col;
   row, col;

  switch (ch){
      case 'A': /* cursor up */
        scr_gotorc (-1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'B': /* cursor down */
        scr_gotorc (1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'C': /* cursor right */
        scr_gotorc (0, 1, R_RELATIVE | C_RELATIVE);
        break;
      case 'D': /* cursor left */
        scr_gotorc (0, -1, R_RELATIVE | C_RELATIVE);
        break;
      case 'H': /* cursor home */
        scr_gotorc (0, 0, 0);
        break;
      case 'I': /* cursor up and scroll down if needed */
        scr_index (DN);
        break;
      case 'J': /* erase to end of screen */
        scr_erase_screen (0);
        break;
      case 'K': /* erase to end of line */
        scr_erase_line (0);
        break;
      case 'Y': /* move to specified row and col */
        /* full command is 'ESC Y row col' where row and col
//CMNT: possible_pointer ^|                * are encoded by adding 32 and sending the ascii
            are encoded by adding 32 and sending the ascii
//CMNT: c_keyword possible_pointer ^|                * character.  eg. SPACE = 0, '+' = 13, '0' = 18,
            acter.  eg. SPACE = 0, '+' = 13, '0' = 18,
//CMNT: possible_pointer ^|                * etc. */
            etc. */
        row = cmd_getc () - ' ';
        col = cmd_getc () - ' ';
        scr_gotorc (row, col, 0);
        break;
      case 'Z': /* identify the terminal type */
//CMNT: c_keyword ^|               tt_printf ("\033/Z"); /* I am a VT100 emulating a VT52 */
        tt_prf ("\033/Z"); /* I am a VT100 emulating a VT52 */
        break;
      case '<': /* turn off VT52 mode */
        set_privmode ((1UL<<18), 0);
        break;
//CMNT: c_keyword ^|             case 'F': /* use special graphics character set */
      case 'F': /* use special graphics acter set */
//CMNT: c_keyword ^|             case 'G': /* use regular character set */
      case 'G': /* use regular acter set */
        /* unimplemented */
        break;
      case '=': /* use alternate keypad mode */
      case '>': /* use regular keypad mode */
        /* unimplemented */
        break;
    }
}
/*}}} */


/*{{{ process escape sequences */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_escape_seq (){
rxvt_term.process_escape_seq =function(){
//CMNT: js_style_variables ^|         unicode_t ch = cmd_getc ();
 var ch= cmd_getc ();

  if (priv_modes & (1UL<<18)){
      process_escape_vt52 (ch);
      return;
    }

  switch (ch){
        /* case 1:        do_tek_mode (); break; */
      case '#':
        if (cmd_getc () == '8')
          scr_E ();
        break;
      case '(':
//CMNT: c_keyword ^|               scr_charset_set (0, (unsigned int)cmd_getc ());
        scr_set_set (0, ( )cmd_getc ());
        break;
      case ')':
//CMNT: c_keyword ^|               scr_charset_set (1, (unsigned int)cmd_getc ());
        scr_set_set (1, ( )cmd_getc ());
        break;
//CMNT: possible_pointer ^|             case '*':
      case ' ' :
//CMNT: c_keyword ^|               scr_charset_set (2, (unsigned int)cmd_getc ());
        scr_set_set (2, ( )cmd_getc ());
        break;
      case '+':
//CMNT: c_keyword ^|               scr_charset_set (3, (unsigned int)cmd_getc ());
        scr_set_set (3, ( )cmd_getc ());
        break;





      case '7':
        scr_cursor (SAVE);
        break;
      case '8':
        scr_cursor (RESTORE);
        break;





      case '=':
      case '>':
        set_privmode ((1UL<<7), ch == '=');
        break;

      case C1_40:
        cmd_getc ();
        break;
      case C1_44:
        scr_index (UP);
        break;

        /* 8.3.87: NEXT LINE */
      case C1_NEL: /* ESC E */
        {
//CMNT: js_style_variables js_style_arrays ^|                 wchar_t nlcr[] = { C0_LF, C0_CR };
 var nlcr= [ C0_LF, C0_CR ] ;
          scr_add_lines (nlcr, sizeof (nlcr) / sizeof (nlcr [0]), 1);
        }
        break;

        /* kidnapped escape sequence: Should be 8.3.48 */
      case C1_ESA: /* ESC G */
        process_graphics ();
        break;

        /* 8.3.63: CHARACTER TABULATION SET */
      case C1_HTS: /* ESC H */
        scr_set_tab (1);
        break;

        /* 8.3.105: REVERSE LINE FEED */
      case C1_RI: /* ESC M */
        scr_index (DN);
        break;

        /* 8.3.142: SINGLE-SHIFT TWO */
      /*case C1_SS2: scr_single_shift (2);   break; */

        /* 8.3.143: SINGLE-SHIFT THREE */
      /*case C1_SS3: scr_single_shift (3);   break; */

        /* 8.3.27: DEVICE CONTROL STRING */
      case C1_DCS: /* ESC P */
        process_dcs_seq ();
        break;

        /* 8.3.110: SINGLE CHARACTER INTRODUCER */
      case C1_SCI: /* ESC Z */
        tt_write ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */, sizeof ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */) - 1);
        break; /* steal obsolete ESC [ c */

        /* 8.3.16: CONTROL SEQUENCE INTRODUCER (CSI) */
      case C1_CSI: /* ESC [ */
        process_csi_seq ();
        break;

        /* 8.3.90: OPERATING SYSTEM COMMAND (OSC) */
      case C1_OSC: /* ESC ] */
        process_osc_seq ();
        break;

        /* 8.3.106: RESET TO INITIAL STATE (RIS) */
      case 'c':
        mbstate.reset ();
        scr_poweron ();
        scrollBar.show (1);
        break;

        /* 8.3.79: LOCKING-SHIFT TWO (see ISO2022) */
      case 'n':
//CMNT: c_keyword ^|               scr_charset_choose (2);
        scr_set_choose (2);
        break;

        /* 8.3.81: LOCKING-SHIFT THREE (see ISO2022) */
      case 'o':
//CMNT: c_keyword ^|               scr_charset_choose (3);
        scr_set_choose (3);
        break;
    }
}
/*}}} */

/*{{{ process CONTROL SEQUENCE INTRODUCER (CSI) sequences `ESC[' */
//CMNT: possible_pointer ^|       /* *INDENT-OFF* */
/*  I NDENT-OFF   */
enum {
  CSI_ICH = 0x40,
           CSI_CUU, CSI_CUD, CSI_CUF, CSI_CUB, CSI_CNL, CSI_CPL, CSI_CHA,
  CSI_CUP, CSI_CHT, CSI_ED , CSI_EL , CSI_IL , CSI_DL , CSI_EF , CSI_EA ,
  CSI_DCH, CSI_SEE, CSI_CPR, CSI_SU , CSI_SD , CSI_NP , CSI_PP , CSI_CTC,
  CSI_ECH, CSI_CVT, CSI_CBT, CSI_SRS, CSI_PTX, CSI_SDS, CSI_SIMD, CSI_5F,
  CSI_HPA, CSI_HPR, CSI_REP, CSI_DA , CSI_VPA, CSI_VPR, CSI_HVP, CSI_TBC,
  CSI_SM , CSI_MC , CSI_HPB, CSI_VPB, CSI_RM , CSI_SGR, CSI_DSR, CSI_DAQ,
  CSI_70 , CSI_71 , CSI_72 , CSI_73 , CSI_74 , CSI_75 , CSI_76 , CSI_77 ,
  CSI_78 , CSI_79 , CSI_7A , CSI_7B , CSI_7C , CSI_7D , CSI_7E , CSI_7F
};







//CMNT: c_keyword ^|       const unsigned char csi_defaults[] =
   csi_defaults[] =
  {
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (1)), /* @, A, B, C, D, E, F, G, */
    (((1) << 7) | ((1) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((0) << 1) | (0)), /* H, I, J, K, L, M, N, O, */
    (((1) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* P, Q, R, S, T, U, V, W, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((1) << 1) | (0)), /* X, Y, Z, [, \, ], ^, _, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* `, a, b, c, d, e, f, g, */
    (((0) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* h, i, j, k, l, m, n, o, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* p, q, r, s, t, u, v, w, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* x, y, z, {, |, }, ~,    */
  };
//CMNT: possible_pointer ^|       /* *INDENT-ON* */
/*  I NDENT-ON   */

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_csi_seq (){
rxvt_term.process_csi_seq =function(){
//CMNT: c_keyword ^|         unicode_t ch, priv, i;
  ch, priv, i;
//CMNT: c_keyword ^|         unsigned int nargs, p;
    nargs, p;
//CMNT: c_keyword ^|         int n, ndef;
   n, ndef;
//CMNT: c_keyword ^|         int arg[32 /* max # of args for esc sequences */] = { };
   arg[32 /* max # of args for esc sequences */] = { };

  nargs = 0;

  priv = 0;
  ch = cmd_getc ();
  if ((ch >= '<' && ch <= '?') || ch == '!'){
      /* '<' '=' '>' '?' '!' */
      priv = ch;
      ch = cmd_getc ();
    }

  /* read any numerical arguments */
  for (n = -1; ch < CSI_ICH; ){
      if (isdigit (ch)){
          if (n < 0)
            n = ch - '0';
          else
//CMNT: possible_pointer ^|                   n = n * 10 + ch - '0';
            n = n    10 + ch - '0';
        }
      else if (ch == ';'){
          if (nargs < 32 /* max # of args for esc sequences */)
            arg[nargs++] = n;
          n = -1;
        }
      else if (!((ch) & 0xffffff60UL))
//CMNT: c_keyword ^|               process_nonprinting (ch);
        process_nonpring (ch);

      ch = cmd_getc ();
    }

  if (ch > CSI_7F)
    return;

  if (nargs < 32 /* max # of args for esc sequences */)
    arg[nargs++] = n;

  i = ch - CSI_ICH;
  ndef = (!! ((csi_defaults)[ (i) / 8] & (128 >> ((i) & 7))));
  for (p = 0; p < nargs; p++)
    if (arg[p] == -1)
      arg[p] = ndef;

  /*
//CMNT: possible_pointer ^|          * private mode handling
      private mode handling
   */
  if (priv){
      switch (priv){
          case '>':
            if (ch == CSI_DA) /* secondary device attributes */
              {
                // first parameter is normally 0 for vt100, 1 for vt220, 'R' for rxvt,
                // 'U' for rxvt-unicode != 7.[34] (where it was broken).
                //
                // second parameter is xterm patch level for xterm, MMmmpp (e.g. 20703) for rxvt
                // and Mm (e.g. 72 for 7.2) for urxvt <= 7.2, 94 for urxvt <= 8.3, and 95 for later
                // versions.
                //
//CMNT: c_keyword ^|                       tt_printf ("\033[>%d;95;0c", 'U');
                tt_prf ("\033[>%d;95;0c", 'U');
              }
            break;

          case '?':
            if (ch == 'h' || ch == 'l' || ch == 'r' || ch == 's' || ch == 't')
              process_terminal_mode (ch, priv, nargs, arg);
            break;

          case '!':
            if (ch == CSI_70){
                /* DECSTR: soft terminal reset, used by our terminfo since 9.06 */
                scr_soft_reset ();

//CMNT: js_style_variables js_style_arrays ^|                       static const int pm_h[] = { 7, 25 };
 var pm_h= [ 7, 25 ] ;
//CMNT: js_style_variables js_style_arrays ^|                       static const int pm_l[] = { 1, 3, 4, 5, 6, 9, 66, 1000, 1001, 1049 };
 var pm_l= [ 1, 3, 4, 5, 6, 9, 66, 1000, 1001, 1049 ] ;

                process_terminal_mode ('h', 0, sizeof (pm_h) / sizeof (pm_h[0]), pm_h);
                process_terminal_mode ('l', 0, sizeof (pm_l) / sizeof (pm_l[0]), pm_l);
              }
          break;
        }

      return;
    }

  switch (ch){
        /*
//CMNT: possible_pointer ^|                * ISO/IEC 6429:1992 (E) CSI sequences (defaults in parentheses)
            ISO/IEC 6429:1992 (E) CSI sequences (defaults in parentheses)
         */

      case CSI_MC: /* 8.3.83: (0) MEDIA COPY */
        switch (arg[0]){
            case 0: /* initiate transfer to primary aux device */
//CMNT: c_keyword ^|                     scr_printscreen (0);
              scr_prscreen (0);
              break;
            case 5: /* start relay to primary aux device */
//CMNT: c_keyword ^|                     process_print_pipe ();
              process_pr_pipe ();
              break;
          }
        break;


      case CSI_CUU: /* 8.3.22: (1) CURSOR UP */
      case CSI_VPR: /* 8.3.161: (1) LINE POSITION FORWARD */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CUD: /* 8.3.19: (1) CURSOR DOWN */
      case CSI_VPB: /* 8.3.160: (1) LINE POSITION BACKWARD */
        scr_gotorc (arg[0], 0, RELATIVE);
        break;

      case CSI_CUB: /* 8.3.18: (1) CURSOR LEFT */
      case CSI_HPB: /* 8.3.59: (1) CHARACTER POSITION BACKWARD */



        arg[0] = arg[0] ? -arg[0] : -1;

        /* FALLTHROUGH */
      case CSI_CUF: /* 8.3.20: (1) CURSOR RIGHT */
      case CSI_HPR: /* 8.3.60: (1) CHARACTER POSITION FORWARD */



        scr_gotorc (0, arg[0] ? arg[0] : 1, RELATIVE);

        break;

      case CSI_CPL: /* 8.3.13: (1) CURSOR PRECEDING LINE */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CNL: /* 8.3.12: (1) CURSOR NEXT LINE */
        scr_gotorc (arg[0], 0, R_RELATIVE);
        break;

      case CSI_CHA: /* 8.3.9: (1) CURSOR CHARACTER ABSOLUTE */
      case CSI_HPA: /* 8.3.58: (1) CURSOR POSITION ABSOLUTE */
        scr_gotorc (0, arg[0] - 1, R_RELATIVE);
        break;

      case CSI_VPA: /* 8.3.159: (1) LINE POSITION ABSOLUTE */
        scr_gotorc (arg[0] - 1, 0, C_RELATIVE);
        break;

      case CSI_CUP: /* 8.3.21: (1,1) CURSOR POSITION */
      case CSI_HVP: /* 8.3.64: (1,1) CHARACTER AND LINE POSITION */
        scr_gotorc (arg[0] - 1, nargs < 2 ? 0 : (arg[1] - 1), 0);
        break;

      case CSI_CBT: /* 8.3.7: (1) CURSOR BACKWARD TABULATION */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CHT: /* 8.3.10: (1) CURSOR FORWARD TABULATION */
        scr_tab (arg[0]);
        break;

      case CSI_ED: /* 8.3.40: (0) ERASE IN PAGE */
        scr_erase_screen (arg[0]);
        break;

      case CSI_EL: /* 8.3.42: (0) ERASE IN LINE */
        scr_erase_line (arg[0]);
        break;

      case CSI_ICH: /* 8.3.65: (1) INSERT CHARACTER */
//CMNT: c_keyword ^|               scr_insdel_chars (arg[0], INSERT);
        scr_insdel_s (arg[0], INSERT);
        break;

      case CSI_IL: /* 8.3.68: (1) INSERT LINE */
        scr_insdel_lines (arg[0], INSERT);
        break;

      case CSI_DL: /* 8.3.33: (1) DELETE LINE */
        scr_insdel_lines (arg[0], DELETE);
        break;

      case CSI_ECH: /* 8.3.39: (1) ERASE CHARACTER */
//CMNT: c_keyword ^|               scr_insdel_chars (arg[0], ERASE);
        scr_insdel_s (arg[0], ERASE);
        break;

      case CSI_DCH: /* 8.3.26: (1) DELETE CHARACTER */
//CMNT: c_keyword ^|               scr_insdel_chars (arg[0], DELETE);
        scr_insdel_s (arg[0], DELETE);
        break;

      case CSI_SD: /* 8.3.114: (1) SCROLL DOWN */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_SU: /* 8.3.148: (1) SCROLL UP */
        scr_scroll_text (screen.tscroll, screen.bscroll, arg[0]);
        break;

      case CSI_DA: /* 8.3.24: (0) DEVICE ATTRIBUTES */
        tt_write ("\033[?1;2c" /* vt100 answerback */, sizeof ("\033[?1;2c" /* vt100 answerback */) - 1);
        break;

      case CSI_SGR: /* 8.3.118: (0) SELECT GRAPHIC RENDITION */
        process_sgr_mode (nargs, arg);
        break;

      case CSI_DSR: /* 8.3.36: (0) DEVICE STATUS REPORT */
        switch (arg[0]){
            case 5: /* DSR requested */
//CMNT: c_keyword ^|                     tt_printf ("\033[0n");
              tt_prf ("\033[0n");
              break;
            case 6: /* CPR requested */
              scr_report_position ();
              break;
            case 7: /* unofficial extension */
              if (option (Opt_insecure))
//CMNT: c_keyword ^|                       tt_printf ("%-.250s\012", rs[Rs_display_name]);
                tt_prf ("%-.250s\012", rs[Rs_display_name]);
              break;
            case 8: /* unofficial extension */
              process_xterm_seq (XTerm_title, "urxvt" "-" "9.06", 0x9c /* 0234 */);
              break;
          }
        break;

      case CSI_TBC: /* 8.3.155: (0) TABULATION CLEAR */
        switch (arg[0]){
//CMNT: c_keyword ^|                   case 0: /* char tab stop cleared at active position */
            case 0: /*  tab stop cleared at active position */
              scr_set_tab (0);
              break;
              /* case 1: */ /* line tab stop cleared in active line */
//CMNT: c_keyword ^|                     /* case 2: */ /* char tab stops cleared in active line */
              /* case 2: */ /*  tab stops cleared in active line */
//CMNT: c_keyword ^|                   case 3: /* all char tab stops are cleared */
            case 3: /* all  tab stops are cleared */
              /* case 4: */ /* all line tab stops are cleared */
            case 5: /* all tab stops are cleared */
              scr_set_tab (-1);
              break;
          }
        break;

      case CSI_CTC: /* 8.3.17: (0) CURSOR TABULATION CONTROL */
        switch (arg[0]){
//CMNT: c_keyword ^|                   case 0: /* char tab stop set at active position */
            case 0: /*  tab stop set at active position */
              scr_set_tab (1);
              break; /* = ESC H */
              /* case 1: */ /* line tab stop set at active line */
//CMNT: c_keyword ^|                   case 2: /* char tab stop cleared at active position */
            case 2: /*  tab stop cleared at active position */
              scr_set_tab (0);
              break; /* = ESC [ 0 g */
              /* case 3: */ /* line tab stop cleared at active line */
//CMNT: c_keyword ^|                     /* case 4: */ /* char tab stops cleared at active line */
              /* case 4: */ /*  tab stops cleared at active line */
//CMNT: c_keyword ^|                   case 5: /* all char tab stops are cleared */
            case 5: /* all  tab stops are cleared */
              scr_set_tab (-1);
              break; /* = ESC [ 3 g */
              /* case 6: */ /* all line tab stops are cleared */
          }
        break;

      case CSI_RM: /* 8.3.107: RESET MODE */
        if (arg[0] == 4)
          scr_insert_mode (0);
        else if (arg[0] == 20)
          priv_modes &= ~(1UL<<19);
        break;

      case CSI_SM: /* 8.3.126: SET MODE */
        if (arg[0] == 4)
          scr_insert_mode (1);
        else if (arg[0] == 20)
          priv_modes |= (1UL<<19);
        break;

        /*
//CMNT: c_keyword possible_pointer ^|                * PRIVATE USE beyond this point.  All CSI_7? sequences here
            PRIVATE USE beyond this po.  All CSI_7? sequences here
         */
      case CSI_72: /* DECSTBM: set top and bottom margins */
        if (nargs == 1)
          scr_scroll_region (arg[0] - 1, 10000 - 1);
        else if (nargs == 0 || arg[0] >= arg[1])
          scr_scroll_region (0, 10000 - 1);
        else
          scr_scroll_region (arg[0] - 1, arg[1] - 1);
        break;

      case CSI_73:
        scr_cursor (SAVE);
        break;
      case CSI_75:
        scr_cursor (RESTORE);
        break;







      case CSI_78: /* DECREQTPARM */
        if (arg[0] == 0 || arg[0] == 1)
//CMNT: c_keyword ^|                 tt_printf ("\033[%d;1;1;128;128;1;0x", arg[0] + 2);
          tt_prf ("\033[%d;1;1;128;128;1;0x", arg[0] + 2);
        break;

      default:
        break;
    }
}
/*}}} */
      //     # 3171 "command.C"
/*----------------------------------------------------------------------*/
/*
//CMNT: possible_pointer ^|        * get input up until STRING TERMINATOR (or BEL)
    get input up until STRING TERMINATOR (or BEL)
//CMNT: possible_pointer ^|        * ends_how is terminator used. returned input must be free()'d
    ends_how is terminator used. returned input must be free()'d
 */
//CMNT: c_keyword ^|       char *
 *
//CMNT: js_style_functions c_keyword ^|       rxvt_term::get_to_st (unicode_t &ends_how){
rxvt_term.get_to_st =function(&ends_how){
//CMNT: c_keyword ^|         unicode_t ch;
  ch;
  bool seen_esc = false;
//CMNT: c_keyword ^|         unsigned int n = 0;
    n = 0;
//CMNT: c_keyword ^|         wchar_t string[2048 /* max string size for process_rxvt_xterm_seq() */];
   string[2048 /* max string size for process_rxvt_xterm_seq() */];

  while ((ch = cmd_getc ()) != NOCHAR){
      if (seen_esc){
          if (ch == 0x5c) /* 7bit ST */
            break;
          else
            return __null;
        }
      else if (ch == C0_ESC){
          seen_esc = true;
          continue;
        }
      else if (ch == C0_BEL || ch == 0x9c /* 0234 */)
        break;
      else if (ch == C0_SYN)
        ch = cmd_get8 ();
      else if (ch < 0x20)
//CMNT: c_keyword ^|               return __null; /* other control character - exit */
        return __null; /* other control acter - exit */

      seen_esc = false;

      if (n >= 2048 /* max string size for process_rxvt_xterm_seq() */ - 1)
        // stop at some sane length
        return __null;

      string[n++] = ch;
    }

  string[n++] = '\0';

  ends_how = (ch == 0x5c ? C0_ESC : ch);

  return rxvt_wcstombs (string);
}

/*----------------------------------------------------------------------*/
/*
//CMNT: possible_pointer ^|        * process DEVICE CONTROL STRING `ESC P ... (ST|BEL)' or `0x90 ... (ST|BEL)'
    process DEVICE CONTROL STRING `ESC P ... (ST|BEL)' or `0x90 ... (ST|BEL)'
 */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_dcs_seq (){
rxvt_term.process_dcs_seq =function(){
//CMNT: c_keyword possible_pointer ^|         char *s;
    s ;
//CMNT: c_keyword ^|         unicode_t eh;
  eh;

  /*
//CMNT: possible_pointer ^|          * Not handled yet
      Not handled yet
   */
  s = get_to_st (eh);
  if (s)
    free (s);

  return;
}

/*----------------------------------------------------------------------*/
/*
//CMNT: possible_pointer ^|        * process OPERATING SYSTEM COMMAND sequence `ESC ] Ps ; Pt (ST|BEL)'
    process OPERATING SYSTEM COMMAND sequence `ESC ] Ps ; Pt (ST|BEL)'
 */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_osc_seq (){
rxvt_term.process_osc_seq =function(){
//CMNT: c_keyword ^|         unicode_t ch, eh;
  ch, eh;
//CMNT: c_keyword ^|         int arg;
   arg;

  ch = cmd_getc ();
  for (arg = 0; isdigit (ch); ch = cmd_getc ())
//CMNT: possible_pointer ^|           arg = arg * 10 + (ch - '0');
    arg = arg    10 + (ch - '0');

  if (ch == ';'){
//CMNT: js_style_variables possible_pointer ^|             char *s = get_to_st (eh);
 var s= get_to_st (eh);

      if (s){
          process_xterm_seq (arg, s, eh);
          free (s);
        }
    }
}

//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::process_color_seq (int report, int color, const char *str, char resp){
rxvt_term.process_color_seq =function( report,  color,    s tr,  resp){
  if (str[0] == '?' && !str[1]){
      rgba c;
      pix_colors_focused[color].get (c);






//CMNT: c_keyword ^|               tt_printf ("\033]%d;rgb:%04x/%04x/%04x%c", report, c.r, c.g, c.b, resp);
        tt_prf ("\033]%d;rgb:%04x/%04x/%04x%c", report, c.r, c.g, c.b, resp);
    }
  else
    set_window_color (color, str);
}

/*
//CMNT: possible_pointer ^|        * XTerm escape sequences: ESC ] Ps;Pt (ST|BEL)
    XTerm escape sequences: ESC ] Ps;Pt (ST|BEL)
 */
//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::process_xterm_seq (int op, const char *str, char resp){
rxvt_term.process_xterm_seq =function( op,    s tr,  resp){
//CMNT: c_keyword ^|         int color;
   color;
//CMNT: c_keyword possible_pointer ^|         char *buf, *name;
    b uf,  n ame;
  bool query = str[0] == '?' && !str[1];
//CMNT: js_style_variables ^|         int saveop = op;
 var saveop= op;

//CMNT: c_keyword possible_pointer ^|         Display * const dpy = this->dpy;
  Display     dpy = this->dpy;

//CMNT: remove_casts ^|         (__builtin_expect(!(str != __null), 0) ? __assert_rtn(__func__, "command.C", 3299, "str != NULL") : (void)0);
  (__builtin_expect(!(str != __null), 0) ? __assert_rtn(__func__, "command.C", 3299, "str != NULL") : 0);

  if (false)
    return;

  switch (op){
      case XTerm_name:
        set_title (str);
        /* FALLTHROUGH */
      case XTerm_iconName:
        set_icon_name (str);
        break;
      case XTerm_title:
        set_title (str);
        break;
      case XTerm_property:
        if (str[0] == '?'){
            Atom prop = display->atom (str + 1);
            Atom actual_type;
//CMNT: c_keyword ^|                   int actual_format;
             actual_format;
//CMNT: c_keyword ^|                   unsigned long nitems;
             long nitems;
//CMNT: c_keyword ^|                   unsigned long bytes_after;
             long bytes_after;
//CMNT: c_keyword possible_pointer ^|                   unsigned char *value = 0;
               v alue = 0;
//CMNT: c_keyword possible_pointer ^|                   const char *str = "";
               s tr = "";

            if (prop
                && XGetWindowProperty (dpy, parent[0],
                                       prop, 0, 1<<16, 0, 0L /* special Atom, passed to GetProperty */,
                                       &actual_type, &actual_format,
                                       &nitems, &bytes_after, &value) == 0 /* everything's okay */
                && actual_type != 0L /* universal null resource or null atom */
                && actual_format == 8)
//CMNT: c_keyword possible_pointer ^|                     str = (const char *)(value);
              str = (   ) (value);

//CMNT: c_keyword ^|                   tt_printf ("\033]%d;%s%c", op, str, resp);
            tt_prf ("\033]%d;%s%c", op, str, resp);

            XFree (value);
          }
        else{
//CMNT: c_keyword possible_pointer ^|                   char *eq = strchr (str, '='); // constness lost, but verified to be ok
              e q = strchr (str, '='); // ness lost, but verified to be ok

            if (eq){
//CMNT: possible_pointer ^|                       *eq = 0;
                 e q = 0;
                set_utf8_property (display->atom (str), eq + 1);
              }
            else
              XDeleteProperty (dpy, parent[0],
                               display->atom (str));
          }
        break;

      case XTerm_Color:
//CMNT: c_keyword possible_pointer ^|               for (buf = (char *)str; buf && *buf;){
        for (buf = (  ) str; buf &&  b uf;){
            if ((name = strchr (buf, ';')) == __null)
              break;

//CMNT: possible_pointer ^|                   *name++ = '\0';
             n ame++ = '\0';
            color = atoi (buf) + minCOLOR;

//CMNT: c_keyword ^|                   if (!((unsigned int)(color) - (unsigned int)(minCOLOR) <= (unsigned int)(maxTermCOLOR) - (unsigned int)(minCOLOR)))
            if (!(( )(color) - ( )(minCOLOR) <= ( )(maxTermCOLOR) - ( )(minCOLOR)))
              break;

            if ((buf = strchr (name, ';')) != __null)
//CMNT: possible_pointer ^|                     *buf++ = '\0';
               b uf++ = '\0';

            process_color_seq (op, color, name, resp);
          }
        break;
      case Rxvt_restoreFG:
      case XTerm_Color00:
        process_color_seq (op, Color_fg, str, resp);
        break;
      case Rxvt_restoreBG:
      case XTerm_Color01:
        process_color_seq (op, Color_bg, str, resp);
        break;

      case XTerm_Color_cursor:
        process_color_seq (op, Color_cursor, str, resp);
        break;

//CMNT: c_keyword ^|             case XTerm_Color_pointer_fg:
      case XTerm_Color_poer_fg:
//CMNT: c_keyword ^|               process_color_seq (op, Color_pointer_fg, str, resp);
        process_color_seq (op, Color_poer_fg, str, resp);
        break;
//CMNT: c_keyword ^|             case XTerm_Color_pointer_bg:
      case XTerm_Color_poer_bg:
//CMNT: c_keyword ^|               process_color_seq (op, Color_pointer_bg, str, resp);
        process_color_seq (op, Color_poer_bg, str, resp);
        break;

      case XTerm_Color_RV:
        process_color_seq (op, Color_RV, str, resp);
        break;
      case Rxvt_Color_BD:
      case URxvt_Color_BD:
        process_color_seq (op, Color_BD, str, resp);
        break;
      case Rxvt_Color_UL:
      case URxvt_Color_UL:
        process_color_seq (op, Color_UL, str, resp);
        break;
      case URxvt_Color_IT:
        process_color_seq (op, Color_IT, str, resp);
        break;

      case URxvt_Color_border:
        process_color_seq (op, Color_border, str, resp);
        break;
      //     # 3468 "command.C"
      case XTerm_logfile:
        // TODO, when secure mode?
        break;
      //     # 3484 "command.C"
      case XTerm_font:
        op = URxvt_font;
      case URxvt_font:





        if (query)
//CMNT: c_keyword ^|                 tt_printf ("\33]%d;%-.250s%c", saveop,
          tt_prf ("\33]%d;%-.250s%c", saveop,
                     option (Opt_insecure) && fontset[op - URxvt_font]->fontdesc
                       ? fontset[op - URxvt_font]->fontdesc : "",
                     resp);
        else{
//CMNT: c_keyword possible_pointer ^|                   const char *&res = rs[Rs_font + (op - URxvt_font)];
               & res = rs[Rs_font + (op - URxvt_font)];

            res = strdup (str);
//CMNT: c_keyword possible_pointer ^|                   allocated.push_back ((void *)res);
            allocated.push_back ((  ) res);
            set_fonts ();
          }
        break;

      case URxvt_version:
        if (query)
//CMNT: c_keyword ^|                 tt_printf ("\33]%d;rxvt-unicode;%-.20s;%c;%c%c",
          tt_prf ("\33]%d;rxvt-unicode;%-.20s;%c;%c%c",
                     op,
                     rs[Rs_name], "9.06"[0], "9.06"[2],
                     resp);
        break;
      //     # 3546 "command.C"
    }
}
/*----------------------------------------------------------------------*/

/*{{{ process DEC private mode sequences `ESC [ ? Ps mode' */
/*
//CMNT: possible_pointer ^|        * mode can only have the following values:
    mode can only have the following values:
//CMNT: possible_pointer ^|        *      'l' = low
         'l' = low
//CMNT: possible_pointer ^|        *      'h' = high
         'h' = high
//CMNT: possible_pointer ^|        *      's' = save
         's' = save
//CMNT: possible_pointer ^|        *      'r' = restore
         'r' = restore
//CMNT: possible_pointer ^|        *      't' = toggle
         't' = toggle
//CMNT: possible_pointer ^|        * so no need for fancy checking
    so no need for fancy checking
 */
//CMNT: js_style_functions c_keyword ^|       int rxvt_term::privcases (int mode, unsigned long bit){
rxvt_term.privcases =function( mode,  long bit){
//CMNT: c_keyword ^|         int state;
   state;

  if (mode == 's'){
      SavedModes |= (priv_modes & bit);
      return -1;
    }
  else{
      if (mode == 'r')
        state = (SavedModes & bit) ? 1 : 0; /* no overlapping */
      else
        state = (mode == 't') ? ! (priv_modes & bit) : mode;
      set_privmode (bit, state);
    }

  return state;
}

/* we're not using priv _yet_ */
//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::process_terminal_mode (int mode, int priv __attribute__((unused)), unsigned int nargs, const int *arg){
rxvt_term.process_terminal_mode =function( mode,  priv __attribute__((unused)),   nargs,    a rg){
//CMNT: c_keyword ^|         unsigned int i, j;
    i, j;
//CMNT: c_keyword ^|         int state;
   state;

//CMNT: c_keyword ^|         static const struct
    struct
  {
//CMNT: c_keyword ^|           const int argval;
      argval;
//CMNT: c_keyword ^|           const unsigned long bit;
      long bit;
  } argtopriv[] = {
                  { 1, (1UL<<6) }, // DECCKM
                  { 2, (1UL<<18) },
                  { 3, (1UL<<0) }, // DECCOLM
                  { 4, (1UL<<17) }, // DECSCLM
                  { 5, (1UL<<2) }, // DECSCNM
                  { 6, (1UL<<3) }, // DECOM
                  { 7, (1UL<<5) }, // DECAWM
                 // 8, auto-repeat keys         // DECARM
                  { 9, (1UL<<12) },
//CMNT: c_keyword ^|                        // 18 end FF to printer after print screen
                 // 18 end FF to prer after pr screen
//CMNT: c_keyword ^|                        // 19 Print screen prints full screen/scorll region
                 // 19 Pr screen prs full screen/scorll region
                  { 25, (1UL<<11) }, // cnorm/cvvis/civis

                  { 30, (1UL<<14) },

                  { 35, (1UL<<10) }, // rxvt extension
                 // 38, tektronix mode          // DECTEK
                  { 40, (1UL<<1) },
                 // 41 xterm more fixes NYI
                 // 45 margin bell NYI
                 // 46 start logging
                  { 47, (1UL<<4) },
                  { 66, (1UL<<7) }, // DECPAM/DECPNM



                  { 1000, (1UL<<13) },
                  { 1002, (1UL<<20) },
                  { 1003, (1UL<<21) },
                  { 1010, (1UL<<15) }, // rxvt extension
                  { 1011, (1UL<<16) }, // rxvt extension
                 // 1035 enable modifiers for alt, numlock NYI
                 // 1036 send ESC for meta keys NYI
                 // 1037 send DEL for keypad delete NYI
                  { 1047, (1UL<<4) },
                 // 1048 save and restore cursor
                  { 1049, (1UL<<4) }, /* xterm extension, clear screen on ti rather than te */
                 // 1051, 1052, 1060, 1061 keyboard emulation NYI
                  { 2004, (1UL<<22) },
                };

  if (nargs == 0)
    return;

  /* make lo/hi boolean */
  if (mode == 'l')
    mode = 0; /* reset */
  else if (mode == 'h')
    mode = 1; /* set */

  for (i = 0; i < nargs; i++){
      state = -1;

      /* basic handling */
      for (j = 0; j < (sizeof (argtopriv)/sizeof (argtopriv[0])); j++)
        if (argtopriv[j].argval == arg[i]){
            state = privcases (mode, argtopriv[j].bit);
            break;
          }

      /* extra handling for values with state unkept  */
      switch (arg[i]){







          case 1048: /* alternative cursor save */
            if (option (Opt_secondaryScreen))
              if (mode == 0)
                scr_cursor (RESTORE);
              else if (mode == 1)
                scr_cursor (SAVE);
            break;
        }

      if (state >= 0)
        /* extra handling for values with valid 0 or 1 state */
        switch (arg[i]){
              /* case 1:	- application cursor keys */
            case 2: /* VT52 mode */
              /* oddball mode.  should be set regardless of set/reset
//CMNT: possible_pointer ^|                      * parameter.  Return from VT52 mode with an ESC < from
                  parameter.  Return from VT52 mode with an ESC < from
//CMNT: possible_pointer ^|                      * within VT52 mode
                  within VT52 mode
               */
              set_privmode ((1UL<<18), 1);
              break;
            case 3: /* 80/132 */
              if (priv_modes & (1UL<<1))
//CMNT: possible_pointer ^|                       set_widthheight ((state ? 132 : 80) * fwidth, 24 * fheight);
                set_widthheight ((state ? 132 : 80)    fwidth, 24    fheight);
              break;
            case 4: /* smooth scrolling */
              set_option (Opt_jumpScroll, !state);
              break;
            case 5: /* reverse video */
              scr_rvideo_mode (state);
              break;
            case 6: /* relative/absolute origins  */
              scr_relative_origin (state);
              break;
            case 7: /* autowrap */
              scr_autowrap (state);
              break;
            /* case 8:	- auto repeat, can't do on a per window basis */
            case 9: /* X10 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<13)|(1UL<<20)|(1UL<<21));
              break;

            case 30:
              if (scrollBar.map (state)){
                  resize_all_windows (0, 0, 0);
                  scr_touch (true);
                }
              break;

            case 25: /* visible/invisible cursor */
              scr_cursor_visible (state);
              break;
            /* case 35:	- shift keys */
            /* case 40:	- 80 <--> 132 mode */
            case 47: /* secondary screen */
              scr_change_screen (state);
              break;
            /* case 66:	- application key pad */
            /* case 67:	- backspace key */
            case 1000: /* X11 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<12)|(1UL<<20)|(1UL<<21));
              break;
            case 1002:
            case 1003:
              if (state){
                  priv_modes &= ~((1UL<<12)|(1UL<<13));
                  priv_modes &= arg[i] == 1003 ? ~(1UL<<20) : ~(1UL<<21);
                  vt_emask_mouse = (1L<<6);
                }
              else
                vt_emask_mouse = 0L;

              vt_select_input ();
              break;
            case 1010: /* scroll to bottom on TTY output inhibit */
              set_option (Opt_scrollTtyOutput, !state);
              break;
            case 1011: /* scroll to bottom on key press */
              set_option (Opt_scrollTtyKeypress, state);
              break;
            case 1047: /* secondary screen w/ clearing last */
              if (option (Opt_secondaryScreen))
                if (!state)
                  scr_erase_screen (2);

              scr_change_screen (state);
              break;
            case 1049: /* secondary screen w/ clearing first */
              if (option (Opt_secondaryScreen))
                if (state)
                  scr_cursor (SAVE);

              scr_change_screen (state);

              if (option (Opt_secondaryScreen))
                if (state)
                  scr_erase_screen (2);
                else
                  scr_cursor (RESTORE);
              break;
            default:
              break;
          }
    }
}
/*}}} */

/*{{{ process sgr sequences */
//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::process_sgr_mode (unsigned int nargs, const int *arg){
rxvt_term.process_sgr_mode =function(  nargs,    a rg){
//CMNT: c_keyword ^|         unsigned int i;
    i;
//CMNT: c_keyword ^|         short rendset;
   rendset;
//CMNT: c_keyword ^|         int rendstyle;
   rendstyle;

  if (nargs == 0){
      scr_rendition (0, ~0);
      return;
    }

  for (i = 0; i < nargs; i++){
      rendset = -1;
      switch (arg[i]){
          case 0:
            rendset = 0, rendstyle = ~0;
            break;
          case 1:
            rendset = 1, rendstyle = 0x00004000UL /* value 1*/;
            break;
//CMNT: c_keyword ^|                 //case 2: // low intensity
          //case 2: // low ensity
          case 3:
            rendset = 1, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 4:
            rendset = 1, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 5: // slowly blinking
          case 6: // rapidly blinking
            rendset = 1, rendstyle = 0x00010000UL /* blink*/;
            break;
          //case 6: // scoansi light background
          case 7:
            rendset = 1, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          case 8:
            // invisible. NYI
            break;
          //case 9: // crossed out
          //case 10: // scoansi acs off, primary font
          //case 11: // scoansi acs on, first alt font
          //case 12: // scoansi acs on, |0x80, second alt font
          //...
//CMNT: c_keyword ^|                 //case 19: // ninth alt font
          //case 19: // nh alt font
          //case 20: // gothic
//CMNT: c_keyword ^|                 case 21: // disable bold, faint, sometimes doubly underlined (iso 8613)
          case 21: // disable bold, fa, sometimes doubly underlined (iso 8613)
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
//CMNT: c_keyword ^|                 case 22: // normal intensity
          case 22: // normal ensity
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
          case 23: // disable italic
            rendset = 0, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 24:
            rendset = 0, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 25:
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 26: // variable spacing (iso 8613)
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 27:
            rendset = 0, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          //case 28: // visible. NYI
          //case 29: // not crossed-out
        }

      if (rendset != -1){
          scr_rendition (rendset, rendstyle);
          continue; /* for (;i;) */
        }

      switch (arg[i]){
          case 30:
          case 31: /* set fg color */
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
//CMNT: c_keyword ^|                   scr_color ((unsigned int) (minCOLOR + (arg[i] - 30)), Color_fg);
            scr_color (( ) (minCOLOR + (arg[i] - 30)), Color_fg);
            break;
          case 38: // set fg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5){
//CMNT: c_keyword ^|                       scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_fg);
                scr_color (( ) (minCOLOR + arg[i + 2]), Color_fg);
                i += 2;
              }
            break;
          case 39: /* default fg */
            scr_color (Color_fg, Color_fg);
            break;

          case 40:
          case 41: /* set bg color */
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
//CMNT: c_keyword ^|                   scr_color ((unsigned int) (minCOLOR + (arg[i] - 40)), Color_bg);
            scr_color (( ) (minCOLOR + (arg[i] - 40)), Color_bg);
            break;
          case 48: // set bg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5){
//CMNT: c_keyword ^|                       scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_bg);
                scr_color (( ) (minCOLOR + arg[i + 2]), Color_bg);
                i += 2;
              }
            break;
          case 49: /* default bg */
            scr_color (Color_bg, Color_bg);
            break;

          //case 50: // not variable spacing
      //     # 3926 "command.C"
        }
    }
}
/*}}} */

/*{{{ (do not) process Rob Nation's own graphics mode sequences */
//CMNT: js_style_functions c_keyword ^|       void rxvt_term::process_graphics (){
rxvt_term.process_graphics =function(){
//CMNT: c_keyword ^|         unicode_t ch, cmd = cmd_getc ();
  ch, cmd = cmd_getc ();

  if (cmd == 'Q'){
      /* query graphics */
//CMNT: c_keyword ^|             tt_printf ("\033G0\012"); /* no graphics */
      tt_prf ("\033G0\012"); /* no graphics */
      return;
    }
  /* swallow other graphics sequences until terminating ':' */
  do
    ch = cmd_getc ();
  while (ch != ':');
}
/*}}} */

/* ------------------------------------------------------------------------- */

/*
//CMNT: c_keyword possible_pointer ^|        * Send printf () formatted output to the command.
    Send prf () formatted output to the command.
//CMNT: possible_pointer ^|        * Only use for small amounts of data.
    Only use for small amounts of data.
 */
//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::tt_printf (const char *fmt,...){
rxvt_term.tt_prf =function(   f mt,...){
  va_list arg_ptr;
//CMNT: c_keyword ^|         char buf[256];
   buf[256];

  __builtin_va_start(arg_ptr,fmt);
//CMNT: c_keyword possible_pointer ^|         vsnprintf ((char *)buf, 256, fmt, arg_ptr);
  vsnprf ((  ) buf, 256, fmt, arg_ptr);
  __builtin_va_end(arg_ptr);
  tt_write (buf, (strlen)(buf));
}

/* ---------------------------------------------------------------------- */
/* Write data to the pty as typed by the user, pasted with the mouse,
//CMNT: possible_pointer ^|        * or generated by us in response to a query ESC sequence.
    or generated by us in response to a query ESC sequence.
 */
//CMNT: c_keyword ^|       const unsigned int MAX_PTY_WRITE = 255; // minimum MAX_INPUT
   MAX_PTY_WRITE = 255; // minimum MAX_INPUT

//CMNT: js_style_functions c_keyword possible_pointer ^|       void rxvt_term::tt_write (const char *data, unsigned int len){
rxvt_term.tt_write =function(   d ata,   len){
  if (false)
    return;

  if (pty->pty < 0)
    return;

  if (v_buflen == 0){
      ssize_t written = write (pty->pty, data, min (len, MAX_PTY_WRITE));

//CMNT: c_keyword ^|             if ((unsigned int)written == len)
      if (( )written == len)
        return;

      data += written;
      len -= written;
    }

//CMNT: c_keyword possible_pointer ^|         v_buffer = (char *)realloc (v_buffer, v_buflen + len);
  v_buffer = (  ) realloc (v_buffer, v_buflen + len);

  (memcpy)(v_buffer + v_buflen,data,len);
  v_buflen += len;

  pty_ev.set (ev::READ | ev::WRITE);
}

//CMNT: js_style_functions c_keyword ^|       void rxvt_term::pty_write (){
rxvt_term.pty_write =function(){
//CMNT: js_style_variables ^|         int written = write (pty->pty, v_buffer, min (v_buflen, MAX_PTY_WRITE));
 var written= write (pty->pty, v_buffer, min (v_buflen, MAX_PTY_WRITE));

  if (written > 0){
      v_buflen -= written;

      if (v_buflen == 0){
          free (v_buffer);
          v_buffer = 0;

          pty_ev.set (ev::READ);
          return;
        }

      memmove (v_buffer, v_buffer + written, v_buflen);
    }
//CMNT: possible_pointer ^|         else if (written != -1 || ((*__error()) != 35 /* Resource temporarily unavailable */ && (*__error()) != 4 /* Interrupted system call */))
  else if (written != -1 || (( _ _error()) != 35 /* Resource temporarily unavailable */ && ( _ _error()) != 4 /* Interrupted system call */))
    pty_ev.set (ev::READ);
}

/*----------------------- end-of-file (C source) -----------------------*/