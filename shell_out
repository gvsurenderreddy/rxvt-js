bash-3.2$ cd _code_qr/trunk3/trunkspacer/manageServer/conf/resinconf/
bash-3.2$ ls
__init__.py		app-default.xml		development.conf	generator		nohup.out		resin-admin.xml		resin-debug.conf~	resin.conf		templates
__init__.pyc		conf_generated		fine.conf		minimal.conf		password.xml		resin-debug.conf	resin-default.conf	resin.conf~
bash-3.2$ ls resin*
resin-admin.xml		resin-debug.conf	resin-debug.conf~	resin-default.conf	resin.conf		resin.conf~
bash-3.2$ ls resin*conf
resin-debug.conf	resin-default.conf	resin.conf
bash-3.2$ rm resin*conf
bash-3.2$ ls
__init__.py		__init__.pyc		app-default.xml		conf_generated		development.conf	fine.conf		generator		minimal.conf		nohup.out		password.xml		resin-admin.xml		resin-debug.conf~	resin.conf~		templates
bash-3.2$ ls *~
resin-debug.conf~	resin.conf~
bash-3.2$ rm *~
bash-3.2$ cd ..
bash-3.2$ ls
homedotfiles	resinconf
bash-3.2$ cd ..
bash-3.2$ ls
conf	scripts
bash-3.2$ svn add conf
A         conf
A         conf/homedotfiles
A         conf/homedotfiles/.bash_profile
A         conf/homedotfiles/.bashrc
A         conf/homedotfiles/.lesshst
A         conf/homedotfiles/.profile
A         conf/homedotfiles/.screenrc
A         conf/homedotfiles/dotfiles
A         conf/homedotfiles/dotfiles/.bash_history
A         conf/homedotfiles/dotfiles/.bash_profile
A         conf/homedotfiles/dotfiles/.bashrc
A         conf/homedotfiles/dotfiles/.lesshst
A         conf/homedotfiles/dotfiles/.mysql_history
A         conf/homedotfiles/dotfiles/.profile
A         conf/homedotfiles/dotfiles/.screenrc
A         conf/resinconf
A         conf/resinconf/__init__.py
A         conf/resinconf/app-default.xml
A         conf/resinconf/conf_generated
A         conf/resinconf/conf_generated/debug-resin.conf.tmpl.xml
A         conf/resinconf/conf_generated/production-resin.conf.tmpl.xml
A         conf/resinconf/development.conf
A         conf/resinconf/fine.conf
A         conf/resinconf/generator
A         conf/resinconf/generator/__init__.py
A         conf/resinconf/generator/settings.py
A         conf/resinconf/generator/template_runner.py
A         conf/resinconf/minimal.conf
A         conf/resinconf/nohup.out
A         conf/resinconf/password.xml
A         conf/resinconf/resin-admin.xml
A         conf/resinconf/templates
A         conf/resinconf/templates/base
A         conf/resinconf/templates/base/base-resin-conf-tmpl.xml
A         conf/resinconf/templates/final
A         conf/resinconf/templates/final/debug-resin.conf.tmpl.xml
A         conf/resinconf/templates/final/production-resin.conf.tmpl.xml
bash-3.2$ svn ci -m " work for resin conf templates "
Adding         manageServer/conf
Adding         manageServer/conf/homedotfiles
Adding         manageServer/conf/homedotfiles/.bash_profile
Adding         manageServer/conf/homedotfiles/.bashrc
Adding         manageServer/conf/homedotfiles/.lesshst
Adding         manageServer/conf/homedotfiles/.profile
Adding         manageServer/conf/homedotfiles/.screenrc
Adding         manageServer/conf/homedotfiles/dotfiles
Adding         manageServer/conf/homedotfiles/dotfiles/.bash_history
Adding         manageServer/conf/homedotfiles/dotfiles/.bash_profile
Adding         manageServer/conf/homedotfiles/dotfiles/.bashrc
Adding         manageServer/conf/homedotfiles/dotfiles/.lesshst
Adding         manageServer/conf/homedotfiles/dotfiles/.mysql_history
Adding         manageServer/conf/homedotfiles/dotfiles/.profile
Adding         manageServer/conf/homedotfiles/dotfiles/.screenrc
Adding         manageServer/conf/resinconf
Adding         manageServer/conf/resinconf/__init__.py
Adding         manageServer/conf/resinconf/app-default.xml
Adding         manageServer/conf/resinconf/conf_generated
Adding         manageServer/conf/resinconf/conf_generated/debug-resin.conf.tmpl.xml
Adding         manageServer/conf/resinconf/conf_generated/production-resin.conf.tmpl.xml
Adding         manageServer/conf/resinconf/development.conf
Adding         manageServer/conf/resinconf/fine.conf
Adding         manageServer/conf/resinconf/generator
Adding         manageServer/conf/resinconf/generator/__init__.py
Adding         manageServer/conf/resinconf/generator/settings.py
Adding         manageServer/conf/resinconf/generator/template_runner.py
Adding         manageServer/conf/resinconf/minimal.conf
Adding         manageServer/conf/resinconf/nohup.out
Adding         manageServer/conf/resinconf/password.xml
Adding         manageServer/conf/resinconf/resin-admin.xml
Adding         manageServer/conf/resinconf/templates
Adding         manageServer/conf/resinconf/templates/base
Adding         manageServer/conf/resinconf/templates/base/base-resin-conf-tmpl.xml
Adding         manageServer/conf/resinconf/templates/final
Adding         manageServer/conf/resinconf/templates/final/debug-resin.conf.tmpl.xml
Adding         manageServer/conf/resinconf/templates/final/production-resin.conf.tmpl.xml
Transmitting file data ............................
Committed revision 1066.
bash-3.2$ pwd
/Users/patrickmullen/_code_qr/trunk3/trunkspacer/manageServer
bash-3.2$ cd ~/delete/idcdata/ftpprod.intdata.com/QUANTRUNFTPH1/
bash-3.2$ ls
#shortqprc1#	qchg1.fil.Z	qdesc1.fil.Z	qprc1.fil	qprc10.fil.Z	qprc12.fil.Z	qprc14.fil.Z	qprc16.fil.Z	qprc18.fil.Z	qprc2.fil.Z	qprc21.fil.Z	qprc23.fil.Z	qprc25.fil.Z	qprc27.fil.Z	qprc29.fil.Z	qprc30.fil.Z	qprc32.fil.Z	qprc34.fil.Z	qprc5.fil.Z	qprc7.fil.Z	qprc9.fil.Z	shortqprc1
qchg1.fil	qdesc1.fil	qdiv1.fil.Z	qprc1.fil.Z	qprc11.fil.Z	qprc13.fil.Z	qprc15.fil.Z	qprc17.fil.Z	qprc19.fil.Z	qprc20.fil.Z	qprc22.fil.Z	qprc24.fil.Z	qprc26.fil.Z	qprc28.fil.Z	qprc3.fil.Z	qprc31.fil.Z	qprc33.fil.Z	qprc4.fil.Z	qprc6.fil.Z	qprc8.fil.Z	shortqchg1.fil	test.txt
bash-3.2$ du -h qdesc1.fil
5.6M	qdesc1.fil
bash-3.2$ pwd
/Users/patrickmullen/delete/idcdata/ftpprod.intdata.com/QUANTRUNFTPH1
bash-3.2$ popd
bash: popd: directory stack empty
bash-3.2$ cd ~/_code_qr/import/branches/081122/pyBase/qr/importer/idc/
bash-3.2$ cat ongoing_description.txt 
11/08  320/216 Record Formats  135 
1-68 x(80) Identification Data: 
1-8 x(8) CUSIP Number/User Number 
9 x Uniqueness Code: blank, 1 
10 x Exchange Code 
 
11-16 x(6) Ticker Symbol 
17-20 x(4) SIC Code 
21-48 x(28) Issuer Description 
49-68 x(20) Issue Description 
69-107 Pricing Data: 
69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-79 9(7) Volume 
80-86 9(4)v9(3) High/Ask 
87-93 9(4)v9(3) Low/Bid 
94-100 9(4)v9(3) Current Price/Evaluation 
101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132 Indicators Data: 
108-111 x(4) Status/Type Flag 
108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109 x Trade Type Code: 0-5, 8, 9, H, Z 
110 x Issue Status Code 
111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119 x(8) Expiration Date (mmddccyy) 
120-125 9(2)v9(4) Adjustment Factor 
126 x Margin/Eligibility Code 
127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152 Earnings For Equities/Indices Data: 
133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139 9(2)v9(3) Earnings Per Share - Basic 
140 x Earnings Indicator - Basic 
141-147 9(7) Shares Outstanding 
148 9 Indicated Annual Dividend (IAD) Modifier 
149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184 First Dividend Data: 
153-158 9(2)v9(4) Dividend Amount/Rate 
159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170 9(6) Record Date (mmddyy) 
171-176 9(6) Payment Date (mmddyy) 
177 x Payment Type Code 
178 x Payment Order/Scaling Factor 
179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180 9 Revision/Late Code 
181 9 Payment Frequency Code 
182 x Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183 x Revision Indicator 
184 9 Announcement Entry Code 
185-216 Second Dividend Data: 
185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196 9(6) 
Record Date (mmddyy) 
197-202 9(6) 
Payment Date (mmddyy) 
203-208 9(6) 
209 x Payment Type Code 
210 x Payment Order/Scaling Factor Code 
211 x Tax Base Code 
212 9 Revision/Late Code 
213 9 Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214 x Reserved for future development 
215 x Revision Indicator 
216 9 Announcement Entry Code 
217-320 For 320 Service: 
217-223 9(4)v9(3) Bid 
224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132 
243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260 x(4) 
261 x Rule 144A Flag 
262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272  9(2)v9(3) Earnings Per Share - Diluted  
273 x Earnings Indicator - Diluted 
274-279 x(6) NAICS Code 
280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292 x(3) Currency Code - First Dividend Data  
136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295 x(3) Currency Code - Second Dividend Data  
296-308 x(13) Reserved for future development  
309 x Moody's Quality Rating 
310 x Quote Source Code 
311 x CUSIP Check Digit 
312-314 x(3) Supplemental Issue Type Code 
315 x Shares Outstanding Indicator 
316-319 x(4) Reserved for internal use 
320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^0-9]*\):                \1:'
                11/08  320/216 Record Formats  135 
                1-68 x(80) Identification Data: 
                1-8 x(8) CUSIP Number/User Number 
                9 x Uniqueness Code: blank, 1 
                10 x Exchange Code 
                 
                11-16 x(6) Ticker Symbol 
                17-20 x(4) SIC Code 
                21-48 x(28) Issuer Description 
                49-68 x(20) Issue Description 
                69-107 Pricing Data: 
                69-72 9(4) Pricing/Evaluation Date (mmdd) 
                73-79 9(7) Volume 
                80-86 9(4)v9(3) High/Ask 
                87-93 9(4)v9(3) Low/Bid 
                94-100 9(4)v9(3) Current Price/Evaluation 
                101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
                108-132 Indicators Data: 
                108-111 x(4) Status/Type Flag 
                108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
                109 x Trade Type Code: 0-5, 8, 9, H, Z 
                110 x Issue Status Code 
                111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
                Rating Code 
                 For index records, pos. 112-126: Reserved for future development 
                112-119 x(8) Expiration Date (mmddccyy) 
                120-125 9(2)v9(4) Adjustment Factor 
                126 x Margin/Eligibility Code 
                127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
                 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
                133-152 Earnings For Equities/Indices Data: 
                133-134 9(2) Earnings Per Share Month - Basic (mm) 
                135-139 9(2)v9(3) Earnings Per Share - Basic 
                140 x Earnings Indicator - Basic 
                141-147 9(7) Shares Outstanding 
                148 9 Indicated Annual Dividend (IAD) Modifier 
                149-152 9v9(3) Indicated Annual Dividend (IAD) 
                153-184 First Dividend Data: 
                153-158 9(2)v9(4) Dividend Amount/Rate 
                159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
                165-170 9(6) Record Date (mmddyy) 
                171-176 9(6) Payment Date (mmddyy) 
                177 x Payment Type Code 
                178 x Payment Order/Scaling Factor 
                179 x Tax Base Code 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
                180 9 Revision/Late Code 
                181 9 Payment Frequency Code 
                182 x Liquidation/Return of Capital Flag  
                8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
                183 x Revision Indicator 
                184 9 Announcement Entry Code 
                185-216 Second Dividend Data: 
                185-190 9(2)v9(4) Dividend Amount/Rate 
                Ex-Distribution/Dividend Date (mmddyy) 
                191-196 9(6) 
                Record Date (mmddyy) 
                197-202 9(6) 
                Payment Date (mmddyy) 
                203-208 9(6) 
                209 x Payment Type Code 
                210 x Payment Order/Scaling Factor Code 
                211 x Tax Base Code 
                212 9 Revision/Late Code 
                213 9 Liquidation/Return of Capital Flag  
                8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
                214 x Reserved for future development 
                215 x Revision Indicator 
                216 9 Announcement Entry Code 
                217-320 For 320 Service: 
                217-223 9(4)v9(3) Bid 
                224-230 9(4)v9(3) Ask 
                Bid/Ask Pricing Date (ccyymmdd) 
                231-238 x(8) 
                Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
                239-242 x(4) 
                
                
                Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
                or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
                132 
                243-244 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
                First Dividend Data field)  
                245-246 x(2) 
                Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
                field)  
                247-248 x(2) 
                Century (cc) of Payment Date (positions 171-176 in First Dividend 
                Data field) 
                249-250 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
                Second Dividend Data field)  
                251-252 x(2) 
                Century (cc) of Record Date (positions 197-202 in Second 
                Dividend Data field)  
                253-254 x(2) 
                Century (cc) of Payment Date (positions 203-208 in Second 
                Dividend Data field) 
                255-256 x(2) 
                Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
                257-260 x(4) 
                261 x Rule 144A Flag 
                262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
                268-272  9(2)v9(3) Earnings Per Share - Diluted  
                273 x Earnings Indicator - Diluted 
                274-279 x(6) NAICS Code 
                280-284 x(5) Announcement Sequence Code - First Dividend Data  
                285-289 x(5) Announcement Sequence Code - Second Dividend Data  
                290-292 x(3) Currency Code - First Dividend Data  
                136  320/216 Record Formats  11/08 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
                293-295 x(3) Currency Code - Second Dividend Data  
                296-308 x(13) Reserved for future development  
                309 x Moody's Quality Rating 
                310 x Quote Source Code 
                311 x CUSIP Check Digit 
                312-314 x(3) Supplemental Issue Type Code 
                315 x Shares Outstanding Indicator 
                316-319 x(4) Reserved for internal use 
                320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt 
11/08  320/216 Record Formats  135 
1-68 x(80) Identification Data: 
1-8 x(8) CUSIP Number/User Number 
9 x Uniqueness Code: blank, 1 
10 x Exchange Code 
 
11-16 x(6) Ticker Symbol 
17-20 x(4) SIC Code 
21-48 x(28) Issuer Description 
49-68 x(20) Issue Description 
69-107 Pricing Data: 
69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-79 9(7) Volume 
80-86 9(4)v9(3) High/Ask 
87-93 9(4)v9(3) Low/Bid 
94-100 9(4)v9(3) Current Price/Evaluation 
101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132 Indicators Data: 
108-111 x(4) Status/Type Flag 
108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109 x Trade Type Code: 0-5, 8, 9, H, Z 
110 x Issue Status Code 
111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119 x(8) Expiration Date (mmddccyy) 
120-125 9(2)v9(4) Adjustment Factor 
126 x Margin/Eligibility Code 
127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152 Earnings For Equities/Indices Data: 
133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139 9(2)v9(3) Earnings Per Share - Basic 
140 x Earnings Indicator - Basic 
141-147 9(7) Shares Outstanding 
148 9 Indicated Annual Dividend (IAD) Modifier 
149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184 First Dividend Data: 
153-158 9(2)v9(4) Dividend Amount/Rate 
159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170 9(6) Record Date (mmddyy) 
171-176 9(6) Payment Date (mmddyy) 
177 x Payment Type Code 
178 x Payment Order/Scaling Factor 
179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180 9 Revision/Late Code 
181 9 Payment Frequency Code 
182 x Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183 x Revision Indicator 
184 9 Announcement Entry Code 
185-216 Second Dividend Data: 
185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196 9(6) 
Record Date (mmddyy) 
197-202 9(6) 
Payment Date (mmddyy) 
203-208 9(6) 
209 x Payment Type Code 
210 x Payment Order/Scaling Factor Code 
211 x Tax Base Code 
212 9 Revision/Late Code 
213 9 Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214 x Reserved for future development 
215 x Revision Indicator 
216 9 Announcement Entry Code 
217-320 For 320 Service: 
217-223 9(4)v9(3) Bid 
224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132 
243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260 x(4) 
261 x Rule 144A Flag 
262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272  9(2)v9(3) Earnings Per Share - Diluted  
273 x Earnings Indicator - Diluted 
274-279 x(6) NAICS Code 
280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292 x(3) Currency Code - First Dividend Data  
136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295 x(3) Currency Code - Second Dividend Data  
296-308 x(13) Reserved for future development  
309 x Moody's Quality Rating 
310 x Quote Source Code 
311 x CUSIP Check Digit 
312-314 x(3) Supplemental Issue Type Code 
315 x Shares Outstanding Indicator 
316-319 x(4) Reserved for internal use 
320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^0-9]+\):                \1:'
11/08  320/216 Record Formats  135 
1-68 x(80) Identification Data: 
1-8 x(8) CUSIP Number/User Number 
9 x Uniqueness Code: blank, 1 
10 x Exchange Code 
 
11-16 x(6) Ticker Symbol 
17-20 x(4) SIC Code 
21-48 x(28) Issuer Description 
49-68 x(20) Issue Description 
69-107 Pricing Data: 
69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-79 9(7) Volume 
80-86 9(4)v9(3) High/Ask 
87-93 9(4)v9(3) Low/Bid 
94-100 9(4)v9(3) Current Price/Evaluation 
101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132 Indicators Data: 
108-111 x(4) Status/Type Flag 
108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109 x Trade Type Code: 0-5, 8, 9, H, Z 
110 x Issue Status Code 
111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119 x(8) Expiration Date (mmddccyy) 
120-125 9(2)v9(4) Adjustment Factor 
126 x Margin/Eligibility Code 
127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152 Earnings For Equities/Indices Data: 
133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139 9(2)v9(3) Earnings Per Share - Basic 
140 x Earnings Indicator - Basic 
141-147 9(7) Shares Outstanding 
148 9 Indicated Annual Dividend (IAD) Modifier 
149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184 First Dividend Data: 
153-158 9(2)v9(4) Dividend Amount/Rate 
159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170 9(6) Record Date (mmddyy) 
171-176 9(6) Payment Date (mmddyy) 
177 x Payment Type Code 
178 x Payment Order/Scaling Factor 
179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180 9 Revision/Late Code 
181 9 Payment Frequency Code 
182 x Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183 x Revision Indicator 
184 9 Announcement Entry Code 
185-216 Second Dividend Data: 
185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196 9(6) 
Record Date (mmddyy) 
197-202 9(6) 
Payment Date (mmddyy) 
203-208 9(6) 
209 x Payment Type Code 
210 x Payment Order/Scaling Factor Code 
211 x Tax Base Code 
212 9 Revision/Late Code 
213 9 Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214 x Reserved for future development 
215 x Revision Indicator 
216 9 Announcement Entry Code 
217-320 For 320 Service: 
217-223 9(4)v9(3) Bid 
224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132 
243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260 x(4) 
261 x Rule 144A Flag 
262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272  9(2)v9(3) Earnings Per Share - Diluted  
273 x Earnings Indicator - Diluted 
274-279 x(6) NAICS Code 
280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292 x(3) Currency Code - First Dividend Data  
136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295 x(3) Currency Code - Second Dividend Data  
296-308 x(13) Reserved for future development  
309 x Moody's Quality Rating 
310 x Quote Source Code 
311 x CUSIP Check Digit 
312-314 x(3) Supplemental Issue Type Code 
315 x Shares Outstanding Indicator 
316-319 x(4) Reserved for internal use 
320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^0-9]\{1,\}\):                \1:'
11/08  320/216 Record Formats  135 
1-68 x(80) Identification Data: 
1-8 x(8) CUSIP Number/User Number 
9 x Uniqueness Code: blank, 1 
10 x Exchange Code 
                 
11-16 x(6) Ticker Symbol 
17-20 x(4) SIC Code 
21-48 x(28) Issuer Description 
49-68 x(20) Issue Description 
69-107 Pricing Data: 
69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-79 9(7) Volume 
80-86 9(4)v9(3) High/Ask 
87-93 9(4)v9(3) Low/Bid 
94-100 9(4)v9(3) Current Price/Evaluation 
101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132 Indicators Data: 
108-111 x(4) Status/Type Flag 
108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109 x Trade Type Code: 0-5, 8, 9, H, Z 
110 x Issue Status Code 
111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
                Rating Code 
                 For index records, pos. 112-126: Reserved for future development 
112-119 x(8) Expiration Date (mmddccyy) 
120-125 9(2)v9(4) Adjustment Factor 
126 x Margin/Eligibility Code 
127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
                 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152 Earnings For Equities/Indices Data: 
133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139 9(2)v9(3) Earnings Per Share - Basic 
140 x Earnings Indicator - Basic 
141-147 9(7) Shares Outstanding 
148 9 Indicated Annual Dividend (IAD) Modifier 
149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184 First Dividend Data: 
153-158 9(2)v9(4) Dividend Amount/Rate 
159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170 9(6) Record Date (mmddyy) 
171-176 9(6) Payment Date (mmddyy) 
177 x Payment Type Code 
178 x Payment Order/Scaling Factor 
179 x Tax Base Code 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
180 9 Revision/Late Code 
181 9 Payment Frequency Code 
182 x Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183 x Revision Indicator 
184 9 Announcement Entry Code 
185-216 Second Dividend Data: 
185-190 9(2)v9(4) Dividend Amount/Rate 
                Ex-Distribution/Dividend Date (mmddyy) 
191-196 9(6) 
                Record Date (mmddyy) 
197-202 9(6) 
                Payment Date (mmddyy) 
203-208 9(6) 
209 x Payment Type Code 
210 x Payment Order/Scaling Factor Code 
211 x Tax Base Code 
212 9 Revision/Late Code 
213 9 Liquidation/Return of Capital Flag  
8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214 x Reserved for future development 
215 x Revision Indicator 
216 9 Announcement Entry Code 
217-320 For 320 Service: 
217-223 9(4)v9(3) Bid 
224-230 9(4)v9(3) Ask 
                Bid/Ask Pricing Date (ccyymmdd) 
231-238 x(8) 
                Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242 x(4) 


                Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
                or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132 
243-244 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
                First Dividend Data field)  
245-246 x(2) 
                Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
                field)  
247-248 x(2) 
                Century (cc) of Payment Date (positions 171-176 in First Dividend 
                Data field) 
249-250 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
                Second Dividend Data field)  
251-252 x(2) 
                Century (cc) of Record Date (positions 197-202 in Second 
                Dividend Data field)  
253-254 x(2) 
                Century (cc) of Payment Date (positions 203-208 in Second 
                Dividend Data field) 
255-256 x(2) 
                Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260 x(4) 
261 x Rule 144A Flag 
262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272  9(2)v9(3) Earnings Per Share - Diluted  
273 x Earnings Indicator - Diluted 
274-279 x(6) NAICS Code 
280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292 x(3) Currency Code - First Dividend Data  
136  320/216 Record Formats  11/08 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
293-295 x(3) Currency Code - Second Dividend Data  
296-308 x(13) Reserved for future development  
309 x Moody's Quality Rating 
310 x Quote Source Code 
311 x CUSIP Check Digit 
312-314 x(3) Supplemental Issue Type Code 
315 x Shares Outstanding Indicator 
316-319 x(4) Reserved for internal use 
320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^ ]*[^0-9]\{1,\}\):                \1:'
                11/08  320/216 Record Formats  135 
                1-68 x(80) Identification Data: 
                1-8 x(8) CUSIP Number/User Number 
                9 x Uniqueness Code: blank, 1 
                10 x Exchange Code 
                 
                11-16 x(6) Ticker Symbol 
                17-20 x(4) SIC Code 
                21-48 x(28) Issuer Description 
                49-68 x(20) Issue Description 
                69-107 Pricing Data: 
                69-72 9(4) Pricing/Evaluation Date (mmdd) 
                73-79 9(7) Volume 
                80-86 9(4)v9(3) High/Ask 
                87-93 9(4)v9(3) Low/Bid 
                94-100 9(4)v9(3) Current Price/Evaluation 
                101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
                108-132 Indicators Data: 
                108-111 x(4) Status/Type Flag 
                108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
                109 x Trade Type Code: 0-5, 8, 9, H, Z 
                110 x Issue Status Code 
                111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
                Rating Code 
                 For index records, pos. 112-126: Reserved for future development 
                112-119 x(8) Expiration Date (mmddccyy) 
                120-125 9(2)v9(4) Adjustment Factor 
                126 x Margin/Eligibility Code 
                127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
                 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
                133-152 Earnings For Equities/Indices Data: 
                133-134 9(2) Earnings Per Share Month - Basic (mm) 
                135-139 9(2)v9(3) Earnings Per Share - Basic 
                140 x Earnings Indicator - Basic 
                141-147 9(7) Shares Outstanding 
                148 9 Indicated Annual Dividend (IAD) Modifier 
                149-152 9v9(3) Indicated Annual Dividend (IAD) 
                153-184 First Dividend Data: 
                153-158 9(2)v9(4) Dividend Amount/Rate 
                159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
                165-170 9(6) Record Date (mmddyy) 
                171-176 9(6) Payment Date (mmddyy) 
                177 x Payment Type Code 
                178 x Payment Order/Scaling Factor 
                179 x Tax Base Code 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
                180 9 Revision/Late Code 
                181 9 Payment Frequency Code 
                182 x Liquidation/Return of Capital Flag  
                8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
                183 x Revision Indicator 
                184 9 Announcement Entry Code 
                185-216 Second Dividend Data: 
                185-190 9(2)v9(4) Dividend Amount/Rate 
                Ex-Distribution/Dividend Date (mmddyy) 
                191-196 9(6) 
                Record Date (mmddyy) 
                197-202 9(6) 
                Payment Date (mmddyy) 
                203-208 9(6) 
                209 x Payment Type Code 
                210 x Payment Order/Scaling Factor Code 
                211 x Tax Base Code 
                212 9 Revision/Late Code 
                213 9 Liquidation/Return of Capital Flag  
                8 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
                214 x Reserved for future development 
                215 x Revision Indicator 
                216 9 Announcement Entry Code 
                217-320 For 320 Service: 
                217-223 9(4)v9(3) Bid 
                224-230 9(4)v9(3) Ask 
                Bid/Ask Pricing Date (ccyymmdd) 
                231-238 x(8) 
                Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
                239-242 x(4) 


                Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
                or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
                132 
                243-244 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
                First Dividend Data field)  
                245-246 x(2) 
                Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
                field)  
                247-248 x(2) 
                Century (cc) of Payment Date (positions 171-176 in First Dividend 
                Data field) 
                249-250 x(2) 
                Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
                Second Dividend Data field)  
                251-252 x(2) 
                Century (cc) of Record Date (positions 197-202 in Second 
                Dividend Data field)  
                253-254 x(2) 
                Century (cc) of Payment Date (positions 203-208 in Second 
                Dividend Data field) 
                255-256 x(2) 
                Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
                257-260 x(4) 
                261 x Rule 144A Flag 
                262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
                268-272  9(2)v9(3) Earnings Per Share - Diluted  
                273 x Earnings Indicator - Diluted 
                274-279 x(6) NAICS Code 
                280-284 x(5) Announcement Sequence Code - First Dividend Data  
                285-289 x(5) Announcement Sequence Code - Second Dividend Data  
                290-292 x(3) Currency Code - First Dividend Data  
                136  320/216 Record Formats  11/08 
                IDSI REFERENCE MANUAL 
                Position Format Data Field 
                293-295 x(3) Currency Code - Second Dividend Data  
                296-308 x(13) Reserved for future development  
                309 x Moody's Quality Rating 
                310 x Quote Source Code 
                311 x CUSIP Check Digit 
                312-314 x(3) Supplemental Issue Type Code 
                315 x Shares Outstanding Indicator 
                316-319 x(4) Reserved for internal use 
                320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^ ]*\)\([^0-9]\{1,\}\):         \2       \1:'
                  11/08320/216 Record Formats  135 
          x(       1-6880) Identification Data: 
          x(       1-88) CUSIP Number/User Number 
          x Uniqueness Code: blank,        91 
          x Exchange Code        10
                 
          x(       11-166) Ticker Symbol 
          x(       17-204) SIC Code 
          x(       21-4828) Issuer Description 
          x(       49-6820) Issue Description 
          Pricing Data:        69-107
                 69-729(4) Pricing/Evaluation Date (mmdd) 
                 73-799(7) Volume 
                 80-869(4)v9(3) High/Ask 
                 87-939(4)v9(3) Low/Bid 
                 94-1009(4)v9(3) Current Price/Evaluation 
                 101-1079(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
          Indicators Data:        108-132
          x(       108-1114) Status/Type Flag 
          x Issue Type Code:        1080-2, 4, 7, 8, A, E-G, Q, % 
          x Trade Type Code:        1090-5, 8, 9, H, Z 
          x Issue Status Code        110
          x Standard & Poor?s Common Stock Ranking or Preferred Stock        111
          Code        Rating
          For index records, pos.        112-126: Reserved for future development 
          x(       112-1198) Expiration Date (mmddccyy) 
                 120-1259(2)v9(4) Adjustment Factor 
          x Margin/Eligibility Code        126
          x(       127-1326) Date of Previous Price/Evaluation (mmddyy) 
          x(       6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
          Earnings For Equities/Indices Data:        133-152
                 133-1349(2) Earnings Per Share Month - Basic (mm) 
                 135-1399(2)v9(3) Earnings Per Share - Basic 
          x Earnings Indicator - Basic        140
                 141-1479(7) Shares Outstanding 
                 1489 Indicated Annual Dividend (IAD) Modifier 
                 149-1529v9(3) Indicated Annual Dividend (IAD) 
          First Dividend Data:        153-184
                 153-1589(2)v9(4) Dividend Amount/Rate 
                 159-1649(6) Ex-Distribution/Dividend Date (mmddyy) 
                 165-1709(6) Record Date (mmddyy) 
                 171-1769(6) Payment Date (mmddyy) 
          x Payment Type Code        177
          x Payment Order/Scaling Factor        178
          x Tax Base Code        179
          REFERENCE MANUAL        IDSI
          Format Data Field        Position
                 1809 Revision/Late Code 
                 1819 Payment Frequency Code 
          x Liquidation/Return of Capital Flag         182
          = Liquidation,        89 = Return of Capital, 0 = Not applicable 
          x Revision Indicator        183
                 1849 Announcement Entry Code 
          Second Dividend Data:        185-216
                 185-1909(2)v9(4) Dividend Amount/Rate 
          Date (mmddyy)        Ex-Distribution/Dividend
                 191-1969(6) 
          Date (mmddyy)        Record
                 197-2029(6) 
          Date (mmddyy)        Payment
                 203-2089(6) 
          x Payment Type Code        209
          x Payment Order/Scaling Factor Code        210
          x Tax Base Code        211
                 2129 Revision/Late Code 
                 2139 Liquidation/Return of Capital Flag  
          = Liquidation,        89 = Return of Capital, 0 = Not applicable 
          x Reserved for future development        214
          x Revision Indicator        215
                 2169 Announcement Entry Code 
          For        217-320320 Service: 
                 217-2239(4)v9(3) Bid 
                 224-2309(4)v9(3) Ask 
          Pricing Date (ccyymmdd)        Bid/Ask
          x(       231-2388) 
          (ccyy) of Pricing/Evaluation Date (positions        Year69-72) 
          x(       239-2424) 


          (cc) of Date of Previous Price/Evaluation (pos.        Century127-132) 
          Zero-filled, if Cross-Reference CUSIP Number in positions        or127- 
                 132
          x(       243-2442) 
          (cc) of Ex-Distribution/Dividend Date (pos.        Century159-164 in 
          Dividend Data field)         First
          x(       245-2462) 
          (cc) of Record Date (pos.        Century165-170 in First Dividend Data 
                  field)
          x(       247-2482) 
          (cc) of Payment Date (positions        Century171-176 in First Dividend 
          field)        Data
          x(       249-2502) 
          (cc) of Ex-Distribution/Dividend Date (pos.        Century191-196 in 
          Dividend Data field)         Second
          x(       251-2522) 
          (cc) of Record Date (positions        Century197-202 in Second 
          Data field)         Dividend
          x(       253-2542) 
          (cc) of Payment Date (positions        Century203-208 in Second 
          Data field)        Dividend
          x(       255-2562) 
          (ccyy) of Basic Earnings Per Share (positions        Year133-134) 
          x(       257-2604) 
          x Rule        261144A Flag 
                 262-2679(6) Earnings Per Share Month - Diluted  (ccyymm) 
                  268-2729(2)v9(3) Earnings Per Share - Diluted  
          x Earnings Indicator - Diluted        273
          x(       274-2796) NAICS Code 
          x(       280-2845) Announcement Sequence Code - First Dividend Data  
          x(       285-2895) Announcement Sequence Code - Second Dividend Data  
          x(       290-2923) Currency Code - First Dividend Data  
                  136320/216 Record Formats  11/08 
          REFERENCE MANUAL        IDSI
          Format Data Field        Position
          x(       293-2953) Currency Code - Second Dividend Data  
          x(       296-30813) Reserved for future development  
          x Moody's Quality Rating        309
          x Quote Source Code        310
          x CUSIP Check Digit        311
          x(       312-3143) Supplemental Issue Type Code 
          x Shares Outstanding Indicator        315
          x(       316-3194) Reserved for internal use 
          x Record Layout Code: F        320
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^ ]*\)\([^0-9]\{1,\}\):         \1       \2:'
         11/08         320/216 Record Formats  135 
         1-68        x(80) Identification Data: 
         1-8        x(8) CUSIP Number/User Number 
         9        x Uniqueness Code: blank, 1 
         10        x Exchange Code 
                 
         11-16        x(6) Ticker Symbol 
         17-20        x(4) SIC Code 
         21-48        x(28) Issuer Description 
         49-68        x(20) Issue Description 
         69-107        Pricing Data: 
         69-72        9(4) Pricing/Evaluation Date (mmdd) 
         73-79        9(7) Volume 
         80-86        9(4)v9(3) High/Ask 
         87-93        9(4)v9(3) Low/Bid 
         94-100        9(4)v9(3) Current Price/Evaluation 
         101-107        9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
         108-132        Indicators Data: 
         108-111        x(4) Status/Type Flag 
         108        x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
         109        x Trade Type Code: 0-5, 8, 9, H, Z 
         110        x Issue Status Code 
         111        x Standard & Poor?s Common Stock Ranking or Preferred Stock 
         Rating        Code 
                 For index records, pos. 112-126: Reserved for future development 
         112-119        x(8) Expiration Date (mmddccyy) 
         120-125        9(2)v9(4) Adjustment Factor 
         126        x Margin/Eligibility Code 
         127-132        x(6) Date of Previous Price/Evaluation (mmddyy) 
                 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
         133-152        Earnings For Equities/Indices Data: 
         133-134        9(2) Earnings Per Share Month - Basic (mm) 
         135-139        9(2)v9(3) Earnings Per Share - Basic 
         140        x Earnings Indicator - Basic 
         141-147        9(7) Shares Outstanding 
         148        9 Indicated Annual Dividend (IAD) Modifier 
         149-152        9v9(3) Indicated Annual Dividend (IAD) 
         153-184        First Dividend Data: 
         153-158        9(2)v9(4) Dividend Amount/Rate 
         159-164        9(6) Ex-Distribution/Dividend Date (mmddyy) 
         165-170        9(6) Record Date (mmddyy) 
         171-176        9(6) Payment Date (mmddyy) 
         177        x Payment Type Code 
         178        x Payment Order/Scaling Factor 
         179        x Tax Base Code 
         IDSI        REFERENCE MANUAL 
         Position        Format Data Field 
         180        9 Revision/Late Code 
         181        9 Payment Frequency Code 
         182        x Liquidation/Return of Capital Flag  
         8        = Liquidation, 9 = Return of Capital, 0 = Not applicable 
         183        x Revision Indicator 
         184        9 Announcement Entry Code 
         185-216        Second Dividend Data: 
         185-190        9(2)v9(4) Dividend Amount/Rate 
         Ex-Distribution/Dividend        Date (mmddyy) 
         191-196        9(6) 
         Record        Date (mmddyy) 
         197-202        9(6) 
         Payment        Date (mmddyy) 
         203-208        9(6) 
         209        x Payment Type Code 
         210        x Payment Order/Scaling Factor Code 
         211        x Tax Base Code 
         212        9 Revision/Late Code 
         213        9 Liquidation/Return of Capital Flag  
         8        = Liquidation, 9 = Return of Capital, 0 = Not applicable 
         214        x Reserved for future development 
         215        x Revision Indicator 
         216        9 Announcement Entry Code 
         217-320        For 320 Service: 
         217-223        9(4)v9(3) Bid 
         224-230        9(4)v9(3) Ask 
         Bid/Ask        Pricing Date (ccyymmdd) 
         231-238        x(8) 
         Year        (ccyy) of Pricing/Evaluation Date (positions 69-72) 
         239-242        x(4) 


         Century        (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
         or        Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
         132        
         243-244        x(2) 
         Century        (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
         First        Dividend Data field)  
         245-246        x(2) 
         Century        (cc) of Record Date (pos. 165-170 in First Dividend Data 
         field)         
         247-248        x(2) 
         Century        (cc) of Payment Date (positions 171-176 in First Dividend 
         Data        field) 
         249-250        x(2) 
         Century        (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
         Second        Dividend Data field)  
         251-252        x(2) 
         Century        (cc) of Record Date (positions 197-202 in Second 
         Dividend        Data field)  
         253-254        x(2) 
         Century        (cc) of Payment Date (positions 203-208 in Second 
         Dividend        Data field) 
         255-256        x(2) 
         Year        (ccyy) of Basic Earnings Per Share (positions 133-134) 
         257-260        x(4) 
         261        x Rule 144A Flag 
         262-267        9(6) Earnings Per Share Month - Diluted  (ccyymm) 
         268-272         9(2)v9(3) Earnings Per Share - Diluted  
         273        x Earnings Indicator - Diluted 
         274-279        x(6) NAICS Code 
         280-284        x(5) Announcement Sequence Code - First Dividend Data  
         285-289        x(5) Announcement Sequence Code - Second Dividend Data  
         290-292        x(3) Currency Code - First Dividend Data  
         136         320/216 Record Formats  11/08 
         IDSI        REFERENCE MANUAL 
         Position        Format Data Field 
         293-295        x(3) Currency Code - Second Dividend Data  
         296-308        x(13) Reserved for future development  
         309        x Moody's Quality Rating 
         310        x Quote Source Code 
         311        x CUSIP Check Digit 
         312-314        x(3) Supplemental Issue Type Code 
         315        x Shares Outstanding Indicator 
         316-319        x(4) Reserved for internal use 
         320        x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^ ]*\)\([^0-9]\{1,\}\):\1       \2:'
11/08         320/216 Record Formats  135 
1-68        x(80) Identification Data: 
1-8        x(8) CUSIP Number/User Number 
9        x Uniqueness Code: blank, 1 
10        x Exchange Code 
        
11-16        x(6) Ticker Symbol 
17-20        x(4) SIC Code 
21-48        x(28) Issuer Description 
49-68        x(20) Issue Description 
69-107        Pricing Data: 
69-72        9(4) Pricing/Evaluation Date (mmdd) 
73-79        9(7) Volume 
80-86        9(4)v9(3) High/Ask 
87-93        9(4)v9(3) Low/Bid 
94-100        9(4)v9(3) Current Price/Evaluation 
101-107        9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132        Indicators Data: 
108-111        x(4) Status/Type Flag 
108        x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109        x Trade Type Code: 0-5, 8, 9, H, Z 
110        x Issue Status Code 
111        x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating        Code 
        For index records, pos. 112-126: Reserved for future development 
112-119        x(8) Expiration Date (mmddccyy) 
120-125        9(2)v9(4) Adjustment Factor 
126        x Margin/Eligibility Code 
127-132        x(6) Date of Previous Price/Evaluation (mmddyy) 
        x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152        Earnings For Equities/Indices Data: 
133-134        9(2) Earnings Per Share Month - Basic (mm) 
135-139        9(2)v9(3) Earnings Per Share - Basic 
140        x Earnings Indicator - Basic 
141-147        9(7) Shares Outstanding 
148        9 Indicated Annual Dividend (IAD) Modifier 
149-152        9v9(3) Indicated Annual Dividend (IAD) 
153-184        First Dividend Data: 
153-158        9(2)v9(4) Dividend Amount/Rate 
159-164        9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170        9(6) Record Date (mmddyy) 
171-176        9(6) Payment Date (mmddyy) 
177        x Payment Type Code 
178        x Payment Order/Scaling Factor 
179        x Tax Base Code 
IDSI        REFERENCE MANUAL 
Position        Format Data Field 
180        9 Revision/Late Code 
181        9 Payment Frequency Code 
182        x Liquidation/Return of Capital Flag  
8        = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183        x Revision Indicator 
184        9 Announcement Entry Code 
185-216        Second Dividend Data: 
185-190        9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend        Date (mmddyy) 
191-196        9(6) 
Record        Date (mmddyy) 
197-202        9(6) 
Payment        Date (mmddyy) 
203-208        9(6) 
209        x Payment Type Code 
210        x Payment Order/Scaling Factor Code 
211        x Tax Base Code 
212        9 Revision/Late Code 
213        9 Liquidation/Return of Capital Flag  
8        = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214        x Reserved for future development 
215        x Revision Indicator 
216        9 Announcement Entry Code 
217-320        For 320 Service: 
217-223        9(4)v9(3) Bid 
224-230        9(4)v9(3) Ask 
Bid/Ask        Pricing Date (ccyymmdd) 
231-238        x(8) 
Year        (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242        x(4) 


Century        (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or        Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132        
243-244        x(2) 
Century        (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First        Dividend Data field)  
245-246        x(2) 
Century        (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)         
247-248        x(2) 
Century        (cc) of Payment Date (positions 171-176 in First Dividend 
Data        field) 
249-250        x(2) 
Century        (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second        Dividend Data field)  
251-252        x(2) 
Century        (cc) of Record Date (positions 197-202 in Second 
Dividend        Data field)  
253-254        x(2) 
Century        (cc) of Payment Date (positions 203-208 in Second 
Dividend        Data field) 
255-256        x(2) 
Year        (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260        x(4) 
261        x Rule 144A Flag 
262-267        9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272         9(2)v9(3) Earnings Per Share - Diluted  
273        x Earnings Indicator - Diluted 
274-279        x(6) NAICS Code 
280-284        x(5) Announcement Sequence Code - First Dividend Data  
285-289        x(5) Announcement Sequence Code - Second Dividend Data  
290-292        x(3) Currency Code - First Dividend Data  
136         320/216 Record Formats  11/08 
IDSI        REFERENCE MANUAL 
Position        Format Data Field 
293-295        x(3) Currency Code - Second Dividend Data  
296-308        x(13) Reserved for future development  
309        x Moody's Quality Rating 
310        x Quote Source Code 
311        x CUSIP Check Digit 
312-314        x(3) Supplemental Issue Type Code 
315        x Shares Outstanding Indicator 
316-319        x(4) Reserved for internal use 
320        x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([^ ]*\)\([^0-9]\{1,\}\):\1               \2:'
11/08                 320/216 Record Formats  135 
1-68                x(80) Identification Data: 
1-8                x(8) CUSIP Number/User Number 
9                x Uniqueness Code: blank, 1 
10                x Exchange Code 
                
11-16                x(6) Ticker Symbol 
17-20                x(4) SIC Code 
21-48                x(28) Issuer Description 
49-68                x(20) Issue Description 
69-107                Pricing Data: 
69-72                9(4) Pricing/Evaluation Date (mmdd) 
73-79                9(7) Volume 
80-86                9(4)v9(3) High/Ask 
87-93                9(4)v9(3) Low/Bid 
94-100                9(4)v9(3) Current Price/Evaluation 
101-107                9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132                Indicators Data: 
108-111                x(4) Status/Type Flag 
108                x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109                x Trade Type Code: 0-5, 8, 9, H, Z 
110                x Issue Status Code 
111                x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating                Code 
                For index records, pos. 112-126: Reserved for future development 
112-119                x(8) Expiration Date (mmddccyy) 
120-125                9(2)v9(4) Adjustment Factor 
126                x Margin/Eligibility Code 
127-132                x(6) Date of Previous Price/Evaluation (mmddyy) 
                x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152                Earnings For Equities/Indices Data: 
133-134                9(2) Earnings Per Share Month - Basic (mm) 
135-139                9(2)v9(3) Earnings Per Share - Basic 
140                x Earnings Indicator - Basic 
141-147                9(7) Shares Outstanding 
148                9 Indicated Annual Dividend (IAD) Modifier 
149-152                9v9(3) Indicated Annual Dividend (IAD) 
153-184                First Dividend Data: 
153-158                9(2)v9(4) Dividend Amount/Rate 
159-164                9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170                9(6) Record Date (mmddyy) 
171-176                9(6) Payment Date (mmddyy) 
177                x Payment Type Code 
178                x Payment Order/Scaling Factor 
179                x Tax Base Code 
IDSI                REFERENCE MANUAL 
Position                Format Data Field 
180                9 Revision/Late Code 
181                9 Payment Frequency Code 
182                x Liquidation/Return of Capital Flag  
8                = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183                x Revision Indicator 
184                9 Announcement Entry Code 
185-216                Second Dividend Data: 
185-190                9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend                Date (mmddyy) 
191-196                9(6) 
Record                Date (mmddyy) 
197-202                9(6) 
Payment                Date (mmddyy) 
203-208                9(6) 
209                x Payment Type Code 
210                x Payment Order/Scaling Factor Code 
211                x Tax Base Code 
212                9 Revision/Late Code 
213                9 Liquidation/Return of Capital Flag  
8                = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214                x Reserved for future development 
215                x Revision Indicator 
216                9 Announcement Entry Code 
217-320                For 320 Service: 
217-223                9(4)v9(3) Bid 
224-230                9(4)v9(3) Ask 
Bid/Ask                Pricing Date (ccyymmdd) 
231-238                x(8) 
Year                (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242                x(4) 


Century                (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or                Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132                
243-244                x(2) 
Century                (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First                Dividend Data field)  
245-246                x(2) 
Century                (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)                 
247-248                x(2) 
Century                (cc) of Payment Date (positions 171-176 in First Dividend 
Data                field) 
249-250                x(2) 
Century                (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second                Dividend Data field)  
251-252                x(2) 
Century                (cc) of Record Date (positions 197-202 in Second 
Dividend                Data field)  
253-254                x(2) 
Century                (cc) of Payment Date (positions 203-208 in Second 
Dividend                Data field) 
255-256                x(2) 
Year                (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260                x(4) 
261                x Rule 144A Flag 
262-267                9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272                 9(2)v9(3) Earnings Per Share - Diluted  
273                x Earnings Indicator - Diluted 
274-279                x(6) NAICS Code 
280-284                x(5) Announcement Sequence Code - First Dividend Data  
285-289                x(5) Announcement Sequence Code - Second Dividend Data  
290-292                x(3) Currency Code - First Dividend Data  
136                 320/216 Record Formats  11/08 
IDSI                REFERENCE MANUAL 
Position                Format Data Field 
293-295                x(3) Currency Code - Second Dividend Data  
296-308                x(13) Reserved for future development  
309                x Moody's Quality Rating 
310                x Quote Source Code 
311                x CUSIP Check Digit 
312-314                x(3) Supplemental Issue Type Code 
315                x Shares Outstanding Indicator 
316-319                x(4) Reserved for internal use 
320                x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9\-]\)\([^]*\)\([^0-9]\{1,\}\):\1               \2\3:'
sed: 1: "s:^\([0-9\-]\)\([^]*\)\ ...": \3 not defined in the RE
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9-]\)\([^]*\)\([^0-9]\{1,\}\):\1               \2\3:'
sed: 1: "s:^\([0-9-]\)\([^]*\)\( ...": \3 not defined in the RE
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9-]\)\([^]*\)\([^0-9]\{1,\}\):\1               \2:'
11/08  320/216 Record Formats  135 
1               -68 x(80) Identification Data: 
1               -8 x(8) CUSIP Number/User Number 
9                x Uniqueness Code: blank, 1 
10 x Exchange Code 
 
11-16 x(6) Ticker Symbol 
17-20 x(4) SIC Code 
21-48 x(28) Issuer Description 
49-68 x(20) Issue Description 
69-107 Pricing Data: 
69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-79 9(7) Volume 
80-86 9(4)v9(3) High/Ask 
87-93 9(4)v9(3) Low/Bid 
94-100 9(4)v9(3) Current Price/Evaluation 
101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132 Indicators Data: 
108-111 x(4) Status/Type Flag 
108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109 x Trade Type Code: 0-5, 8, 9, H, Z 
110 x Issue Status Code 
111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119 x(8) Expiration Date (mmddccyy) 
120-125 9(2)v9(4) Adjustment Factor 
126 x Margin/Eligibility Code 
127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152 Earnings For Equities/Indices Data: 
133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139 9(2)v9(3) Earnings Per Share - Basic 
140 x Earnings Indicator - Basic 
141-147 9(7) Shares Outstanding 
148 9 Indicated Annual Dividend (IAD) Modifier 
149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184 First Dividend Data: 
153-158 9(2)v9(4) Dividend Amount/Rate 
159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170 9(6) Record Date (mmddyy) 
171-176 9(6) Payment Date (mmddyy) 
177 x Payment Type Code 
178 x Payment Order/Scaling Factor 
179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180 9 Revision/Late Code 
181 9 Payment Frequency Code 
182 x Liquidation/Return of Capital Flag  
8                = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183 x Revision Indicator 
184 9 Announcement Entry Code 
185-216 Second Dividend Data: 
185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196 9(6) 
Record Date (mmddyy) 
197-202 9(6) 
Payment Date (mmddyy) 
203-208 9(6) 
209 x Payment Type Code 
210 x Payment Order/Scaling Factor Code 
211 x Tax Base Code 
212 9 Revision/Late Code 
213 9 Liquidation/Return of Capital Flag  
8                = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214 x Reserved for future development 
215 x Revision Indicator 
216 9 Announcement Entry Code 
217-320 For 320 Service: 
217-223 9(4)v9(3) Bid 
224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132 
243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260 x(4) 
261 x Rule 144A Flag 
262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272  9(2)v9(3) Earnings Per Share - Diluted  
273 x Earnings Indicator - Diluted 
274-279 x(6) NAICS Code 
280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292 x(3) Currency Code - First Dividend Data  
136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295 x(3) Currency Code - Second Dividend Data  
296-308 x(13) Reserved for future development  
309 x Moody's Quality Rating 
310 x Quote Source Code 
311 x CUSIP Check Digit 
312-314 x(3) Supplemental Issue Type Code 
315 x Shares Outstanding Indicator 
316-319 x(4) Reserved for internal use 
320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]\{0,}\):\1\1:'
sed: 1: "s:^\([0-9]\{1,\}[-]\{0, ...": RE error: braces not balanced
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9]\{1,\}[-]\{0,1\}\):\1\1:'
1111/08  320/216 Record Formats  135 
1-1-68 x(80) Identification Data: 
1-1-8 x(8) CUSIP Number/User Number 
99 x Uniqueness Code: blank, 1 
1010 x Exchange Code 
 
11-11-16 x(6) Ticker Symbol 
17-17-20 x(4) SIC Code 
21-21-48 x(28) Issuer Description 
49-49-68 x(20) Issue Description 
69-69-107 Pricing Data: 
69-69-72 9(4) Pricing/Evaluation Date (mmdd) 
73-73-79 9(7) Volume 
80-80-86 9(4)v9(3) High/Ask 
87-87-93 9(4)v9(3) Low/Bid 
94-94-100 9(4)v9(3) Current Price/Evaluation 
101-101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-108-132 Indicators Data: 
108-108-111 x(4) Status/Type Flag 
108108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109109 x Trade Type Code: 0-5, 8, 9, H, Z 
110110 x Issue Status Code 
111111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-112-119 x(8) Expiration Date (mmddccyy) 
120-120-125 9(2)v9(4) Adjustment Factor 
126126 x Margin/Eligibility Code 
127-127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-133-152 Earnings For Equities/Indices Data: 
133-133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-135-139 9(2)v9(3) Earnings Per Share - Basic 
140140 x Earnings Indicator - Basic 
141-141-147 9(7) Shares Outstanding 
148148 9 Indicated Annual Dividend (IAD) Modifier 
149-149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-153-184 First Dividend Data: 
153-153-158 9(2)v9(4) Dividend Amount/Rate 
159-159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-165-170 9(6) Record Date (mmddyy) 
171-171-176 9(6) Payment Date (mmddyy) 
177177 x Payment Type Code 
178178 x Payment Order/Scaling Factor 
179179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180180 9 Revision/Late Code 
181181 9 Payment Frequency Code 
182182 x Liquidation/Return of Capital Flag  
88 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183183 x Revision Indicator 
184184 9 Announcement Entry Code 
185-185-216 Second Dividend Data: 
185-185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-191-196 9(6) 
Record Date (mmddyy) 
197-197-202 9(6) 
Payment Date (mmddyy) 
203-203-208 9(6) 
209209 x Payment Type Code 
210210 x Payment Order/Scaling Factor Code 
211211 x Tax Base Code 
212212 9 Revision/Late Code 
213213 9 Liquidation/Return of Capital Flag  
88 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214214 x Reserved for future development 
215215 x Revision Indicator 
216216 9 Announcement Entry Code 
217-217-320 For 320 Service: 
217-217-223 9(4)v9(3) Bid 
224-224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132132 
243-243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-257-260 x(4) 
261261 x Rule 144A Flag 
262-262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-268-272  9(2)v9(3) Earnings Per Share - Diluted  
273273 x Earnings Indicator - Diluted 
274-274-279 x(6) NAICS Code 
280-280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-290-292 x(3) Currency Code - First Dividend Data  
136136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-293-295 x(3) Currency Code - Second Dividend Data  
296-296-308 x(13) Reserved for future development  
309309 x Moody's Quality Rating 
310310 x Quote Source Code 
311311 x CUSIP Check Digit 
312-312-314 x(3) Supplemental Issue Type Code 
315315 x Shares Outstanding Indicator 
316-316-319 x(4) Reserved for internal use 
320320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1\1:'
1111/08  320/216 Record Formats  135 
1-681-68 x(80) Identification Data: 
1-81-8 x(8) CUSIP Number/User Number 
99 x Uniqueness Code: blank, 1 
1010 x Exchange Code 
 
11-1611-16 x(6) Ticker Symbol 
17-2017-20 x(4) SIC Code 
21-4821-48 x(28) Issuer Description 
49-6849-68 x(20) Issue Description 
69-10769-107 Pricing Data: 
69-7269-72 9(4) Pricing/Evaluation Date (mmdd) 
73-7973-79 9(7) Volume 
80-8680-86 9(4)v9(3) High/Ask 
87-9387-93 9(4)v9(3) Low/Bid 
94-10094-100 9(4)v9(3) Current Price/Evaluation 
101-107101-107 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132108-132 Indicators Data: 
108-111108-111 x(4) Status/Type Flag 
108108 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109109 x Trade Type Code: 0-5, 8, 9, H, Z 
110110 x Issue Status Code 
111111 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119112-119 x(8) Expiration Date (mmddccyy) 
120-125120-125 9(2)v9(4) Adjustment Factor 
126126 x Margin/Eligibility Code 
127-132127-132 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152133-152 Earnings For Equities/Indices Data: 
133-134133-134 9(2) Earnings Per Share Month - Basic (mm) 
135-139135-139 9(2)v9(3) Earnings Per Share - Basic 
140140 x Earnings Indicator - Basic 
141-147141-147 9(7) Shares Outstanding 
148148 9 Indicated Annual Dividend (IAD) Modifier 
149-152149-152 9v9(3) Indicated Annual Dividend (IAD) 
153-184153-184 First Dividend Data: 
153-158153-158 9(2)v9(4) Dividend Amount/Rate 
159-164159-164 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170165-170 9(6) Record Date (mmddyy) 
171-176171-176 9(6) Payment Date (mmddyy) 
177177 x Payment Type Code 
178178 x Payment Order/Scaling Factor 
179179 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180180 9 Revision/Late Code 
181181 9 Payment Frequency Code 
182182 x Liquidation/Return of Capital Flag  
88 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183183 x Revision Indicator 
184184 9 Announcement Entry Code 
185-216185-216 Second Dividend Data: 
185-190185-190 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196191-196 9(6) 
Record Date (mmddyy) 
197-202197-202 9(6) 
Payment Date (mmddyy) 
203-208203-208 9(6) 
209209 x Payment Type Code 
210210 x Payment Order/Scaling Factor Code 
211211 x Tax Base Code 
212212 9 Revision/Late Code 
213213 9 Liquidation/Return of Capital Flag  
88 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214214 x Reserved for future development 
215215 x Revision Indicator 
216216 9 Announcement Entry Code 
217-320217-320 For 320 Service: 
217-223217-223 9(4)v9(3) Bid 
224-230224-230 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238231-238 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242239-242 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132132 
243-244243-244 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246245-246 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248247-248 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250249-250 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252251-252 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254253-254 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256255-256 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260257-260 x(4) 
261261 x Rule 144A Flag 
262-267262-267 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272268-272  9(2)v9(3) Earnings Per Share - Diluted  
273273 x Earnings Indicator - Diluted 
274-279274-279 x(6) NAICS Code 
280-284280-284 x(5) Announcement Sequence Code - First Dividend Data  
285-289285-289 x(5) Announcement Sequence Code - Second Dividend Data  
290-292290-292 x(3) Currency Code - First Dividend Data  
136136  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295293-295 x(3) Currency Code - Second Dividend Data  
296-308296-308 x(13) Reserved for future development  
309309 x Moody's Quality Rating 
310310 x Quote Source Code 
311311 x CUSIP Check Digit 
312-314312-314 x(3) Supplemental Issue Type Code 
315315 x Shares Outstanding Indicator 
316-319316-319 x(4) Reserved for internal use 
320320 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1     :g'
11     /08  320/216 Record Formats  135 
1-68      x(80) Identification Data: 
1-8      x(8) CUSIP Number/User Number 
9      x Uniqueness Code: blank, 1 
10      x Exchange Code 
 
11-16      x(6) Ticker Symbol 
17-20      x(4) SIC Code 
21-48      x(28) Issuer Description 
49-68      x(20) Issue Description 
69-107      Pricing Data: 
69-72      9(4) Pricing/Evaluation Date (mmdd) 
73-79      9(7) Volume 
80-86      9(4)v9(3) High/Ask 
87-93      9(4)v9(3) Low/Bid 
94-100      9(4)v9(3) Current Price/Evaluation 
101-107      9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132      Indicators Data: 
108-111      x(4) Status/Type Flag 
108      x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109      x Trade Type Code: 0-5, 8, 9, H, Z 
110      x Issue Status Code 
111      x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119      x(8) Expiration Date (mmddccyy) 
120-125      9(2)v9(4) Adjustment Factor 
126      x Margin/Eligibility Code 
127-132      x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152      Earnings For Equities/Indices Data: 
133-134      9(2) Earnings Per Share Month - Basic (mm) 
135-139      9(2)v9(3) Earnings Per Share - Basic 
140      x Earnings Indicator - Basic 
141-147      9(7) Shares Outstanding 
148      9 Indicated Annual Dividend (IAD) Modifier 
149-152      9v9(3) Indicated Annual Dividend (IAD) 
153-184      First Dividend Data: 
153-158      9(2)v9(4) Dividend Amount/Rate 
159-164      9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170      9(6) Record Date (mmddyy) 
171-176      9(6) Payment Date (mmddyy) 
177      x Payment Type Code 
178      x Payment Order/Scaling Factor 
179      x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180      9 Revision/Late Code 
181      9 Payment Frequency Code 
182      x Liquidation/Return of Capital Flag  
8      = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183      x Revision Indicator 
184      9 Announcement Entry Code 
185-216      Second Dividend Data: 
185-190      9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196      9(6) 
Record Date (mmddyy) 
197-202      9(6) 
Payment Date (mmddyy) 
203-208      9(6) 
209      x Payment Type Code 
210      x Payment Order/Scaling Factor Code 
211      x Tax Base Code 
212      9 Revision/Late Code 
213      9 Liquidation/Return of Capital Flag  
8      = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214      x Reserved for future development 
215      x Revision Indicator 
216      9 Announcement Entry Code 
217-320      For 320 Service: 
217-223      9(4)v9(3) Bid 
224-230      9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238      x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242      x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132      
243-244      x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246      x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248      x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250      x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252      x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254      x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256      x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260      x(4) 
261      x Rule 144A Flag 
262-267      9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272       9(2)v9(3) Earnings Per Share - Diluted  
273      x Earnings Indicator - Diluted 
274-279      x(6) NAICS Code 
280-284      x(5) Announcement Sequence Code - First Dividend Data  
285-289      x(5) Announcement Sequence Code - Second Dividend Data  
290-292      x(3) Currency Code - First Dividend Data  
136       320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295      x(3) Currency Code - Second Dividend Data  
296-308      x(13) Reserved for future development  
309      x Moody's Quality Rating 
310      x Quote Source Code 
311      x CUSIP Check Digit 
312-314      x(3) Supplemental Issue Type Code 
315      x Shares Outstanding Indicator 
316-319      x(4) Reserved for internal use 
320      x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1                :g'
11                /08  320/216 Record Formats  135 
1-68                 x(80) Identification Data: 
1-8                 x(8) CUSIP Number/User Number 
9                 x Uniqueness Code: blank, 1 
10                 x Exchange Code 
 
11-16                 x(6) Ticker Symbol 
17-20                 x(4) SIC Code 
21-48                 x(28) Issuer Description 
49-68                 x(20) Issue Description 
69-107                 Pricing Data: 
69-72                 9(4) Pricing/Evaluation Date (mmdd) 
73-79                 9(7) Volume 
80-86                 9(4)v9(3) High/Ask 
87-93                 9(4)v9(3) Low/Bid 
94-100                 9(4)v9(3) Current Price/Evaluation 
101-107                 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132                 Indicators Data: 
108-111                 x(4) Status/Type Flag 
108                 x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109                 x Trade Type Code: 0-5, 8, 9, H, Z 
110                 x Issue Status Code 
111                 x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119                 x(8) Expiration Date (mmddccyy) 
120-125                 9(2)v9(4) Adjustment Factor 
126                 x Margin/Eligibility Code 
127-132                 x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152                 Earnings For Equities/Indices Data: 
133-134                 9(2) Earnings Per Share Month - Basic (mm) 
135-139                 9(2)v9(3) Earnings Per Share - Basic 
140                 x Earnings Indicator - Basic 
141-147                 9(7) Shares Outstanding 
148                 9 Indicated Annual Dividend (IAD) Modifier 
149-152                 9v9(3) Indicated Annual Dividend (IAD) 
153-184                 First Dividend Data: 
153-158                 9(2)v9(4) Dividend Amount/Rate 
159-164                 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170                 9(6) Record Date (mmddyy) 
171-176                 9(6) Payment Date (mmddyy) 
177                 x Payment Type Code 
178                 x Payment Order/Scaling Factor 
179                 x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180                 9 Revision/Late Code 
181                 9 Payment Frequency Code 
182                 x Liquidation/Return of Capital Flag  
8                 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183                 x Revision Indicator 
184                 9 Announcement Entry Code 
185-216                 Second Dividend Data: 
185-190                 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196                 9(6) 
Record Date (mmddyy) 
197-202                 9(6) 
Payment Date (mmddyy) 
203-208                 9(6) 
209                 x Payment Type Code 
210                 x Payment Order/Scaling Factor Code 
211                 x Tax Base Code 
212                 9 Revision/Late Code 
213                 9 Liquidation/Return of Capital Flag  
8                 = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214                 x Reserved for future development 
215                 x Revision Indicator 
216                 9 Announcement Entry Code 
217-320                 For 320 Service: 
217-223                 9(4)v9(3) Bid 
224-230                 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238                 x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242                 x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132                 
243-244                 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246                 x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248                 x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250                 x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252                 x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254                 x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256                 x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260                 x(4) 
261                 x Rule 144A Flag 
262-267                 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272                  9(2)v9(3) Earnings Per Share - Diluted  
273                 x Earnings Indicator - Diluted 
274-279                 x(6) NAICS Code 
280-284                 x(5) Announcement Sequence Code - First Dividend Data  
285-289                 x(5) Announcement Sequence Code - Second Dividend Data  
290-292                 x(3) Currency Code - First Dividend Data  
136                  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295                 x(3) Currency Code - Second Dividend Data  
296-308                 x(13) Reserved for future development  
309                 x Moody's Quality Rating 
310                 x Quote Source Code 
311                 x CUSIP Check Digit 
312-314                 x(3) Supplemental Issue Type Code 
315                 x Shares Outstanding Indicator 
316-319                 x(4) Reserved for internal use 
320                 x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1\t\t\t\t:g ; s:^\([^0-9]\):\t\t\t\t\1:g'
11tttt/08  320/216 Record Formats  135 
1-68tttt x(80) Identification Data: 
1-8tttt x(8) CUSIP Number/User Number 
9tttt x Uniqueness Code: blank, 1 
10tttt x Exchange Code 
tttt 
11-16tttt x(6) Ticker Symbol 
17-20tttt x(4) SIC Code 
21-48tttt x(28) Issuer Description 
49-68tttt x(20) Issue Description 
69-107tttt Pricing Data: 
69-72tttt 9(4) Pricing/Evaluation Date (mmdd) 
73-79tttt 9(7) Volume 
80-86tttt 9(4)v9(3) High/Ask 
87-93tttt 9(4)v9(3) Low/Bid 
94-100tttt 9(4)v9(3) Current Price/Evaluation 
101-107tttt 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132tttt Indicators Data: 
108-111tttt x(4) Status/Type Flag 
108tttt x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109tttt x Trade Type Code: 0-5, 8, 9, H, Z 
110tttt x Issue Status Code 
111tttt x Standard & Poor?s Common Stock Ranking or Preferred Stock 
ttttRating Code 
tttt For index records, pos. 112-126: Reserved for future development 
112-119tttt x(8) Expiration Date (mmddccyy) 
120-125tttt 9(2)v9(4) Adjustment Factor 
126tttt x Margin/Eligibility Code 
127-132tttt x(6) Date of Previous Price/Evaluation (mmddyy) 
tttt x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152tttt Earnings For Equities/Indices Data: 
133-134tttt 9(2) Earnings Per Share Month - Basic (mm) 
135-139tttt 9(2)v9(3) Earnings Per Share - Basic 
140tttt x Earnings Indicator - Basic 
141-147tttt 9(7) Shares Outstanding 
148tttt 9 Indicated Annual Dividend (IAD) Modifier 
149-152tttt 9v9(3) Indicated Annual Dividend (IAD) 
153-184tttt First Dividend Data: 
153-158tttt 9(2)v9(4) Dividend Amount/Rate 
159-164tttt 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170tttt 9(6) Record Date (mmddyy) 
171-176tttt 9(6) Payment Date (mmddyy) 
177tttt x Payment Type Code 
178tttt x Payment Order/Scaling Factor 
179tttt x Tax Base Code 
ttttIDSI REFERENCE MANUAL 
ttttPosition Format Data Field 
180tttt 9 Revision/Late Code 
181tttt 9 Payment Frequency Code 
182tttt x Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183tttt x Revision Indicator 
184tttt 9 Announcement Entry Code 
185-216tttt Second Dividend Data: 
185-190tttt 9(2)v9(4) Dividend Amount/Rate 
ttttEx-Distribution/Dividend Date (mmddyy) 
191-196tttt 9(6) 
ttttRecord Date (mmddyy) 
197-202tttt 9(6) 
ttttPayment Date (mmddyy) 
203-208tttt 9(6) 
209tttt x Payment Type Code 
210tttt x Payment Order/Scaling Factor Code 
211tttt x Tax Base Code 
212tttt 9 Revision/Late Code 
213tttt 9 Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214tttt x Reserved for future development 
215tttt x Revision Indicator 
216tttt 9 Announcement Entry Code 
217-320tttt For 320 Service: 
217-223tttt 9(4)v9(3) Bid 
224-230tttt 9(4)v9(3) Ask 
ttttBid/Ask Pricing Date (ccyymmdd) 
231-238tttt x(8) 
ttttYear (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242tttt x(4) 


ttttCentury (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
ttttor Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132tttt 
243-244tttt x(2) 
ttttCentury (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
ttttFirst Dividend Data field)  
245-246tttt x(2) 
ttttCentury (cc) of Record Date (pos. 165-170 in First Dividend Data 
ttttfield)  
247-248tttt x(2) 
ttttCentury (cc) of Payment Date (positions 171-176 in First Dividend 
ttttData field) 
249-250tttt x(2) 
ttttCentury (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
ttttSecond Dividend Data field)  
251-252tttt x(2) 
ttttCentury (cc) of Record Date (positions 197-202 in Second 
ttttDividend Data field)  
253-254tttt x(2) 
ttttCentury (cc) of Payment Date (positions 203-208 in Second 
ttttDividend Data field) 
255-256tttt x(2) 
ttttYear (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260tttt x(4) 
261tttt x Rule 144A Flag 
262-267tttt 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272tttt  9(2)v9(3) Earnings Per Share - Diluted  
273tttt x Earnings Indicator - Diluted 
274-279tttt x(6) NAICS Code 
280-284tttt x(5) Announcement Sequence Code - First Dividend Data  
285-289tttt x(5) Announcement Sequence Code - Second Dividend Data  
290-292tttt x(3) Currency Code - First Dividend Data  
136tttt  320/216 Record Formats  11/08 
ttttIDSI REFERENCE MANUAL 
ttttPosition Format Data Field 
293-295tttt x(3) Currency Code - Second Dividend Data  
296-308tttt x(13) Reserved for future development  
309tttt x Moody's Quality Rating 
310tttt x Quote Source Code 
311tttt x CUSIP Check Digit 
312-314tttt x(3) Supplemental Issue Type Code 
315tttt x Shares Outstanding Indicator 
316-319tttt x(4) Reserved for internal use 
320tttt x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1\t\t\t\t:g'  's:^\([^0-9]\):\t\t\t\t\1:g'
sed: s:^\([^0-9]\):\t\t\t\t\1:g: No such file or directory
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1\t\t\t\t:g' -e  's:^\([^0-9]\):\t\t\t\t\1:g'
11tttt/08  320/216 Record Formats  135 
1-68tttt x(80) Identification Data: 
1-8tttt x(8) CUSIP Number/User Number 
9tttt x Uniqueness Code: blank, 1 
10tttt x Exchange Code 
tttt 
11-16tttt x(6) Ticker Symbol 
17-20tttt x(4) SIC Code 
21-48tttt x(28) Issuer Description 
49-68tttt x(20) Issue Description 
69-107tttt Pricing Data: 
69-72tttt 9(4) Pricing/Evaluation Date (mmdd) 
73-79tttt 9(7) Volume 
80-86tttt 9(4)v9(3) High/Ask 
87-93tttt 9(4)v9(3) Low/Bid 
94-100tttt 9(4)v9(3) Current Price/Evaluation 
101-107tttt 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132tttt Indicators Data: 
108-111tttt x(4) Status/Type Flag 
108tttt x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109tttt x Trade Type Code: 0-5, 8, 9, H, Z 
110tttt x Issue Status Code 
111tttt x Standard & Poor?s Common Stock Ranking or Preferred Stock 
ttttRating Code 
tttt For index records, pos. 112-126: Reserved for future development 
112-119tttt x(8) Expiration Date (mmddccyy) 
120-125tttt 9(2)v9(4) Adjustment Factor 
126tttt x Margin/Eligibility Code 
127-132tttt x(6) Date of Previous Price/Evaluation (mmddyy) 
tttt x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152tttt Earnings For Equities/Indices Data: 
133-134tttt 9(2) Earnings Per Share Month - Basic (mm) 
135-139tttt 9(2)v9(3) Earnings Per Share - Basic 
140tttt x Earnings Indicator - Basic 
141-147tttt 9(7) Shares Outstanding 
148tttt 9 Indicated Annual Dividend (IAD) Modifier 
149-152tttt 9v9(3) Indicated Annual Dividend (IAD) 
153-184tttt First Dividend Data: 
153-158tttt 9(2)v9(4) Dividend Amount/Rate 
159-164tttt 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170tttt 9(6) Record Date (mmddyy) 
171-176tttt 9(6) Payment Date (mmddyy) 
177tttt x Payment Type Code 
178tttt x Payment Order/Scaling Factor 
179tttt x Tax Base Code 
ttttIDSI REFERENCE MANUAL 
ttttPosition Format Data Field 
180tttt 9 Revision/Late Code 
181tttt 9 Payment Frequency Code 
182tttt x Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183tttt x Revision Indicator 
184tttt 9 Announcement Entry Code 
185-216tttt Second Dividend Data: 
185-190tttt 9(2)v9(4) Dividend Amount/Rate 
ttttEx-Distribution/Dividend Date (mmddyy) 
191-196tttt 9(6) 
ttttRecord Date (mmddyy) 
197-202tttt 9(6) 
ttttPayment Date (mmddyy) 
203-208tttt 9(6) 
209tttt x Payment Type Code 
210tttt x Payment Order/Scaling Factor Code 
211tttt x Tax Base Code 
212tttt 9 Revision/Late Code 
213tttt 9 Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214tttt x Reserved for future development 
215tttt x Revision Indicator 
216tttt 9 Announcement Entry Code 
217-320tttt For 320 Service: 
217-223tttt 9(4)v9(3) Bid 
224-230tttt 9(4)v9(3) Ask 
ttttBid/Ask Pricing Date (ccyymmdd) 
231-238tttt x(8) 
ttttYear (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242tttt x(4) 


ttttCentury (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
ttttor Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132tttt 
243-244tttt x(2) 
ttttCentury (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
ttttFirst Dividend Data field)  
245-246tttt x(2) 
ttttCentury (cc) of Record Date (pos. 165-170 in First Dividend Data 
ttttfield)  
247-248tttt x(2) 
ttttCentury (cc) of Payment Date (positions 171-176 in First Dividend 
ttttData field) 
249-250tttt x(2) 
ttttCentury (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
ttttSecond Dividend Data field)  
251-252tttt x(2) 
ttttCentury (cc) of Record Date (positions 197-202 in Second 
ttttDividend Data field)  
253-254tttt x(2) 
ttttCentury (cc) of Payment Date (positions 203-208 in Second 
ttttDividend Data field) 
255-256tttt x(2) 
ttttYear (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260tttt x(4) 
261tttt x Rule 144A Flag 
262-267tttt 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272tttt  9(2)v9(3) Earnings Per Share - Diluted  
273tttt x Earnings Indicator - Diluted 
274-279tttt x(6) NAICS Code 
280-284tttt x(5) Announcement Sequence Code - First Dividend Data  
285-289tttt x(5) Announcement Sequence Code - Second Dividend Data  
290-292tttt x(3) Currency Code - First Dividend Data  
136tttt  320/216 Record Formats  11/08 
ttttIDSI REFERENCE MANUAL 
ttttPosition Format Data Field 
293-295tttt x(3) Currency Code - Second Dividend Data  
296-308tttt x(13) Reserved for future development  
309tttt x Moody's Quality Rating 
310tttt x Quote Source Code 
311tttt x CUSIP Check Digit 
312-314tttt x(3) Supplemental Issue Type Code 
315tttt x Shares Outstanding Indicator 
316-319tttt x(4) Reserved for internal use 
320tttt x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1\t\t\t\t:g' 
11tttt/08  320/216 Record Formats  135 
1-68tttt x(80) Identification Data: 
1-8tttt x(8) CUSIP Number/User Number 
9tttt x Uniqueness Code: blank, 1 
10tttt x Exchange Code 
 
11-16tttt x(6) Ticker Symbol 
17-20tttt x(4) SIC Code 
21-48tttt x(28) Issuer Description 
49-68tttt x(20) Issue Description 
69-107tttt Pricing Data: 
69-72tttt 9(4) Pricing/Evaluation Date (mmdd) 
73-79tttt 9(7) Volume 
80-86tttt 9(4)v9(3) High/Ask 
87-93tttt 9(4)v9(3) Low/Bid 
94-100tttt 9(4)v9(3) Current Price/Evaluation 
101-107tttt 9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132tttt Indicators Data: 
108-111tttt x(4) Status/Type Flag 
108tttt x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109tttt x Trade Type Code: 0-5, 8, 9, H, Z 
110tttt x Issue Status Code 
111tttt x Standard & Poor?s Common Stock Ranking or Preferred Stock 
Rating Code 
 For index records, pos. 112-126: Reserved for future development 
112-119tttt x(8) Expiration Date (mmddccyy) 
120-125tttt 9(2)v9(4) Adjustment Factor 
126tttt x Margin/Eligibility Code 
127-132tttt x(6) Date of Previous Price/Evaluation (mmddyy) 
 x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152tttt Earnings For Equities/Indices Data: 
133-134tttt 9(2) Earnings Per Share Month - Basic (mm) 
135-139tttt 9(2)v9(3) Earnings Per Share - Basic 
140tttt x Earnings Indicator - Basic 
141-147tttt 9(7) Shares Outstanding 
148tttt 9 Indicated Annual Dividend (IAD) Modifier 
149-152tttt 9v9(3) Indicated Annual Dividend (IAD) 
153-184tttt First Dividend Data: 
153-158tttt 9(2)v9(4) Dividend Amount/Rate 
159-164tttt 9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170tttt 9(6) Record Date (mmddyy) 
171-176tttt 9(6) Payment Date (mmddyy) 
177tttt x Payment Type Code 
178tttt x Payment Order/Scaling Factor 
179tttt x Tax Base Code 
IDSI REFERENCE MANUAL 
Position Format Data Field 
180tttt 9 Revision/Late Code 
181tttt 9 Payment Frequency Code 
182tttt x Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183tttt x Revision Indicator 
184tttt 9 Announcement Entry Code 
185-216tttt Second Dividend Data: 
185-190tttt 9(2)v9(4) Dividend Amount/Rate 
Ex-Distribution/Dividend Date (mmddyy) 
191-196tttt 9(6) 
Record Date (mmddyy) 
197-202tttt 9(6) 
Payment Date (mmddyy) 
203-208tttt 9(6) 
209tttt x Payment Type Code 
210tttt x Payment Order/Scaling Factor Code 
211tttt x Tax Base Code 
212tttt 9 Revision/Late Code 
213tttt 9 Liquidation/Return of Capital Flag  
8tttt = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214tttt x Reserved for future development 
215tttt x Revision Indicator 
216tttt 9 Announcement Entry Code 
217-320tttt For 320 Service: 
217-223tttt 9(4)v9(3) Bid 
224-230tttt 9(4)v9(3) Ask 
Bid/Ask Pricing Date (ccyymmdd) 
231-238tttt x(8) 
Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242tttt x(4) 


Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132tttt 
243-244tttt x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
First Dividend Data field)  
245-246tttt x(2) 
Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
field)  
247-248tttt x(2) 
Century (cc) of Payment Date (positions 171-176 in First Dividend 
Data field) 
249-250tttt x(2) 
Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
Second Dividend Data field)  
251-252tttt x(2) 
Century (cc) of Record Date (positions 197-202 in Second 
Dividend Data field)  
253-254tttt x(2) 
Century (cc) of Payment Date (positions 203-208 in Second 
Dividend Data field) 
255-256tttt x(2) 
Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260tttt x(4) 
261tttt x Rule 144A Flag 
262-267tttt 9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272tttt  9(2)v9(3) Earnings Per Share - Diluted  
273tttt x Earnings Indicator - Diluted 
274-279tttt x(6) NAICS Code 
280-284tttt x(5) Announcement Sequence Code - First Dividend Data  
285-289tttt x(5) Announcement Sequence Code - Second Dividend Data  
290-292tttt x(3) Currency Code - First Dividend Data  
136tttt  320/216 Record Formats  11/08 
IDSI REFERENCE MANUAL 
Position Format Data Field 
293-295tttt x(3) Currency Code - Second Dividend Data  
296-308tttt x(13) Reserved for future development  
309tttt x Moody's Quality Rating 
310tttt x Quote Source Code 
311tttt x CUSIP Check Digit 
312-314tttt x(3) Supplemental Issue Type Code 
315tttt x Shares Outstanding Indicator 
316-319tttt x(4) Reserved for internal use 
320tttt x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1             :g' -e  's:^\([^0-9]\):             \1:g'
11             /08  320/216 Record Formats  135 
1-68              x(80) Identification Data: 
1-8              x(8) CUSIP Number/User Number 
9              x Uniqueness Code: blank, 1 
10              x Exchange Code 
              
11-16              x(6) Ticker Symbol 
17-20              x(4) SIC Code 
21-48              x(28) Issuer Description 
49-68              x(20) Issue Description 
69-107              Pricing Data: 
69-72              9(4) Pricing/Evaluation Date (mmdd) 
73-79              9(7) Volume 
80-86              9(4)v9(3) High/Ask 
87-93              9(4)v9(3) Low/Bid 
94-100              9(4)v9(3) Current Price/Evaluation 
101-107              9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132              Indicators Data: 
108-111              x(4) Status/Type Flag 
108              x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109              x Trade Type Code: 0-5, 8, 9, H, Z 
110              x Issue Status Code 
111              x Standard & Poor?s Common Stock Ranking or Preferred Stock 
             Rating Code 
              For index records, pos. 112-126: Reserved for future development 
112-119              x(8) Expiration Date (mmddccyy) 
120-125              9(2)v9(4) Adjustment Factor 
126              x Margin/Eligibility Code 
127-132              x(6) Date of Previous Price/Evaluation (mmddyy) 
              x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152              Earnings For Equities/Indices Data: 
133-134              9(2) Earnings Per Share Month - Basic (mm) 
135-139              9(2)v9(3) Earnings Per Share - Basic 
140              x Earnings Indicator - Basic 
141-147              9(7) Shares Outstanding 
148              9 Indicated Annual Dividend (IAD) Modifier 
149-152              9v9(3) Indicated Annual Dividend (IAD) 
153-184              First Dividend Data: 
153-158              9(2)v9(4) Dividend Amount/Rate 
159-164              9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170              9(6) Record Date (mmddyy) 
171-176              9(6) Payment Date (mmddyy) 
177              x Payment Type Code 
178              x Payment Order/Scaling Factor 
179              x Tax Base Code 
             IDSI REFERENCE MANUAL 
             Position Format Data Field 
180              9 Revision/Late Code 
181              9 Payment Frequency Code 
182              x Liquidation/Return of Capital Flag  
8              = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183              x Revision Indicator 
184              9 Announcement Entry Code 
185-216              Second Dividend Data: 
185-190              9(2)v9(4) Dividend Amount/Rate 
             Ex-Distribution/Dividend Date (mmddyy) 
191-196              9(6) 
             Record Date (mmddyy) 
197-202              9(6) 
             Payment Date (mmddyy) 
203-208              9(6) 
209              x Payment Type Code 
210              x Payment Order/Scaling Factor Code 
211              x Tax Base Code 
212              9 Revision/Late Code 
213              9 Liquidation/Return of Capital Flag  
8              = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214              x Reserved for future development 
215              x Revision Indicator 
216              9 Announcement Entry Code 
217-320              For 320 Service: 
217-223              9(4)v9(3) Bid 
224-230              9(4)v9(3) Ask 
             Bid/Ask Pricing Date (ccyymmdd) 
231-238              x(8) 
             Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242              x(4) 


             Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
             or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132              
243-244              x(2) 
             Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
             First Dividend Data field)  
245-246              x(2) 
             Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
             field)  
247-248              x(2) 
             Century (cc) of Payment Date (positions 171-176 in First Dividend 
             Data field) 
249-250              x(2) 
             Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
             Second Dividend Data field)  
251-252              x(2) 
             Century (cc) of Record Date (positions 197-202 in Second 
             Dividend Data field)  
253-254              x(2) 
             Century (cc) of Payment Date (positions 203-208 in Second 
             Dividend Data field) 
255-256              x(2) 
             Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260              x(4) 
261              x Rule 144A Flag 
262-267              9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272               9(2)v9(3) Earnings Per Share - Diluted  
273              x Earnings Indicator - Diluted 
274-279              x(6) NAICS Code 
280-284              x(5) Announcement Sequence Code - First Dividend Data  
285-289              x(5) Announcement Sequence Code - Second Dividend Data  
290-292              x(3) Currency Code - First Dividend Data  
136               320/216 Record Formats  11/08 
             IDSI REFERENCE MANUAL 
             Position Format Data Field 
293-295              x(3) Currency Code - Second Dividend Data  
296-308              x(13) Reserved for future development  
309              x Moody's Quality Rating 
310              x Quote Source Code 
311              x CUSIP Check Digit 
312-314              x(3) Supplemental Issue Type Code 
315              x Shares Outstanding Indicator 
316-319              x(4) Reserved for internal use 
320              x Record Layout Code: F 
bash-3.2$ cat ongoing_description.txt | sed -e 's:^\([0-9]\{1,\}[-]\{0,1\}[0-9]*\):\1             :g' -e  's:^\([^0-9]\):                      \1:g'
11             /08  320/216 Record Formats  135 
1-68              x(80) Identification Data: 
1-8              x(8) CUSIP Number/User Number 
9              x Uniqueness Code: blank, 1 
10              x Exchange Code 
                       
11-16              x(6) Ticker Symbol 
17-20              x(4) SIC Code 
21-48              x(28) Issuer Description 
49-68              x(20) Issue Description 
69-107              Pricing Data: 
69-72              9(4) Pricing/Evaluation Date (mmdd) 
73-79              9(7) Volume 
80-86              9(4)v9(3) High/Ask 
87-93              9(4)v9(3) Low/Bid 
94-100              9(4)v9(3) Current Price/Evaluation 
101-107              9(4)v9(3) Previous Price/Evaluation (Open Price, optional) 
108-132              Indicators Data: 
108-111              x(4) Status/Type Flag 
108              x Issue Type Code: 0-2, 4, 7, 8, A, E-G, Q, % 
109              x Trade Type Code: 0-5, 8, 9, H, Z 
110              x Issue Status Code 
111              x Standard & Poor?s Common Stock Ranking or Preferred Stock 
                      Rating Code 
                       For index records, pos. 112-126: Reserved for future development 
112-119              x(8) Expiration Date (mmddccyy) 
120-125              9(2)v9(4) Adjustment Factor 
126              x Margin/Eligibility Code 
127-132              x(6) Date of Previous Price/Evaluation (mmddyy) 
                       x(6) New CUSIP Issuer Number (when Issue Status is B, F or R) 
133-152              Earnings For Equities/Indices Data: 
133-134              9(2) Earnings Per Share Month - Basic (mm) 
135-139              9(2)v9(3) Earnings Per Share - Basic 
140              x Earnings Indicator - Basic 
141-147              9(7) Shares Outstanding 
148              9 Indicated Annual Dividend (IAD) Modifier 
149-152              9v9(3) Indicated Annual Dividend (IAD) 
153-184              First Dividend Data: 
153-158              9(2)v9(4) Dividend Amount/Rate 
159-164              9(6) Ex-Distribution/Dividend Date (mmddyy) 
165-170              9(6) Record Date (mmddyy) 
171-176              9(6) Payment Date (mmddyy) 
177              x Payment Type Code 
178              x Payment Order/Scaling Factor 
179              x Tax Base Code 
                      IDSI REFERENCE MANUAL 
                      Position Format Data Field 
180              9 Revision/Late Code 
181              9 Payment Frequency Code 
182              x Liquidation/Return of Capital Flag  
8              = Liquidation, 9 = Return of Capital, 0 = Not applicable 
183              x Revision Indicator 
184              9 Announcement Entry Code 
185-216              Second Dividend Data: 
185-190              9(2)v9(4) Dividend Amount/Rate 
                      Ex-Distribution/Dividend Date (mmddyy) 
191-196              9(6) 
                      Record Date (mmddyy) 
197-202              9(6) 
                      Payment Date (mmddyy) 
203-208              9(6) 
209              x Payment Type Code 
210              x Payment Order/Scaling Factor Code 
211              x Tax Base Code 
212              9 Revision/Late Code 
213              9 Liquidation/Return of Capital Flag  
8              = Liquidation, 9 = Return of Capital, 0 = Not applicable 
214              x Reserved for future development 
215              x Revision Indicator 
216              9 Announcement Entry Code 
217-320              For 320 Service: 
217-223              9(4)v9(3) Bid 
224-230              9(4)v9(3) Ask 
                      Bid/Ask Pricing Date (ccyymmdd) 
231-238              x(8) 
                      Year (ccyy) of Pricing/Evaluation Date (positions 69-72) 
239-242              x(4) 


                      Century (cc) of Date of Previous Price/Evaluation (pos. 127-132) 
                      or Zero-filled, if Cross-Reference CUSIP Number in positions 127- 
132              
243-244              x(2) 
                      Century (cc) of Ex-Distribution/Dividend Date (pos. 159-164 in 
                      First Dividend Data field)  
245-246              x(2) 
                      Century (cc) of Record Date (pos. 165-170 in First Dividend Data 
                      field)  
247-248              x(2) 
                      Century (cc) of Payment Date (positions 171-176 in First Dividend 
                      Data field) 
249-250              x(2) 
                      Century (cc) of Ex-Distribution/Dividend Date (pos. 191-196 in 
                      Second Dividend Data field)  
251-252              x(2) 
                      Century (cc) of Record Date (positions 197-202 in Second 
                      Dividend Data field)  
253-254              x(2) 
                      Century (cc) of Payment Date (positions 203-208 in Second 
                      Dividend Data field) 
255-256              x(2) 
                      Year (ccyy) of Basic Earnings Per Share (positions 133-134) 
257-260              x(4) 
261              x Rule 144A Flag 
262-267              9(6) Earnings Per Share Month - Diluted  (ccyymm) 
268-272               9(2)v9(3) Earnings Per Share - Diluted  
273              x Earnings Indicator - Diluted 
274-279              x(6) NAICS Code 
280-284              x(5) Announcement Sequence Code - First Dividend Data  
285-289              x(5) Announcement Sequence Code - Second Dividend Data  
290-292              x(3) Currency Code - First Dividend Data  
136               320/216 Record Formats  11/08 
                      IDSI REFERENCE MANUAL 
                      Position Format Data Field 
293-295              x(3) Currency Code - Second Dividend Data  
296-308              x(13) Reserved for future development  
309              x Moody's Quality Rating 
310              x Quote Source Code 
311              x CUSIP Check Digit 
312-314              x(3) Supplemental Issue Type Code 
315              x Shares Outstanding Indicator 
316-319              x(4) Reserved for internal use 
320              x Record Layout Code: F 
bash-3.2$ whois paddymullen.com

Whois Server Version 2.0

Domain names in the .com and .net domains can now be registered
with many different competing registrars. Go to http://www.internic.net
for detailed information.

   Domain Name: PADDYMULLEN.COM
   Registrar: PAIRNIC
   Whois Server: whois.pairnic.com
   Referral URL: http://www.pairnic.com
   Name Server: NS427.PAIR.COM
   Name Server: NS5.NS0.COM
   Status: clientHold
   Updated Date: 22-jan-2009
   Creation Date: 21-jan-2007
   Expiration Date: 21-jan-2010

>>> Last update of whois database: Fri, 23 Jan 2009 18:00:33 EST <<<

NOTICE: The expiration date displayed in this record is the date the
registrar's sponsorship of the domain name registration in the registry is
currently set to expire. This date does not necessarily reflect the expiration
date of the domain name registrant's agreement with the sponsoring
registrar.  Users may consult the sponsoring registrar's Whois database to
view the registrar's reported date of expiration for this registration.

TERMS OF USE: You are not authorized to access or query our Whois
database through the use of electronic processes that are high-volume and
automated except as reasonably necessary to register domain names or
modify existing registrations; the Data in VeriSign Global Registry
Services' ("VeriSign") Whois database is provided by VeriSign for
information purposes only, and to assist persons in obtaining information
about or related to a domain name registration record. VeriSign does not
guarantee its accuracy. By submitting a Whois query, you agree to abide
by the following terms of use: You agree that you may use this Data only
for lawful purposes and that under no circumstances will you use this Data
to: (1) allow, enable, or otherwise support the transmission of mass
unsolicited, commercial advertising or solicitations via e-mail, telephone,
or facsimile; or (2) enable high volume, automated, electronic processes
that apply to VeriSign (or its computer systems). The compilation,
repackaging, dissemination or other use of this Data is expressly
prohibited without the prior written consent of VeriSign. You agree not to
use electronic processes that are automated and high-volume to access or
query the Whois database except as reasonably necessary to register
domain names or modify existing registrations. VeriSign reserves the right
to restrict your access to the Whois database in its sole discretion to ensure
operational stability.  VeriSign may restrict or terminate your access to the
Whois database for failure to abide by these terms of use. VeriSign
reserves the right to modify these terms at any time.

The Registry database contains ONLY .COM, .NET, .EDU domains and
Registrars.
Registrant:
  F1 Database
  5021 Seminary Rd
  Apt 715
  Alexandria, VA 22310
  US

  yorkpaddy4@yahoo.com
   +1.7039276790

Domain Name: PADDYMULLEN.COM

Administrative & Technical Contact:
  Patrick Mullen
  F1 Database
  5021 Seminary Rd
  Apt 715
  Alexandria, VA 22310
  US

  yorkpaddy4@yahoo.com
   +1.7039276790

Domain Name Servers:
  NS5.NS0.COM
  NS427.PAIR.COM

Transfer-Lock Status: ENABLED

 Created:     January 21, 2007
Modified:     January 22, 2009
 Expires:     January 21, 2009

NOTICE AND TERMS OF USE: By submitting a WHOIS query, you agree to abide by the
following terms of use: You agree that you may use this Data only for lawful
purposes and that under no circumstances will you use this Data to: (a) allow,
enable, or otherwise support the transmission by e-mail, telephone, or
facsimile of mass, unsolicited, commercial advertising or solicitations; or (b)
enable high volume, automated, electronic processes that send queries or data
to the systems of any Registry Operator or ICANN-Accredited registrar, except
as reasonably necessary to register domain names or modify existing
registrations. pairNIC reserves all rights and remedies it now has or may have
in the future, including, but not limited to, the right to terminate your
access to the WHOIS database in its sole discretion, for any violations by you
of these terms of use, including without limitation, for excessive querying of
the WHOIS database or for failure to otherwise abide by these terms of use.
pairNIC reserves the right to modify these terms at any time.

** Register Now at http://www.pairNIC.com/ **

bash-3.2$ declare -i a
bash-3.2$ a=3
bash-3.2$ declare -i b
bash-3.2$ b=4
bash-3.2$ c=a-b
bash-3.2$ echo $c
a-b
bash-3.2$ declare -i c
bash-3.2$ c=a-b
bash-3.2$ echo $c
-1
bash-3.2$ a=`wc -l`
  C-c C-c
bash-3.2$ a=`ls |wc -l`
bash-3.2$ echo $a
14
bash-3.2$ c=a-b
bash-3.2$ echo $c
10
bash-3.2$ pwd
/Users/patrickmullen/_code_qr/import/branches/081122/pyBase/qr/importer/idc
bash-3.2$ cd ~/temp/downloads/rxvt/urxvt-my-conf/
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
Usage: grep [OPTION]... PATTERN [FILE]...
Try `grep --help' for more information.
./strip_to_orig_file_only.bash: line 6: let: first_orig_line=: syntax error: operand expected (error token is "=")

27710
./strip_to_orig_file_only.bash: line 13: 27710-: syntax error: operand expected (error token is "-")

bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
Usage: grep [OPTION]... PATTERN [FILE]...
Try `grep --help' for more information.
./strip_to_orig_file_only.bash: line 6: let: first_orig_line=: syntax error: operand expected (error token is "=")

27710
./strip_to_orig_file_only.bash: line 13: 27710-: syntax error: operand expected (error token is "-")

bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
./strip_to_orig_file_only.bash: command substitution: line 6: unexpected EOF while looking for matching `"'
./strip_to_orig_file_only.bash: command substitution: line 7: syntax error: unexpected end of file
./strip_to_orig_file_only.bash: line 6: let: first_orig_line=: syntax error: operand expected (error token is "=")

27710
./strip_to_orig_file_only.bash: line 13: 27710-: syntax error: operand expected (error token is "-")

bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
./strip_to_orig_file_only.bash: command substitution: line 7: unexpected EOF while looking for matching `"'
./strip_to_orig_file_only.bash: command substitution: line 8: syntax error: unexpected end of file
0
27710
27710
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
27710 src/command.C_exp.C
./strip_to_orig_file_only.bash: command substitution: line 8: unexpected EOF while looking for matching `"'
./strip_to_orig_file_only.bash: command substitution: line 9: syntax error: unexpected end of file
0
27710
27710
bash-3.2$ wc -l src/command.C_exp.C
   27710 src/command.C_exp.C
bash-3.2$ wc -l src/command.C_exp.C
   27710 src/command.C_exp.C
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
27710 src/command.C_exp.C
./strip_to_orig_file_only.bash: command substitution: line 8: unexpected EOF while looking for matching `"'
./strip_to_orig_file_only.bash: command substitution: line 9: syntax error: unexpected end of file
0
27710
27710
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
27710 src/command.C_exp.C
Usage: grep [OPTION]... PATTERN [FILE]...
Try `grep --help' for more information.
0
27710
27710
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C
27710 src/command.C_exp.C
Usage: grep [OPTION]... PATTERN [FILE]...
Try `grep --help' for more information.
0
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C
27710 src/command.C_exp.C
26705
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C
27710 src/command.C_exp.C
cat src/command.C_exp.C | grep -n '[#] [0-9]*'
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C | head -n 10
27710 src/command.C_exp.C
cat src/command.C_exp.C | grep -n '[#] [0-9]*'
./strip_to_orig_file_only.bash: line 12: cat src/command.C_exp.C | grep -n '[#] [0-9]*' : No such file or directory

bash-3.2$ a="ls"
bash-3.2$ echo `"$a"`
bash: 0: command not found

bash-3.2$ cat src/command.C_exp.C | grep -n '[#] [0-9]*' | head -n 10
1:# 1 "command.C"
2:# 1 "/Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf/src//"
3:# 1 "<built-in>"
4:# 1 "<command line>"
5:# 1 "command.C"
54:# 1 "../config.h" 1
474:/* # undef _ALL_SOURCE */
517:# 50 "command.C" 2
518:# 1 "rxvt.h" 1
522:# 1 "/usr/include/c++/4.0.0/cstdio" 1 3
bash-3.2$ cat src/command.C_exp.C | grep -n '[#] [0-9]*' | tail -n 20
25649:# 1495 "command.C"
25744:# 1636 "command.C"
25767:# 1686 "command.C"
25770:# 1705 "command.C"
25778:# 1736 "command.C"
25803:# 1779 "command.C"
25811:# 1794 "command.C"
25813:# 1829 "command.C"
25848:# 1888 "command.C"
26072:# 2123 "command.C"
26099:# 2185 "command.C"
26434:# 2532 "command.C"
26667:  int arg[32 /* max # of args for esc sequences */] = { };
26692:          if (nargs < 32 /* max # of args for esc sequences */)
26705:  if (nargs < 32 /* max # of args for esc sequences */)
26977:# 3171 "command.C"
27217:# 3468 "command.C"
27221:# 3484 "command.C"
27252:# 3546 "command.C"
27610:# 3926 "command.C"
bash-3.2$ cat src/command.C_exp.C | grep -n '^[#] [0-9]*' | tail -n 20
25497:# 1312 "command.C"
25561:# 1384 "command.C"
25620:# 1451 "command.C"
25649:# 1495 "command.C"
25744:# 1636 "command.C"
25767:# 1686 "command.C"
25770:# 1705 "command.C"
25778:# 1736 "command.C"
25803:# 1779 "command.C"
25811:# 1794 "command.C"
25813:# 1829 "command.C"
25848:# 1888 "command.C"
26072:# 2123 "command.C"
26099:# 2185 "command.C"
26434:# 2532 "command.C"
26977:# 3171 "command.C"
27217:# 3468 "command.C"
27221:# 3484 "command.C"
27252:# 3546 "command.C"
27610:# 3926 "command.C"
bash-3.2$ cat src/command.C_exp.C | grep -n '^[#] [0-9]*' | grep -v "command.C" |tail -n 20
23585:# 572 "rxvt.h"
23625:# 626 "rxvt.h"
23627:# 658 "rxvt.h"
23694:# 771 "rxvt.h"
23856:# 1 "optinc.h" 1
23920:# 933 "rxvt.h" 2
24045:# 1072 "rxvt.h"
24070:# 1104 "rxvt.h"
24099:# 1147 "rxvt.h"
24122:# 1185 "rxvt.h"
24141:# 1223 "rxvt.h"
24226:# 1316 "rxvt.h"
24385:# 1 "rxvtperl.h" 1
24390:# 1 "version.h" 1
24393:# 1 "command.h" 1
24402:# 48 "command.h"
24428:# 1 "/usr/include/c++/4.0.0/csignal" 1 3
24476:# 48 "/usr/include/c++/4.0.0/csignal" 3
24478:# 1 "/usr/include/signal.h" 1 3 4
24535:# 50 "/usr/include/c++/4.0.0/csignal" 2 3
bash-3.2$ cat src/command.C_exp.C | grep -n '^[#] [0-9]*' | grep -v "command.C" |tail -n 1
24535:# 50 "/usr/include/c++/4.0.0/csignal" 2 3
bash-3.2$ cat src/command.C_exp.C | grep -n '^[#] [0-9]*' | grep -v "command.C" |tail -n 1
24535:# 50 "/usr/include/c++/4.0.0/csignal" 2 3
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C | head -n 10
24535
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C 
24535
27710
3175
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C  | wc -l
    3178
bash-3.2$ clean-file.bash src/command.C
bash: clean-file.bash: command not found
bash-3.2$ chmod +x clean-file.bash
bash-3.2$ ./clean-file.bash src/command.C
src/command.C
bash-3.2$ ./clean-file.bash src/command.C
src/command.C_exp.C
bash-3.2$ ./clean-file.bash src/command.C
.C
./clean-file.bash: line 25: ./strip_to_orig_file_only: No such file or directory
bash-3.2$ ./clean-file.bash src/command.C
.C
bash-3.2$ ls
#README.configure#		Changes				Makefile.in			aclocal.m4			clean-file.bash~		config.log			configure.ac			multi-line.test			remove-comment.bash		strip_to_orig_file_only.bash~
#my-minimal-config-flags.txt#	INSTALL				README.FAQ			autoconf			config.guess			config.status			doc				multi-line.test~		remove-comment.bash~		update_ptytty
COPYING				MANIFEST			README.configure		autogen.sh			config.h			config.sub			install-sh			my-convert.bash			src
CVS				Makefile			W11				clean-file.bash			config.h.in			configure			libev				ptytty.m4			strip_to_orig_file_only.bash
bash-3.2$ cat .C
bash-3.2$ ls
#README.configure#		Changes				Makefile.in			aclocal.m4			clean-file.bash~		config.log			configure.ac			multi-line.test			print_after.bash~		src
#my-minimal-config-flags.txt#	INSTALL				README.FAQ			autoconf			config.guess			config.status			doc				multi-line.test~		ptytty.m4			strip_to_orig_file_only.bash
COPYING				MANIFEST			README.configure		autogen.sh			config.h			config.sub			install-sh			my-convert.bash			remove-comment.bash		strip_to_orig_file_only.bash~
CVS				Makefile			W11				clean-file.bash			config.h.in			configure			libev				print_after.bash		remove-comment.bash~		update_ptytty
bash-3.2$ chmod +x print_after.bash
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C

// Get rid of those macros defined in <signal.h> in lieu of real functions.


namespace std
{
  using ::sig_atomic_t;
  using ::signal;
  using ::raise;
}
# 60 "command.C" 2





/*----------------------------------------------------------------------*/
# 78 "command.C"
static unsigned short iso14755_symtab[] = {
  // keysym,		unicode
  0xff51 /* Move left, left arrow */, 0x2190,
  0xff96, 0x2190,
  0xff52 /* Move up, up arrow */, 0x2191,
  0xff97, 0x2191,
  0xff53 /* Move right, right arrow */, 0x2192,
  0xff98, 0x2192,
  0xff54 /* Move down, down arrow */, 0x2193,
  0xff99, 0x2193,
  0xff0a /* Linefeed, LF */, 0x21b4,
  0xff0d /* Return, enter */, 0x21b5,
  0xff8d /* Enter */, 0x21b5,

  0xff55 /* Prior, previous */, 0x21de,
  0xff56 /* Next */, 0x21df,
  0xff09, 0x21e5,
  0xfe20, 0x21e6,
  0xffe1 /* Left shift */, 0x21e7,
  0xffe2 /* Right shift */, 0x21e7,

  0xffe6 /* Shift lock */, 0x21eb,
  0xfe01, 0x21eb,
  0xffe5 /* Caps lock */, 0x21ec,
  0xff7f, 0x21ed,
  0xfe03, 0x21ee,
  0xfe05, 0x21ef,
  0xfe07, 0x21f0,
  0xff50, 0x21f1,
  0xff57 /* EOL */, 0x21f2,

  0xff62 /* Execute, run, do */, 0x2318,
  0xff58 /* BOL */, 0x2320,
  0xffff /* Delete, rubout */, 0x2326,
  0xff0b, 0x2327,
  0xff08 /* Back space, back char */, 0x232b,
  0xff63 /* Insert, insert here */, 0x2380,
  0xffe3 /* Left control */, 0x2388,
  0xffe4 /* Right control */, 0x2388,
  0xff13 /* Pause, hold */, 0x2389,
  0xff6b, 0x238a,
  0xff1b, 0x238b,
  0xff65, 0x238c,
  0xff61, 0x2399,

  0x0020 /* U+0020 SPACE */, 0x2423,


  0xff9a, 0x21de,
  0xff9b, 0x21df,
  0xff9d, 0x2320,
  0xff9e, 0x2380,
  0xff9f, 0x2326,
  0xff80 /* Space */, 0x2422,

  0,
};

void
rxvt_term::iso14755_54 (int x, int y)
{
  x = ((int32_t)((int32_t)(x)) / (int32_t)fwidth);
  y = ((int32_t)((int32_t)(y)) / (int32_t)fheight);

  if (!((unsigned int)(x) - (unsigned int)(0) < (unsigned int)(ncol) - (unsigned int)(0))
      || !((unsigned int)(y) - (unsigned int)(0) < (unsigned int)(nrow) - (unsigned int)(0)))
    return;

  for (;;)
    {
      const line_t &l = (this)->row_buf [(((((this))->term_start + int(y + view_start)) + (((this))->total_rows)) % (((this))->total_rows))];

      text_t t = l.t[x];

      if (t != NOCHAR || !x)
        {
          iso14755_51 (l.t[x], l.r[x], x, y);
          iso14755buf = 0x10000000UL /* code feedback (section 5.4)*/;
          break;
        }

      x--;
    }
}

void
rxvt_term::iso14755_51 (unicode_t ch, rend_t r, int x, int y)
{
  rxvt_fontset *fs = (this)->fontset[0];
  rxvt_font *f = (*fs)[fs->find_font (ch)];
  wchar_t *chr, *alloc, ch2, *fname;
  int len;

  fname = rxvt_utf8towcs (f->name);
# 182 "command.C"
    {
      ch2 = ch;

      alloc = 0;
      chr = &ch2;
      len = 1;
    }

  char attr[80]; // plenty

  sprintf (attr, "%08x = fg %d bg %d%s%s%s%s%s%s",
           (int)r,
           fgcolor_of (r), bgcolor_of (r),
           r & 0x00004000UL /* value 1*/ ? " bold" : "",
           r & 0x00008000UL /* value 2*/ ? " italic" : "",
           r & 0x00010000UL /* blink*/ ? " blink" : "",
           r & 0x00020000UL /* reverse video*/ ? " rvid" : "",
           r & 0x00040000UL /* underline*/ ? " uline" : "",
           r & 0x80000000UL /* be careful when drawing these */ ? " careful" : "");

  int width = wcswidth (fname, wcslen (fname));

  max_it (width, 8+5); // for char + hex
  max_it (width, (strlen)(attr));

  if (y >= 0)
    {
      y = (y >= nrow - len - 4 && x < width + 2) ? 0 : -1;
      x = 0;
    }

  scr_overlay_new (x, y, width, len + 2);

  r = ((((0 | Color_Black | (Color_Yellow << 7 /* 0 .. maxTermCOLOR*/))) & ~(0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) | (((((r) & (0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) >> 14)) << 14));

  for (int y = 0; y < len; y++)
    {
      char buf[9];

      ch = *chr++;

      sprintf (buf, "%8x", ch);
      scr_overlay_set (0, y, buf);
      scr_overlay_set (9, y, '=');

      if (ch >= 0x10000)
        ch = 0xfffd;

      scr_overlay_set (11, y, ch, r);

      if ((((unsigned int)(ch) - (unsigned int)(0x20) <= (unsigned int)(0x7e) - (unsigned int)(0x20)) ? 1 : wcwidth (ch)) >= 2)
        scr_overlay_set (12, y, NOCHAR, r);
    }

//  {
//    char buf[4+4+3+1];
//    snprintf (buf, sizeof (buf), "(%.4d|%.4d)", x, y);
//    scr_overlay_set (0, 0, buf);
//  }
  scr_overlay_set (0, len , attr);
  scr_overlay_set (0, len + 1, fname);

  free (fname);





}


void
rxvt_term::commit_iso14755 ()
{
  wchar_t ch[2];

  ch[0] = iso14755buf & 0x0fffffffUL;
  ch[1] = 0;

  if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/)
    {
      char mb[16];
      int len;

      // allow verbatim 0-bytes and control-bytes to be entered
      if (ch[0] >= 0x20)
        len = wcstombs (mb, ch, 16);
      else
        {
          mb[0] = ch[0];
          len = 1;
        }

      if (len > 0)
        tt_write (mb, len);
      else
        scr_bell ();
    }

  iso14755buf = 0;
}

static int
hex_keyval (XKeyEvent &ev)
{
  // check wether this event corresponds to a hex digit
  // if the modifiers had not been pressed.
  for (int index = 0; index < 8; index++)
    {
      KeySym k = XLookupKeysym (&ev, index);

      if (k >= 0xffb0 && k <= 0xffb9) return k - 0xffb0;
      else if (k >= 0x0030 /* U+0030 DIGIT ZERO */ && k <= 0x0039 /* U+0039 DIGIT NINE */) return k - 0x0030 /* U+0030 DIGIT ZERO */;
      else if (k >= 0x0061 /* U+0061 LATIN SMALL LETTER A */ && k <= 0x0066 /* U+0066 LATIN SMALL LETTER F */) return k - 0x0061 /* U+0061 LATIN SMALL LETTER A */ + 10;
      else if (k >= 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ && k <= 0x0046 /* U+0046 LATIN CAPITAL LETTER F */) return k - 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ + 10;
    }

  return -1;
}


static inline KeySym
translate_keypad (KeySym keysym, bool kp)
{

  static const KeySym keypadtrans[] = {
    0xffb7, // XK_KP_Home
    0xffb4, // XK_KP_Left
    0xffb8, // XK_KP_Up
    0xffb6, // XK_KP_Right
    0xffb2, // XK_KP_Down

    0xffb9, // XK_KP_Prior
    0xffb3, // XK_KP_Next




    0xffb1, // XK_KP_End
    0xffb5, // XK_KP_Begin
  };

  if (((unsigned int)(keysym) - (unsigned int)(0xff95) <= (unsigned int)(0xff9d) - (unsigned int)(0xff95)))
    {
      unsigned int index = keysym - 0xff95;
      keysym = kp ? keypadtrans[index] : 0xff50 + index;
    }
  else if (keysym == 0xff9e)
    keysym = kp ? 0xffb0 : 0xff63 /* Insert, insert here */;





  return keysym;
}

static inline int
map_function_key (KeySym keysym)
{
  int param = 0;

  if (((unsigned int)(keysym) - (unsigned int)(0xffbe) <= (unsigned int)(0xffe0) - (unsigned int)(0xffbe)))
    {
      param = 11 + keysym - 0xffbe;
      if (keysym >= 0xffce)
        param += 4;
      else if (keysym >= 0xffcc)
        param += 3;
      else if (keysym >= 0xffc8)
        param += 2;
      else if (keysym >= 0xffc3)
        param += 1;
    }
  else
    switch (keysym)
      {
        case 0xff68 /* Find, search */:
          param = 1;
          break;
        case 0xff63 /* Insert, insert here */:
          param = 2;
          break;



        case 0xff62 /* Execute, run, do */:
          param = 3;
          break;
        case 0xff60 /* Select, mark */:
          param = 4;
          break;

        case 0xff55 /* Prior, previous */:
          param = 5;
          break;
        case 0xff56 /* Next */:
          param = 6;
          break;
        case 0xff50:
          param = 7;
          break;
        case 0xff57 /* EOL */:
          param = 8;
          break;

        case 0xff6a /* Help */:
          param = 28;
          break;
        case 0xff67:
          param = 29;
          break;
      }
  return param;
}

void
rxvt_term::key_press (XKeyEvent &ev)
{
  int ctrl, meta, shft, len;
  KeySym keysym;
  int valid_keysym;
  char kbuf[512 /* size of keyboard mapping buffer*/];


  if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/)
    return;


  /*
   * use Num_Lock to toggle Keypad on/off.  If Num_Lock is off, allow an
   * escape sequence to toggle the Keypad.
   *
   * Always permit `shift' to override the current setting
   */
  shft = ev.state & (1<<0);
  ctrl = ev.state & (1<<2);
  meta = ev.state & ModMetaMask;

  if (numlock_state || (ev.state & ModNumLockMask))
    {
      numlock_state = (ev.state & ModNumLockMask);
      set_privmode ((1UL<<7), !numlock_state);
    }

  kbuf[0] = 0;
# 483 "command.C"
    {
      len = XLookupString (&ev, kbuf, 512 /* size of keyboard mapping buffer*/, &keysym, &compose);
      valid_keysym = keysym != 0L /* special KeySym */;
    }

  if (valid_keysym)
    {





      if (saveLines)
        {



          if ((((shft) || 0 || 0) && (!0 && !(ctrl) && !(meta))))

            {
              int lnsppg;


              lnsppg = nrow - 1;



              if (keysym == 0xff55 /* Prior, previous */)
                {
                  scr_page (UP, lnsppg);
                  return;
                }
              else if (keysym == 0xff56 /* Next */)
                {
                  scr_page (DN, lnsppg);
                  return;
                }
            }
# 551 "command.C"
        }

      if (shft)
        {
          /* Shift + F1 - F10 generates F11 - F20 */
          if (keysym >= 0xffbe && keysym <= 0xffc7)
            {
              keysym += (0xffc8 - 0xffbe);
              shft = 0; /* turn off Shift */
            }
          else if (!ctrl && !meta && (priv_modes & (1UL<<10)))
            {
              switch (keysym)
                {
                    /* normal XTerm key bindings */
                  case 0xff63 /* Insert, insert here */: /* Shift+Insert = paste mouse selection */
                    selection_request (ev.time);
                    return;
# 578 "command.C"
                }
            }
        }


      // ISO 14755 support
      if (shft && ctrl)
        {
          int hv;

          if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/
              && (keysym == 0x0020 /* U+0020 SPACE */ || keysym == 0xff80 /* Space */
                  || keysym == 0xff0d /* Return, enter */ || keysym == 0xff8d /* Enter */))
            {
              commit_iso14755 ();
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (0);

              return;
            }
          else if (keysym == 0xff08 /* Back space, back char */)
            {
              iso14755buf = ((iso14755buf & 0x0fffffffUL) >> 4) | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else if ((hv = hex_keyval (ev)) >= 0)
            {
              iso14755buf = ((iso14755buf << 4) & 0x0fffffffUL)
                          | hv | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else
            {

              scr_overlay_off ();

              iso14755buf = 0;
            }
        }
      else if ((ctrl && (keysym == 0xffe1 /* Left shift */ || keysym == 0xffe2 /* Right shift */))
               || (shft && (keysym == 0xffe3 /* Left control */ || keysym == 0xffe4 /* Right control */)))
        if (!(iso14755buf & 0x80000000UL))
          {
            iso14755buf |= 0x80000000UL;

            scr_overlay_new (0, -1, sizeof ("ISO 14755 mode") - 1, 1);
            scr_overlay_set (0, 0, "ISO 14755 mode");

          }



      if (keysym == 0xff61)
        {
          scr_printscreen (ctrl | shft);
          return;
        }


      if (keysym >= 0xFF00 && keysym <= 0xFFFF)
        {
          bool kp = priv_modes & (1UL<<7) ? !shft : shft;
          unsigned int newlen = 1;

          switch (translate_keypad (keysym, kp))
            {
# 668 "command.C"
              case 0xff09:
                if (shft)
                  (strcpy)(kbuf,"\033[Z");
                else
                  {
# 681 "command.C"
                    newlen = 0;
                  }
                break;

              case 0xff52 /* Move up, up arrow */: /* "\033[A" */
              case 0xff54 /* Move down, down arrow */: /* "\033[B" */
              case 0xff53 /* Move right, right arrow */: /* "\033[C" */
              case 0xff51 /* Move left, left arrow */: /* "\033[D" */
                (strcpy)(kbuf,"\033[Z");
                kbuf[2] = "DACB"[keysym - 0xff51 /* Move left, left arrow */];
                /* do Shift first */
                if (shft)
                  kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                else if (ctrl)
                  {
                    kbuf[1] = 'O';
                    kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                  }
                else if (priv_modes & (1UL<<6))
                  kbuf[1] = 'O';
                break;

              case 0xff8d /* Enter */:
                /* allow shift to override */
                if (kp)
                  {
                    (strcpy)(kbuf,"\033OM");
                    break;
                  }

                /* FALLTHROUGH */

              case 0xff0d /* Return, enter */:
                if (priv_modes & (1UL<<19))
                  {
                    kbuf[0] = '\015';
                    kbuf[1] = '\012';
                    kbuf[2] = '\0';
                  }
                else
                  {
                    kbuf[0] = '\015';
                    kbuf[1] = '\0';
                  }
                break;

              case 0xff91 /* PF1, KP_A, ... */: /* "\033OP" */
              case 0xff92: /* "\033OQ" */
              case 0xff93: /* "\033OR" */
              case 0xff94: /* "\033OS" */
                (strcpy)(kbuf,"\033OP");
                kbuf[2] += (keysym - 0xff91 /* PF1, KP_A, ... */);
                break;

              case 0xffaa: /* "\033Oj" : "*" */
              case 0xffab: /* "\033Ok" : "+" */
              case 0xffac /* Separator, often comma */: /* "\033Ol" : "," */
              case 0xffad: /* "\033Om" : "-" */
              case 0xffae: /* "\033On" : "." */
              case 0xffaf: /* "\033Oo" : "/" */
              case 0xffb0: /* "\033Op" : "0" */
              case 0xffb1: /* "\033Oq" : "1" */
              case 0xffb2: /* "\033Or" : "2" */
              case 0xffb3: /* "\033Os" : "3" */
              case 0xffb4: /* "\033Ot" : "4" */
              case 0xffb5: /* "\033Ou" : "5" */
              case 0xffb6: /* "\033Ov" : "6" */
              case 0xffb7: /* "\033Ow" : "7" */
              case 0xffb8: /* "\033Ox" : "8" */
              case 0xffb9: /* "\033Oy" : "9" */
                /* allow shift to override */
                if (kp)
                  {
                    (strcpy)(kbuf,"\033Oj");
                    kbuf[2] += (keysym - 0xffaa);
                  }
                else
                  {
                    kbuf[0] = ('*' + (keysym - 0xffaa));
                    kbuf[1] = '\0';
                  }
                break;

              default:
                {
                  int param = map_function_key (keysym);
                  if (param > 0)
                    sprintf (kbuf,"\033[%d~", param);
                  else
                    newlen = 0;
                }
                break;
            }

          if (newlen)
            len = (strlen)(kbuf);

          /*
           * Pass meta for all function keys, if 'meta' option set
           */

          if (meta && (meta_char == 0x80) && len > 0)
            kbuf[len - 1] |= 0x80;


        }
      else if (ctrl && keysym == 0x002d /* U+002D HYPHEN-MINUS */)
        {
          len = 1;
          kbuf[0] = '\037'; /* Ctrl-Minus generates ^_ (31) */
        }
      else if (keysym == 0xfe20)
        {
          (strcpy)(kbuf,"\033[Z");
          len = 3;
        }
      else
        {

          /* set 8-bit on */
          if (meta && (meta_char == 0x80))
            {
              char *ch;

              for (ch = kbuf; ch < kbuf + len; ch++)
                *ch |= 0x80;

              meta = 0;
            }

          /* nil */ ;
        }
    }

  if (false)
    return;

  if (len <= 0)
    return; /* not mapped */

  if (option (Opt_scrollTtyKeypress))
    if (view_start)
      {
        view_start = 0;
        want_refresh = 1;
      }

  /*
   * these modifications only affect the static keybuffer
   * pass Shift/Control indicators for function keys ending with `~'
   *
   * eg,
   *   Prior = "ESC[5~"
   *   Shift+Prior = "ESC[5$"
   *   Ctrl+Prior = "ESC[5^"
   *   Ctrl+Shift+Prior = "ESC[5@"
   * Meta adds an Escape prefix (with META8_OPTION, if meta == <escape>).
   */
  if (kbuf[0] == C0_ESC && kbuf[1] == '[' && kbuf[len - 1] == '~')
    kbuf[len - 1] = (shft ? (ctrl ? '@' : '$') : (ctrl ? '^' : '~'));

  /* escape prefix */
  if (meta

      && meta_char == C0_ESC

     )
    {
      const char ch = C0_ESC;
      tt_write (&ch, 1);
    }

  tt_write (kbuf, (unsigned int)len);
}

void
rxvt_term::key_release (XKeyEvent &ev)
{

  KeySym keysym;

  keysym = XLookupKeysym (&ev, ev.state & (1<<0) ? 1 : 0); // sorry, only shift supported :/



  // ISO 14755 support
  if (iso14755buf)
    if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/)
      {

        scr_overlay_off ();


        // iso14755 part 5.2 handling: release time
        // first: controls
        if ((ev.state & (1<<2))
             && ((keysym >= 0x40 && keysym <= 0x5f)
                 || (keysym >= 0x61 && keysym <= 0x7f)))
          {
            iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | 0x2400 | (keysym & 0x1f);
            commit_iso14755 ();

            return;
          }

        for (unsigned short *i = iso14755_symtab; i[0]; i+= 2)
          if (i[0] == keysym)
            {
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | i[1];
              commit_iso14755 ();

              return;
            }

        scr_bell ();

        iso14755buf = 0;

        return;
      }
    else if ((ev.state & ((1<<0) | (1<<2))) != ((1<<0) | (1<<2)))
      {

        scr_overlay_off ();

        if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/)
          commit_iso14755 ();

        else if (option (Opt_iso14755_52) && iso14755buf & 0x80000000UL)
          {
            iso14755buf = 0x20000000UL /* keycap (section 5.2)*/; // iso14755 part 5.2: remember empty begin/end pair

            scr_overlay_new (0, -1, sizeof ("KEYCAP PICTURE INSERT MODE") - 1, 1);
            scr_overlay_set (0, 0, "KEYCAP PICTURE INSERT MODE");
          }

        else
          iso14755buf = 0;
      }


  if (false)
    return;







}
# 966 "command.C"
void
rxvt_term::flush ()
{
  flush_ev.stop ();
# 979 "command.C"
  if (want_refresh)
    {
      if (false)
        {
          int row = view_start;
          int end_row = row + nrow;

          while (row > top_row && (this)->row_buf [(((((this))->term_start + int(row - 1)) + (((this))->total_rows)) % (((this))->total_rows))].is_longer ())
            --row;

          do
            {
              int start_row = row;
              line_t *l;

              do
                {
                  l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];

                  if (!(l->f & 0x0002 /* line has been filtered*/))
                    {
                      // line not filtered, mark it as filtered
                      l->f |= 0x0002 /* line has been filtered*/;
                      while (l->is_longer ())
                        {
                          l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];
                          l->f |= 0x0002 /* line has been filtered*/;
                        }

                      // and filter it
                      false;

                      break;
                    }
                }
              while (l->is_longer () && row < end_row);
            }
          while (row < end_row);
        }

      scr_refresh ();
      scrollBar.show (1);



    }

  display->flush ();
}

/* checks wether a refresh is requested and starts the refresh timer */
void
rxvt_term::refresh_check ()
{
  if (want_refresh && !flush_ev.is_active ())
    flush_ev.start (1. / 60.); // refresh at max. 60 Hz normally

  display->flush ();
}

void
rxvt_term::flush_cb (ev::timer &w, int revents)
{
  make_current ();

  refresh_count = 0;
  flush ();
}
# 1059 "command.C"
void
rxvt_term::text_blink_cb (ev::timer &w, int revents)
{
  if (scr_refresh_rend (0x00010000UL /* blink*/, 0x00010000UL /* blink*/))
    {
      hidden_text = !hidden_text;
      want_refresh = 1;
      refresh_check ();
    }
  else
    w.stop ();
}
# 1149 "command.C"
bool
rxvt_term::pty_fill ()
{
  ssize_t n = cmdbuf_endp - cmdbuf_ptr;

  if (2048 /* size of command buffer*/ == n)
    {
      rxvt_warn ("PLEASE REPORT: pty_fill on full buffer, draining input, continuing.\n");
      n = 0;
    }

  memmove (cmdbuf_base, cmdbuf_ptr, n);
  cmdbuf_ptr = cmdbuf_base;
  cmdbuf_endp = cmdbuf_ptr + n;

  ssize_t r = read (pty->pty, cmdbuf_endp, 2048 /* size of command buffer*/ - n);

  if (r > 0)
    {
      cmdbuf_endp += r;
      return true;
    }
  else if (r < 0 && ((*__error()) == 35 /* Resource temporarily unavailable */ || (*__error()) == 4 /* Interrupted system call */))
    {




    }
  else
    {
      pty_ev.stop ();

      if (!option (Opt_hold))
        destroy ();
    }

  return false;
}

void
rxvt_term::pty_cb (ev::io &w, int revents)
{
  make_current ();

  if (revents & ev::READ)
    // loop, but don't allow a single term to monopolize us
    for (int i = 8 /* never call pty_fill/cmd_parse more than this often in a row*/; i-- && pty_fill (); )
      cmd_parse ();

  if (revents & ev::WRITE)
    pty_write ();

  refresh_check ();
}

void
rxvt_term::pointer_unblank ()
{
  XDefineCursor (dpy, vt, TermWin_cursor);
  recolour_cursor ();







}
# 1241 "command.C"
void
rxvt_term::mouse_report (XButtonEvent &ev)
{
  int button_number, key_state = 0;
  int x, y;
  int code = 32;

  x = ((int32_t)((int32_t)(ev.x)) / (int32_t)fwidth);
  y = ((int32_t)((int32_t)(ev.y)) / (int32_t)fheight);
  if (ev.type == 6)
    {
      if (x == mouse_row && y == mouse_col)
        return;
      mouse_row = x;
      mouse_col = y;
      code += 32;
    }

  if (MEvent.button == 0L /* special Button Code, passed to GrabButton */)
    button_number = 3;
  else
    {
      button_number = MEvent.button - 1;
      /* add 0x3D for wheel events, like xterm does */
      if (button_number >= 3)
        button_number += (64 - 3);
    }

  if (priv_modes & (1UL<<12))
    {
      /*
       * do not report ButtonRelease
       * no state info allowed
       */
      key_state = 0;
      if (button_number == 3)
        return;
    }
  else
    {
      /* XTerm mouse reporting needs these values:
       *   4 = Shift
       *   8 = Meta
       *  16 = Control
       * plus will add in our own Double-Click reporting
       *  32 = Double Click
       */
      key_state = ((MEvent.state & (1<<0)) ? 4 : 0)
                  + ((MEvent.state & ModMetaMask) ? 8 : 0)
                  + ((MEvent.state & (1<<2)) ? 16 : 0);



    }
# 1312 "command.C"
  tt_printf ("\033[M%c%c%c",
            (code + button_number + key_state),
            (32 + x + 1),
            (32 + y + 1));
}

/*{{{ process an X event */
void
rxvt_term::x_cb (XEvent &ev)
{
  make_current ();

  Display * const dpy = this->dpy;

  if (ev.xany.window == vt
      && false
      && false)
    return;

  // for XQueryPointer
  Window unused_root, unused_child;
  int unused_root_x, unused_root_y;
  unsigned int unused_mask;

  switch (ev.type)
    {
      case 2:
        key_press (ev.xkey);
        break;

      case 3:
        key_release (ev.xkey);
        break;

      case 4:
        button_press (ev.xbutton);
        break;

      case 5:
        button_release (ev.xbutton);
        break;

      case 33:
        if (ev.xclient.format == 32
            && !false)
          {
            if (ev.xclient.message_type == xa[XA_WM_PROTOCOLS])
              {
                if (!false)
                  {
                    if (ev.xclient.data.l[0] == xa[XA_WM_DELETE_WINDOW])
                      {
                        if (!false)
                          destroy ();
                      }






                  }
              }
# 1384 "command.C"
          }
        break;

        /*
         * XXX: this is not the _current_ arrangement
         * Here's my conclusion:
         * If the window is completely unobscured, use bitblt's
         * to scroll. Even then, they're only used when doing partial
         * screen scrolling. When partially obscured, we have to fill
         * in the GraphicsExpose parts, which means that after each refresh,
         * we need to wait for the graphics expose or Noexpose events,
         * which ought to make things real slow!
         */
      case 15:
        switch (ev.xvisibility.state)
          {
            case 0:
              refresh_type = FAST_REFRESH;
              break;
            case 1:
              refresh_type = SLOW_REFRESH;
              break;
            default:
              refresh_type = NO_REFRESH;
              break;
          }
        break;

      case 9:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_in ();
        break;

      case 10:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_out ();
        break;

      case 22:
        /*fprintf (stderr, "ConfigureNotify for %X, parent is %X, geom is %dx%d%+d%+d, old geom was %dx%d\n",
              ev.xconfigure.window, parent[0], ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y,
              szHint.width, szHint.height);*/
        if (ev.xconfigure.window == parent[0])
          {
            while (XCheckTypedWindowEvent (dpy, ev.xconfigure.window, 22, &ev))
              ;

            if (szHint.width != ev.xconfigure.width || szHint.height != ev.xconfigure.height)
              {
                seen_resize = 1;
                resize_all_windows (ev.xconfigure.width, ev.xconfigure.height, 1);
              }
            else
              {
# 1451 "command.C"
              }

            false;
          }
        break;

      case 28:
        if (!false)
          if (ev.xproperty.atom == xa[XA_VT_SELECTION]
              && ev.xproperty.state == 0)
            selection_property (ev.xproperty.window, ev.xproperty.atom);

        break;

      case 29:
        selection_clear ();
        break;

      case 31:
        if (selection_wait == 0x01 /* normal selection */)
          selection_paste (ev.xselection.requestor, ev.xselection.property, true);
        break;

      case 30:
        selection_send (ev.xselectionrequest);
        break;

      case 19:
# 1495 "command.C"
        mapped = 1;

        text_blink_ev.start ();

        false;
        break;

      case 18:
        mapped = 0;

        text_blink_ev.stop ();

        false;
        break;

      case 13:
      case 12:
        if (ev.xany.window == vt)
          {
            do
              {
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }
            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev));

            ev.xany.type = ev.xany.type == 12 ? 13 : 12;

            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev))
              {
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }

            want_refresh = 1;
          }
        else
          {
            XEvent unused_event;

            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 12, &unused_event))
              ;
            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 13, &unused_event))
              ;

            if (scrollBar.state && ev.xany.window == scrollBar.win)
              {
                scrollBar.state = STATE_IDLE;
                scrollBar.show (0);
              }
          }
        break;

      case 6:




        if ((priv_modes & (1UL<<20) && ev.xbutton.state & ((1<<8)|(1<<9)|(1<<10)))
            || priv_modes & (1UL<<21))
          mouse_report (ev.xbutton);
        if ((priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))) && !bypass_keystate)
          break;

        if (ev.xany.window == vt)
          {
            if (false
                && false)
              ; // nop
            else if (ev.xbutton.state & ((1<<8) | (1<<10)))
              {
                while (XCheckTypedWindowEvent (dpy, vt, 6, &ev))
                  ;

                XQueryPointer (dpy, vt,
                               &unused_root, &unused_child,
                               &unused_root_x, &unused_root_y,
                               &ev.xbutton.x, &ev.xbutton.y,
                               &ev.xbutton.state);

                /* deal with a `jumpy' mouse */
                if ((ev.xmotion.time - MEvent.time) > 50)
                  {


                    // 5.4
                    if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
                      {
                        iso14755_54 (ev.xbutton.x, ev.xbutton.y);
                        break;
                      }

                    selection_extend (ev.xbutton.x, ev.xbutton.y,
                                      ev.xbutton.state & (1<<10) ? 2 : 0);
# 1636 "command.C"
                  }

              }
          }
        else if (scrollBar.state == STATE_MOTION && ev.xany.window == scrollBar.win)
          {
            while (XCheckTypedWindowEvent (dpy, scrollBar.win,
                                           6, &ev))
              ;

            XQueryPointer (dpy, scrollBar.win,
                          &unused_root, &unused_child,
                          &unused_root_x, &unused_root_y,
                          &ev.xbutton.x, &ev.xbutton.y,
                          &unused_mask);
            scr_move_to (((ev.xbutton.y) - scrollBar.beg) - csrO,
                         scrollBar.size ());
            want_refresh = 1;
            scrollBar.show (1);
          }
        break;
    }
# 1686 "command.C"
  refresh_check ();
}
# 1705 "command.C"
void
rxvt_term::focus_in ()
{
  if (!focus)
    {
      focus = 1;
      want_refresh = 1;
# 1736 "command.C"
      false;
    }
}

void
rxvt_term::focus_out ()
{
  if (focus)
    {
      focus = 0;
      want_refresh = 1;






      if (iso14755buf)
        {
          iso14755buf = 0;

          scr_overlay_off ();

        }
# 1779 "command.C"
      false;
    }
}

void
rxvt_term::update_fade_color (unsigned int idx)
{
# 1794 "command.C"
}
# 1829 "command.C"
void
rxvt_term::button_press (XButtonEvent &ev)
{
  int reportmode = 0, clickintime;

  bypass_keystate = ev.state & (ModMetaMask | (1<<0));

  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  /*
   * VT window processing of button press
   */
  if (ev.window == vt)
    {
      if (false)
        return;


      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
        {
          iso14755_54 (ev.x, ev.y);
          return;
        }


      clickintime = ev.time - MEvent.time < 500;

      if (reportmode)
        {
          /* mouse report from vt window */
          /* save the xbutton state (for ButtonRelease) */
          MEvent.state = ev.state;
# 1888 "command.C"
          MEvent.button = ev.button;
          mouse_report (ev);


        }
      else
        {
          if (ev.button != MEvent.button)
            MEvent.clicks = 0;

          switch (ev.button)
            {
              case 1:
                /* allow meta + click to select rectangular areas */
                /* should be done in screen.C */



                selection.rect = false;


                /* allow shift+left click to extend selection */
                if (ev.state & (1<<0) && !(priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))))
                  {
                    if (MEvent.button == 1 && clickintime)
                      selection_rotate (ev.x, ev.y);
                    else
                      selection_extend (ev.x, ev.y, 1);
                  }
                else
                  {
                    if (MEvent.button == 1 && clickintime)
                      MEvent.clicks++;
                    else
                      MEvent.clicks = 1;

                    selection_click (MEvent.clicks, ev.x, ev.y);
                  }

                MEvent.button = 1;
                break;

              case 3:
                if (MEvent.button == 3 && clickintime)
                  selection_rotate (ev.x, ev.y);
                else
                  selection_extend (ev.x, ev.y, 1);

                MEvent.button = 3;
                break;
            }
        }

      MEvent.time = ev.time;
      return;
    }

  /*
   * Scrollbar window processing of button press
   */
  if (scrollBar.state && ev.window == scrollBar.win)
    {
      page_dirn direction = NO_DIR;

      if (scrollBar.upButton (ev.y))
        direction = UP; /* up */
      else if (scrollBar.dnButton (ev.y))
        direction = DN; /* down */

      scrollBar.state = STATE_IDLE;
      /*
       * Rxvt-style scrollbar:
       * move up if mouse is above slider
       * move dn if mouse is below slider
       *
       * XTerm-style scrollbar:
       * Move display proportional to pointer location
       * pointer near top -> scroll one line
       * pointer near bot -> scroll full page
       */

      if (reportmode)
        {
          /*
           * Mouse report disabled scrollbar:
           * arrow buttons - send up/down
           * click on scrollbar - send pageup/down
           */
          if (direction == UP)
            tt_printf ("\033[A");
          else if (direction == DN)
            tt_printf ("\033[B");
          else
            switch (ev.button)
              {
                case 2:
                  tt_printf ("\014");
                  break;
                case 1:
                  tt_printf ("\033[6~");
                  break;
                case 3:
                  tt_printf ("\033[5~");
                  break;
              }
        }
      else

        {
          if (direction != NO_DIR)
            {




              if (scr_page (direction, 1))
                {
                  if (direction == UP)
                    scrollBar.state = STATE_UP;
                  else
                    scrollBar.state = STATE_DOWN;
                }
            }
          else
            switch (ev.button)
              {
                case 2:
                  switch (scrollBar.align)
                    {
                      case 1:
                        csrO = 0;
                        break;
                      case 0:
                        csrO = (scrollBar.bot - scrollBar.top) / 2;
                        break;
                      case 2:
                        csrO = scrollBar.bot - scrollBar.top;
                        break;
                    }

                  if (scrollBar.style == 2
                      || ((ev.y) < scrollBar.top)
                      || ((ev.y) > scrollBar.bot))
                    scr_move_to (((ev.y) - scrollBar.beg) - csrO, scrollBar.size ());

                  scrollBar.state = STATE_MOTION;
                  break;

                case 1:
                  if (scrollBar.align == 0)
                    csrO = ev.y - scrollBar.top;
                  /* FALLTHROUGH */

                case 3:
                  if (scrollBar.style != 2)
                    {
                      if (((ev.y) < scrollBar.top))

                        scr_page (UP, nrow - 1);



                      else if (((ev.y) > scrollBar.bot))

                        scr_page (DN, nrow - 1);



                      else
                        scrollBar.state = STATE_MOTION;
                    }
                  else
                    {
                      scr_page ((ev.button == 1 ? DN : UP),
                                (nrow
                                 * ((ev.y) - scrollBar.beg)
                                 / scrollBar.size ()));
                    }

                  break;
              }
        }

      return;
    }
}

void
rxvt_term::button_release (XButtonEvent &ev)
{
  int reportmode = 0;

  csrO = 0; /* reset csr Offset */
  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  if (scrollBar.state == STATE_UP || scrollBar.state == STATE_DOWN)
    {
      scrollBar.state = STATE_IDLE;
      scrollBar.show (0);
    }





  if (ev.window == vt)
    {
      if (false)
        return;


      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
        return;


      if (reportmode)
        {
          /* mouse report from vt window */
          /* don't report release of wheel "buttons" */
          if (ev.button >= 4)
            return;
# 2123 "command.C"
          MEvent.button = 0L /* special Button Code, passed to GrabButton */;
          mouse_report (ev);

          return;
        }

      /*
       * dumb hack to compensate for the failure of click-and-drag
       * when overriding mouse reporting
       */
      if (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))
          && bypass_keystate
          && ev.button == 1 && MEvent.clicks <= 1)
        selection_extend (ev.x, ev.y, 0);

      switch (ev.button)
        {
          case 1:
          case 3:
            selection_make (ev.time);
            break;

          case 2:
            if (((unsigned int)(ev.x) - (unsigned int)(0) < (unsigned int)(width) - (unsigned int)(0)) && ((unsigned int)(ev.y) - (unsigned int)(0) < (unsigned int)(height) - (unsigned int)(0))) // inside window?
       selection_request (ev.time, ev.state & ModMetaMask ? 0x03 : 0x01);
            break;
# 2185 "command.C"
        }
    }
}

/*}}} */

void
rxvt_term::cmd_parse ()
{
  wchar_t ch = NOCHAR;
  char *seq_begin; // remember start of esc-sequence here

  for (;;)
    {
      if (__builtin_expect (((ch == NOCHAR) != 0),(0)))
        {
          seq_begin = cmdbuf_ptr;
          ch = next_char ();

          if (ch == NOCHAR)
            break;
        }

      if (__builtin_expect (((!!((ch) & 0xffffff60UL) || ch == C0_LF || ch == C0_CR || ch == C0_HT) != 0),(1)))
        {
          if (__builtin_expect (((!seen_input) != 0),(0)))
            {
              seen_input = 1;
              // many badly-written programs (e.g. jed) contain a race condition:
              // they first read the screensize and then install a SIGWINCH handler.
              // some window managers resize the window early, and these programs
              // then sometimes get the size wrong.
              // unfortunately other programs are even more buggy and dislike
              // being sent SIGWINCH, so only do it when we were in fact being
              // resized.
              if (seen_resize && cmd_pid)
                kill (-cmd_pid, 28 /* window size changes */);
            }

          /* Read a text string from the input buffer */
          wchar_t buf[2048 /* character buffer*/];
          bool refreshnow = false;
          int nlines = 0;
          wchar_t *str = buf;
          wchar_t *eol = str + min (ncol, 2048 /* character buffer*/);

          for (;;)
            {
              if (__builtin_expect (((ch == NOCHAR || (!((ch) & 0xffffff60UL) && ch != C0_LF && ch != C0_CR && ch != C0_HT)) != 0),(0)))
                break;

              *str++ = ch;

              if (__builtin_expect (((ch == C0_LF || str >= eol) != 0),(0)))
                {
                  if (ch == C0_LF)
                    nlines++;

                  refresh_count++;

                  if (!option (Opt_jumpScroll) || refresh_count >= nrow - 1)
                    {
                      refresh_count = 0;

                      if (!option (Opt_skipScroll) || ev_time () > ev::now () + 1. / 60.)
                        {
                          refreshnow = true;
                          ch = NOCHAR;
                          break;
                        }
                    }

                  // scr_add_lines only works for nlines <= nrow - 1.
                  if (nlines >= nrow - 1)
                    {
                      if (!(false
                            && false))
                        scr_add_lines (buf, str - buf, nlines);

                      nlines = 0;
                      str = buf;
                      eol = str + min (ncol, 2048 /* character buffer*/);
                    }

                  if (str >= eol)
                    {
                      if (eol >= buf + 2048 /* character buffer*/)
                        {
                          ch = NOCHAR;
                          break;
                        }
                      else
                        eol = min (eol + ncol, buf + 2048 /* character buffer*/);
                    }

                }

              seq_begin = cmdbuf_ptr;
              ch = next_char ();
            }

          if (!(false
                && false))
            scr_add_lines (buf, str - buf, nlines);

          /*
           * If there have been a lot of new lines, then update the screen
           * What the heck we'll cheat and only refresh less than every page-full.
           * if skipScroll is enabled.
           */
          if (refreshnow)
            {
              scr_refresh ();
              want_refresh = 1;
            }
        }
      else
        {
          try
            {
              process_nonprinting (ch);
            }
          catch (const class out_of_input &o)
            {
              // we ran out of input, retry later
              cmdbuf_ptr = seq_begin;
              break;
            }

          ch = NOCHAR;
        }
    }
}

// read the next character
wchar_t
rxvt_term::next_char ()
{
  while (cmdbuf_ptr < cmdbuf_endp)
    {
      // assume 7-bit to be ascii ALWAYS
      if (__builtin_expect ((((unsigned char)*cmdbuf_ptr <= 0x7f && *cmdbuf_ptr != 0x1b) != 0),(1)))
        return *cmdbuf_ptr++;

      wchar_t wc;
      size_t len = mbrtowc (&wc, cmdbuf_ptr, cmdbuf_endp - cmdbuf_ptr, mbstate);

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }

      if (len == (size_t)-1)
        {
          mbrtowc (0, 0, 0, mbstate); // reset now undefined conversion state
          return (unsigned char)*cmdbuf_ptr++; // the _occasional_ latin1 character is allowed to slip through
        }

      // assume wchar == unicode
      cmdbuf_ptr += len;
      return wc & 0x1fffffUL;
    }

  return NOCHAR;
}

// read the next octet
uint32_t
rxvt_term::next_octet ()
{
  return cmdbuf_ptr < cmdbuf_endp
         ? (unsigned char)*cmdbuf_ptr++
         : NOCHAR;
}

static class out_of_input out_of_input;

/* rxvt_cmd_getc () - Return next input character */
/*
 * Return the next input character after first passing any keyboard input
 * to the command.
 */
wchar_t
rxvt_term::cmd_getc ()
{
  wchar_t c = next_char ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

uint32_t
rxvt_term::cmd_get8 ()
{
  uint32_t c = next_octet ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

/*{{{ print pipe */
/*----------------------------------------------------------------------*/

FILE *
rxvt_term::popen_printer ()
{
  FILE *stream = popen (rs[Rs_print_pipe] ? rs[Rs_print_pipe] : "lpr", "w");

  if (stream == __null)
    rxvt_warn ("can't open printer pipe, not printing.\n");

  return stream;
}

int
rxvt_term::pclose_printer (FILE *stream)
{
  fflush (stream);
  return pclose (stream);
}

/*
 * simulate attached vt100 printer
 */
void
rxvt_term::process_print_pipe ()
{
  FILE *fd = popen_printer ();

  if (!fd)
    return;

  /*
   * Send all input to the printer until either ESC[4i or ESC[?4i
   * is received.
   */
  for (int done = 0; !done; )
    {
      unsigned char buf[8];
      unicode_t ch;
      unsigned int i, len;

      if ((ch = cmd_getc ()) != C0_ESC)
        {
          if (putc (ch, fd) == (-1))
            break; /* done = 1 */
        }
      else
        {
          len = 0;
          buf[len++] = ch;

          if ((buf[len++] = cmd_getc ()) == '[')
            {
              if ((ch = cmd_getc ()) == '?')
                {
                  buf[len++] = '?';
                  ch = cmd_getc ();
                }
              if ((buf[len++] = ch) == '4')
                {
                  if ((buf[len++] = cmd_getc ()) == 'i')
                    break; /* done = 1 */
                }
            }

          for (i = 0; i < len; i++)
            if (putc (buf[i], fd) == (-1))
              {
                done = 1;
                break;
              }
        }
    }

  pclose_printer (fd);
}

/*}}} */

/* *INDENT-OFF* */
enum {
  C1_40 = 0x40,
          C1_41 , C1_BPH, C1_NBH, C1_44 , C1_NEL, C1_SSA, C1_ESA,
  C1_HTS, C1_HTJ, C1_VTS, C1_PLD, C1_PLU, C1_RI , C1_SS2, C1_SS3,
  C1_DCS, C1_PU1, C1_PU2, C1_STS, C1_CCH, C1_MW , C1_SPA, C1_EPA,
  C1_SOS, C1_59 , C1_SCI, C1_CSI, CS_ST , C1_OSC, C1_PM , C1_APC,
};
/* *INDENT-ON* */

/*{{{ process non-printing single characters */
void
rxvt_term::process_nonprinting (unicode_t ch)
{
  switch (ch)
    {
      case C0_ESC:
        process_escape_seq ();
        break;
      case C0_ENQ: /* terminal Status */
        if (rs[Rs_answerbackstring])
          tt_write (rs [Rs_answerbackstring], (strlen)(rs [Rs_answerbackstring]));
        else
          tt_write ("\033[?1;2c" /* vt100 answerback */, (strlen)("\033[?1;2c" /* vt100 answerback */));
        break;
      case C0_BEL: /* bell */
        scr_bell ();
        break;
      case C0_BS: /* backspace */
        scr_backspace ();
        break;
      case C0_HT: /* tab */
        scr_tab (1);
        break;
      case C0_CR: /* carriage return */
        scr_gotorc (0, 0, R_RELATIVE);
        break;
      case C0_VT: /* vertical tab, form feed */
      case C0_FF:
      case C0_LF: /* line feed */
        scr_index (UP);
        break;
      case C0_SO: /* shift out - acs */
        scr_charset_choose (1);
        break;
      case C0_SI: /* shift in - acs */
        scr_charset_choose (0);
        break;
# 2532 "command.C"
    }
}
/*}}} */


/*{{{ process VT52 escape sequences */
void
rxvt_term::process_escape_vt52 (unicode_t ch)
{
  int row, col;

  switch (ch)
    {
      case 'A': /* cursor up */
        scr_gotorc (-1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'B': /* cursor down */
        scr_gotorc (1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'C': /* cursor right */
        scr_gotorc (0, 1, R_RELATIVE | C_RELATIVE);
        break;
      case 'D': /* cursor left */
        scr_gotorc (0, -1, R_RELATIVE | C_RELATIVE);
        break;
      case 'H': /* cursor home */
        scr_gotorc (0, 0, 0);
        break;
      case 'I': /* cursor up and scroll down if needed */
        scr_index (DN);
        break;
      case 'J': /* erase to end of screen */
        scr_erase_screen (0);
        break;
      case 'K': /* erase to end of line */
        scr_erase_line (0);
        break;
      case 'Y': /* move to specified row and col */
        /* full command is 'ESC Y row col' where row and col
         * are encoded by adding 32 and sending the ascii
         * character.  eg. SPACE = 0, '+' = 13, '0' = 18,
         * etc. */
        row = cmd_getc () - ' ';
        col = cmd_getc () - ' ';
        scr_gotorc (row, col, 0);
        break;
      case 'Z': /* identify the terminal type */
        tt_printf ("\033/Z"); /* I am a VT100 emulating a VT52 */
        break;
      case '<': /* turn off VT52 mode */
        set_privmode ((1UL<<18), 0);
        break;
      case 'F': /* use special graphics character set */
      case 'G': /* use regular character set */
        /* unimplemented */
        break;
      case '=': /* use alternate keypad mode */
      case '>': /* use regular keypad mode */
        /* unimplemented */
        break;
    }
}
/*}}} */


/*{{{ process escape sequences */
void
rxvt_term::process_escape_seq ()
{
  unicode_t ch = cmd_getc ();

  if (priv_modes & (1UL<<18))
    {
      process_escape_vt52 (ch);
      return;
    }

  switch (ch)
    {
        /* case 1:        do_tek_mode (); break; */
      case '#':
        if (cmd_getc () == '8')
          scr_E ();
        break;
      case '(':
        scr_charset_set (0, (unsigned int)cmd_getc ());
        break;
      case ')':
        scr_charset_set (1, (unsigned int)cmd_getc ());
        break;
      case '*':
        scr_charset_set (2, (unsigned int)cmd_getc ());
        break;
      case '+':
        scr_charset_set (3, (unsigned int)cmd_getc ());
        break;





      case '7':
        scr_cursor (SAVE);
        break;
      case '8':
        scr_cursor (RESTORE);
        break;





      case '=':
      case '>':
        set_privmode ((1UL<<7), ch == '=');
        break;

      case C1_40:
        cmd_getc ();
        break;
      case C1_44:
        scr_index (UP);
        break;

        /* 8.3.87: NEXT LINE */
      case C1_NEL: /* ESC E */
        {
          wchar_t nlcr[] = { C0_LF, C0_CR };
          scr_add_lines (nlcr, sizeof (nlcr) / sizeof (nlcr [0]), 1);
        }
        break;

        /* kidnapped escape sequence: Should be 8.3.48 */
      case C1_ESA: /* ESC G */
        process_graphics ();
        break;

        /* 8.3.63: CHARACTER TABULATION SET */
      case C1_HTS: /* ESC H */
        scr_set_tab (1);
        break;

        /* 8.3.105: REVERSE LINE FEED */
      case C1_RI: /* ESC M */
        scr_index (DN);
        break;

        /* 8.3.142: SINGLE-SHIFT TWO */
      /*case C1_SS2: scr_single_shift (2);   break; */

        /* 8.3.143: SINGLE-SHIFT THREE */
      /*case C1_SS3: scr_single_shift (3);   break; */

        /* 8.3.27: DEVICE CONTROL STRING */
      case C1_DCS: /* ESC P */
        process_dcs_seq ();
        break;

        /* 8.3.110: SINGLE CHARACTER INTRODUCER */
      case C1_SCI: /* ESC Z */
        tt_write ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */, sizeof ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */) - 1);
        break; /* steal obsolete ESC [ c */

        /* 8.3.16: CONTROL SEQUENCE INTRODUCER (CSI) */
      case C1_CSI: /* ESC [ */
        process_csi_seq ();
        break;

        /* 8.3.90: OPERATING SYSTEM COMMAND (OSC) */
      case C1_OSC: /* ESC ] */
        process_osc_seq ();
        break;

        /* 8.3.106: RESET TO INITIAL STATE (RIS) */
      case 'c':
        mbstate.reset ();
        scr_poweron ();
        scrollBar.show (1);
        break;

        /* 8.3.79: LOCKING-SHIFT TWO (see ISO2022) */
      case 'n':
        scr_charset_choose (2);
        break;

        /* 8.3.81: LOCKING-SHIFT THREE (see ISO2022) */
      case 'o':
        scr_charset_choose (3);
        break;
    }
}
/*}}} */

/*{{{ process CONTROL SEQUENCE INTRODUCER (CSI) sequences `ESC[' */
/* *INDENT-OFF* */
enum {
  CSI_ICH = 0x40,
           CSI_CUU, CSI_CUD, CSI_CUF, CSI_CUB, CSI_CNL, CSI_CPL, CSI_CHA,
  CSI_CUP, CSI_CHT, CSI_ED , CSI_EL , CSI_IL , CSI_DL , CSI_EF , CSI_EA ,
  CSI_DCH, CSI_SEE, CSI_CPR, CSI_SU , CSI_SD , CSI_NP , CSI_PP , CSI_CTC,
  CSI_ECH, CSI_CVT, CSI_CBT, CSI_SRS, CSI_PTX, CSI_SDS, CSI_SIMD, CSI_5F,
  CSI_HPA, CSI_HPR, CSI_REP, CSI_DA , CSI_VPA, CSI_VPR, CSI_HVP, CSI_TBC,
  CSI_SM , CSI_MC , CSI_HPB, CSI_VPB, CSI_RM , CSI_SGR, CSI_DSR, CSI_DAQ,
  CSI_70 , CSI_71 , CSI_72 , CSI_73 , CSI_74 , CSI_75 , CSI_76 , CSI_77 ,
  CSI_78 , CSI_79 , CSI_7A , CSI_7B , CSI_7C , CSI_7D , CSI_7E , CSI_7F
};







const unsigned char csi_defaults[] =
  {
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (1)), /* @, A, B, C, D, E, F, G, */
    (((1) << 7) | ((1) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((0) << 1) | (0)), /* H, I, J, K, L, M, N, O, */
    (((1) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* P, Q, R, S, T, U, V, W, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((1) << 1) | (0)), /* X, Y, Z, [, \, ], ^, _, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* `, a, b, c, d, e, f, g, */
    (((0) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* h, i, j, k, l, m, n, o, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* p, q, r, s, t, u, v, w, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* x, y, z, {, |, }, ~,    */
  };
/* *INDENT-ON* */

void
rxvt_term::process_csi_seq ()
{
  unicode_t ch, priv, i;
  unsigned int nargs, p;
  int n, ndef;
  int arg[32 /* max # of args for esc sequences */] = { };

  nargs = 0;

  priv = 0;
  ch = cmd_getc ();
  if ((ch >= '<' && ch <= '?') || ch == '!')
    {
      /* '<' '=' '>' '?' '!' */
      priv = ch;
      ch = cmd_getc ();
    }

  /* read any numerical arguments */
  for (n = -1; ch < CSI_ICH; )
    {
      if (isdigit (ch))
        {
          if (n < 0)
            n = ch - '0';
          else
            n = n * 10 + ch - '0';
        }
      else if (ch == ';')
        {
          if (nargs < 32 /* max # of args for esc sequences */)
            arg[nargs++] = n;
          n = -1;
        }
      else if (!((ch) & 0xffffff60UL))
        process_nonprinting (ch);

      ch = cmd_getc ();
    }

  if (ch > CSI_7F)
    return;

  if (nargs < 32 /* max # of args for esc sequences */)
    arg[nargs++] = n;

  i = ch - CSI_ICH;
  ndef = (!! ((csi_defaults)[ (i) / 8] & (128 >> ((i) & 7))));
  for (p = 0; p < nargs; p++)
    if (arg[p] == -1)
      arg[p] = ndef;

  /*
   * private mode handling
   */
  if (priv)
    {
      switch (priv)
        {
          case '>':
            if (ch == CSI_DA) /* secondary device attributes */
              {
                // first parameter is normally 0 for vt100, 1 for vt220, 'R' for rxvt,
                // 'U' for rxvt-unicode != 7.[34] (where it was broken).
                //
                // second parameter is xterm patch level for xterm, MMmmpp (e.g. 20703) for rxvt
                // and Mm (e.g. 72 for 7.2) for urxvt <= 7.2, 94 for urxvt <= 8.3, and 95 for later
                // versions.
                //
                tt_printf ("\033[>%d;95;0c", 'U');
              }
            break;

          case '?':
            if (ch == 'h' || ch == 'l' || ch == 'r' || ch == 's' || ch == 't')
              process_terminal_mode (ch, priv, nargs, arg);
            break;

          case '!':
            if (ch == CSI_70)
              {
                /* DECSTR: soft terminal reset, used by our terminfo since 9.06 */
                scr_soft_reset ();

                static const int pm_h[] = { 7, 25 };
                static const int pm_l[] = { 1, 3, 4, 5, 6, 9, 66, 1000, 1001, 1049 };

                process_terminal_mode ('h', 0, sizeof (pm_h) / sizeof (pm_h[0]), pm_h);
                process_terminal_mode ('l', 0, sizeof (pm_l) / sizeof (pm_l[0]), pm_l);
              }
          break;
        }

      return;
    }

  switch (ch)
    {
        /*
         * ISO/IEC 6429:1992 (E) CSI sequences (defaults in parentheses)
         */

      case CSI_MC: /* 8.3.83: (0) MEDIA COPY */
        switch (arg[0])
          {
            case 0: /* initiate transfer to primary aux device */
              scr_printscreen (0);
              break;
            case 5: /* start relay to primary aux device */
              process_print_pipe ();
              break;
          }
        break;


      case CSI_CUU: /* 8.3.22: (1) CURSOR UP */
      case CSI_VPR: /* 8.3.161: (1) LINE POSITION FORWARD */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CUD: /* 8.3.19: (1) CURSOR DOWN */
      case CSI_VPB: /* 8.3.160: (1) LINE POSITION BACKWARD */
        scr_gotorc (arg[0], 0, RELATIVE);
        break;

      case CSI_CUB: /* 8.3.18: (1) CURSOR LEFT */
      case CSI_HPB: /* 8.3.59: (1) CHARACTER POSITION BACKWARD */



        arg[0] = arg[0] ? -arg[0] : -1;

        /* FALLTHROUGH */
      case CSI_CUF: /* 8.3.20: (1) CURSOR RIGHT */
      case CSI_HPR: /* 8.3.60: (1) CHARACTER POSITION FORWARD */



        scr_gotorc (0, arg[0] ? arg[0] : 1, RELATIVE);

        break;

      case CSI_CPL: /* 8.3.13: (1) CURSOR PRECEDING LINE */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CNL: /* 8.3.12: (1) CURSOR NEXT LINE */
        scr_gotorc (arg[0], 0, R_RELATIVE);
        break;

      case CSI_CHA: /* 8.3.9: (1) CURSOR CHARACTER ABSOLUTE */
      case CSI_HPA: /* 8.3.58: (1) CURSOR POSITION ABSOLUTE */
        scr_gotorc (0, arg[0] - 1, R_RELATIVE);
        break;

      case CSI_VPA: /* 8.3.159: (1) LINE POSITION ABSOLUTE */
        scr_gotorc (arg[0] - 1, 0, C_RELATIVE);
        break;

      case CSI_CUP: /* 8.3.21: (1,1) CURSOR POSITION */
      case CSI_HVP: /* 8.3.64: (1,1) CHARACTER AND LINE POSITION */
        scr_gotorc (arg[0] - 1, nargs < 2 ? 0 : (arg[1] - 1), 0);
        break;

      case CSI_CBT: /* 8.3.7: (1) CURSOR BACKWARD TABULATION */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CHT: /* 8.3.10: (1) CURSOR FORWARD TABULATION */
        scr_tab (arg[0]);
        break;

      case CSI_ED: /* 8.3.40: (0) ERASE IN PAGE */
        scr_erase_screen (arg[0]);
        break;

      case CSI_EL: /* 8.3.42: (0) ERASE IN LINE */
        scr_erase_line (arg[0]);
        break;

      case CSI_ICH: /* 8.3.65: (1) INSERT CHARACTER */
        scr_insdel_chars (arg[0], INSERT);
        break;

      case CSI_IL: /* 8.3.68: (1) INSERT LINE */
        scr_insdel_lines (arg[0], INSERT);
        break;

      case CSI_DL: /* 8.3.33: (1) DELETE LINE */
        scr_insdel_lines (arg[0], DELETE);
        break;

      case CSI_ECH: /* 8.3.39: (1) ERASE CHARACTER */
        scr_insdel_chars (arg[0], ERASE);
        break;

      case CSI_DCH: /* 8.3.26: (1) DELETE CHARACTER */
        scr_insdel_chars (arg[0], DELETE);
        break;

      case CSI_SD: /* 8.3.114: (1) SCROLL DOWN */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_SU: /* 8.3.148: (1) SCROLL UP */
        scr_scroll_text (screen.tscroll, screen.bscroll, arg[0]);
        break;

      case CSI_DA: /* 8.3.24: (0) DEVICE ATTRIBUTES */
        tt_write ("\033[?1;2c" /* vt100 answerback */, sizeof ("\033[?1;2c" /* vt100 answerback */) - 1);
        break;

      case CSI_SGR: /* 8.3.118: (0) SELECT GRAPHIC RENDITION */
        process_sgr_mode (nargs, arg);
        break;

      case CSI_DSR: /* 8.3.36: (0) DEVICE STATUS REPORT */
        switch (arg[0])
          {
            case 5: /* DSR requested */
              tt_printf ("\033[0n");
              break;
            case 6: /* CPR requested */
              scr_report_position ();
              break;
            case 7: /* unofficial extension */
              if (option (Opt_insecure))
                tt_printf ("%-.250s\012", rs[Rs_display_name]);
              break;
            case 8: /* unofficial extension */
              process_xterm_seq (XTerm_title, "urxvt" "-" "9.06", 0x9c /* 0234 */);
              break;
          }
        break;

      case CSI_TBC: /* 8.3.155: (0) TABULATION CLEAR */
        switch (arg[0])
          {
            case 0: /* char tab stop cleared at active position */
              scr_set_tab (0);
              break;
              /* case 1: */ /* line tab stop cleared in active line */
              /* case 2: */ /* char tab stops cleared in active line */
            case 3: /* all char tab stops are cleared */
              /* case 4: */ /* all line tab stops are cleared */
            case 5: /* all tab stops are cleared */
              scr_set_tab (-1);
              break;
          }
        break;

      case CSI_CTC: /* 8.3.17: (0) CURSOR TABULATION CONTROL */
        switch (arg[0])
          {
            case 0: /* char tab stop set at active position */
              scr_set_tab (1);
              break; /* = ESC H */
              /* case 1: */ /* line tab stop set at active line */
            case 2: /* char tab stop cleared at active position */
              scr_set_tab (0);
              break; /* = ESC [ 0 g */
              /* case 3: */ /* line tab stop cleared at active line */
              /* case 4: */ /* char tab stops cleared at active line */
            case 5: /* all char tab stops are cleared */
              scr_set_tab (-1);
              break; /* = ESC [ 3 g */
              /* case 6: */ /* all line tab stops are cleared */
          }
        break;

      case CSI_RM: /* 8.3.107: RESET MODE */
        if (arg[0] == 4)
          scr_insert_mode (0);
        else if (arg[0] == 20)
          priv_modes &= ~(1UL<<19);
        break;

      case CSI_SM: /* 8.3.126: SET MODE */
        if (arg[0] == 4)
          scr_insert_mode (1);
        else if (arg[0] == 20)
          priv_modes |= (1UL<<19);
        break;

        /*
         * PRIVATE USE beyond this point.  All CSI_7? sequences here
         */
      case CSI_72: /* DECSTBM: set top and bottom margins */
        if (nargs == 1)
          scr_scroll_region (arg[0] - 1, 10000 - 1);
        else if (nargs == 0 || arg[0] >= arg[1])
          scr_scroll_region (0, 10000 - 1);
        else
          scr_scroll_region (arg[0] - 1, arg[1] - 1);
        break;

      case CSI_73:
        scr_cursor (SAVE);
        break;
      case CSI_75:
        scr_cursor (RESTORE);
        break;







      case CSI_78: /* DECREQTPARM */
        if (arg[0] == 0 || arg[0] == 1)
          tt_printf ("\033[%d;1;1;128;128;1;0x", arg[0] + 2);
        break;

      default:
        break;
    }
}
/*}}} */
# 3171 "command.C"
/*----------------------------------------------------------------------*/
/*
 * get input up until STRING TERMINATOR (or BEL)
 * ends_how is terminator used. returned input must be free()'d
 */
char *
rxvt_term::get_to_st (unicode_t &ends_how)
{
  unicode_t ch;
  bool seen_esc = false;
  unsigned int n = 0;
  wchar_t string[2048 /* max string size for process_rxvt_xterm_seq() */];

  while ((ch = cmd_getc ()) != NOCHAR)
    {
      if (seen_esc)
        {
          if (ch == 0x5c) /* 7bit ST */
            break;
          else
            return __null;
        }
      else if (ch == C0_ESC)
        {
          seen_esc = true;
          continue;
        }
      else if (ch == C0_BEL || ch == 0x9c /* 0234 */)
        break;
      else if (ch == C0_SYN)
        ch = cmd_get8 ();
      else if (ch < 0x20)
        return __null; /* other control character - exit */

      seen_esc = false;

      if (n >= 2048 /* max string size for process_rxvt_xterm_seq() */ - 1)
        // stop at some sane length
        return __null;

      string[n++] = ch;
    }

  string[n++] = '\0';

  ends_how = (ch == 0x5c ? C0_ESC : ch);

  return rxvt_wcstombs (string);
}

/*----------------------------------------------------------------------*/
/*
 * process DEVICE CONTROL STRING `ESC P ... (ST|BEL)' or `0x90 ... (ST|BEL)'
 */
void
rxvt_term::process_dcs_seq ()
{
  char *s;
  unicode_t eh;

  /*
   * Not handled yet
   */
  s = get_to_st (eh);
  if (s)
    free (s);

  return;
}

/*----------------------------------------------------------------------*/
/*
 * process OPERATING SYSTEM COMMAND sequence `ESC ] Ps ; Pt (ST|BEL)'
 */
void
rxvt_term::process_osc_seq ()
{
  unicode_t ch, eh;
  int arg;

  ch = cmd_getc ();
  for (arg = 0; isdigit (ch); ch = cmd_getc ())
    arg = arg * 10 + (ch - '0');

  if (ch == ';')
    {
      char *s = get_to_st (eh);

      if (s)
        {
          process_xterm_seq (arg, s, eh);
          free (s);
        }
    }
}

void
rxvt_term::process_color_seq (int report, int color, const char *str, char resp)
{
  if (str[0] == '?' && !str[1])
    {
      rgba c;
      pix_colors_focused[color].get (c);






        tt_printf ("\033]%d;rgb:%04x/%04x/%04x%c", report, c.r, c.g, c.b, resp);
    }
  else
    set_window_color (color, str);
}

/*
 * XTerm escape sequences: ESC ] Ps;Pt (ST|BEL)
 */
void
rxvt_term::process_xterm_seq (int op, const char *str, char resp)
{
  int color;
  char *buf, *name;
  bool query = str[0] == '?' && !str[1];
  int saveop = op;

  Display * const dpy = this->dpy;

  (__builtin_expect(!(str != __null), 0) ? __assert_rtn(__func__, "command.C", 3299, "str != NULL") : (void)0);

  if (false)
    return;

  switch (op)
    {
      case XTerm_name:
        set_title (str);
        /* FALLTHROUGH */
      case XTerm_iconName:
        set_icon_name (str);
        break;
      case XTerm_title:
        set_title (str);
        break;
      case XTerm_property:
        if (str[0] == '?')
          {
            Atom prop = display->atom (str + 1);
            Atom actual_type;
            int actual_format;
            unsigned long nitems;
            unsigned long bytes_after;
            unsigned char *value = 0;
            const char *str = "";

            if (prop
                && XGetWindowProperty (dpy, parent[0],
                                       prop, 0, 1<<16, 0, 0L /* special Atom, passed to GetProperty */,
                                       &actual_type, &actual_format,
                                       &nitems, &bytes_after, &value) == 0 /* everything's okay */
                && actual_type != 0L /* universal null resource or null atom */
                && actual_format == 8)
              str = (const char *)(value);

            tt_printf ("\033]%d;%s%c", op, str, resp);

            XFree (value);
          }
        else
          {
            char *eq = strchr (str, '='); // constness lost, but verified to be ok

            if (eq)
              {
                *eq = 0;
                set_utf8_property (display->atom (str), eq + 1);
              }
            else
              XDeleteProperty (dpy, parent[0],
                               display->atom (str));
          }
        break;

      case XTerm_Color:
        for (buf = (char *)str; buf && *buf;)
          {
            if ((name = strchr (buf, ';')) == __null)
              break;

            *name++ = '\0';
            color = atoi (buf) + minCOLOR;

            if (!((unsigned int)(color) - (unsigned int)(minCOLOR) <= (unsigned int)(maxTermCOLOR) - (unsigned int)(minCOLOR)))
              break;

            if ((buf = strchr (name, ';')) != __null)
              *buf++ = '\0';

            process_color_seq (op, color, name, resp);
          }
        break;
      case Rxvt_restoreFG:
      case XTerm_Color00:
        process_color_seq (op, Color_fg, str, resp);
        break;
      case Rxvt_restoreBG:
      case XTerm_Color01:
        process_color_seq (op, Color_bg, str, resp);
        break;

      case XTerm_Color_cursor:
        process_color_seq (op, Color_cursor, str, resp);
        break;

      case XTerm_Color_pointer_fg:
        process_color_seq (op, Color_pointer_fg, str, resp);
        break;
      case XTerm_Color_pointer_bg:
        process_color_seq (op, Color_pointer_bg, str, resp);
        break;

      case XTerm_Color_RV:
        process_color_seq (op, Color_RV, str, resp);
        break;
      case Rxvt_Color_BD:
      case URxvt_Color_BD:
        process_color_seq (op, Color_BD, str, resp);
        break;
      case Rxvt_Color_UL:
      case URxvt_Color_UL:
        process_color_seq (op, Color_UL, str, resp);
        break;
      case URxvt_Color_IT:
        process_color_seq (op, Color_IT, str, resp);
        break;

      case URxvt_Color_border:
        process_color_seq (op, Color_border, str, resp);
        break;
# 3468 "command.C"
      case XTerm_logfile:
        // TODO, when secure mode?
        break;
# 3484 "command.C"
      case XTerm_font:
        op = URxvt_font;
      case URxvt_font:





        if (query)
          tt_printf ("\33]%d;%-.250s%c", saveop,
                     option (Opt_insecure) && fontset[op - URxvt_font]->fontdesc
                       ? fontset[op - URxvt_font]->fontdesc : "",
                     resp);
        else
          {
            const char *&res = rs[Rs_font + (op - URxvt_font)];

            res = strdup (str);
            allocated.push_back ((void *)res);
            set_fonts ();
          }
        break;

      case URxvt_version:
        if (query)
          tt_printf ("\33]%d;rxvt-unicode;%-.20s;%c;%c%c",
                     op,
                     rs[Rs_name], "9.06"[0], "9.06"[2],
                     resp);
        break;
# 3546 "command.C"
    }
}
/*----------------------------------------------------------------------*/

/*{{{ process DEC private mode sequences `ESC [ ? Ps mode' */
/*
 * mode can only have the following values:
 *      'l' = low
 *      'h' = high
 *      's' = save
 *      'r' = restore
 *      't' = toggle
 * so no need for fancy checking
 */
int
rxvt_term::privcases (int mode, unsigned long bit)
{
  int state;

  if (mode == 's')
    {
      SavedModes |= (priv_modes & bit);
      return -1;
    }
  else
    {
      if (mode == 'r')
        state = (SavedModes & bit) ? 1 : 0; /* no overlapping */
      else
        state = (mode == 't') ? ! (priv_modes & bit) : mode;
      set_privmode (bit, state);
    }

  return state;
}

/* we're not using priv _yet_ */
void
rxvt_term::process_terminal_mode (int mode, int priv __attribute__((unused)), unsigned int nargs, const int *arg)
{
  unsigned int i, j;
  int state;

  static const struct
  {
    const int argval;
    const unsigned long bit;
  } argtopriv[] = {
                  { 1, (1UL<<6) }, // DECCKM
                  { 2, (1UL<<18) },
                  { 3, (1UL<<0) }, // DECCOLM
                  { 4, (1UL<<17) }, // DECSCLM
                  { 5, (1UL<<2) }, // DECSCNM
                  { 6, (1UL<<3) }, // DECOM
                  { 7, (1UL<<5) }, // DECAWM
                 // 8, auto-repeat keys         // DECARM
                  { 9, (1UL<<12) },
                 // 18 end FF to printer after print screen
                 // 19 Print screen prints full screen/scorll region
                  { 25, (1UL<<11) }, // cnorm/cvvis/civis

                  { 30, (1UL<<14) },

                  { 35, (1UL<<10) }, // rxvt extension
                 // 38, tektronix mode          // DECTEK
                  { 40, (1UL<<1) },
                 // 41 xterm more fixes NYI
                 // 45 margin bell NYI
                 // 46 start logging
                  { 47, (1UL<<4) },
                  { 66, (1UL<<7) }, // DECPAM/DECPNM



                  { 1000, (1UL<<13) },
                  { 1002, (1UL<<20) },
                  { 1003, (1UL<<21) },
                  { 1010, (1UL<<15) }, // rxvt extension
                  { 1011, (1UL<<16) }, // rxvt extension
                 // 1035 enable modifiers for alt, numlock NYI
                 // 1036 send ESC for meta keys NYI
                 // 1037 send DEL for keypad delete NYI
                  { 1047, (1UL<<4) },
                 // 1048 save and restore cursor
                  { 1049, (1UL<<4) }, /* xterm extension, clear screen on ti rather than te */
                 // 1051, 1052, 1060, 1061 keyboard emulation NYI
                  { 2004, (1UL<<22) },
                };

  if (nargs == 0)
    return;

  /* make lo/hi boolean */
  if (mode == 'l')
    mode = 0; /* reset */
  else if (mode == 'h')
    mode = 1; /* set */

  for (i = 0; i < nargs; i++)
    {
      state = -1;

      /* basic handling */
      for (j = 0; j < (sizeof (argtopriv)/sizeof (argtopriv[0])); j++)
        if (argtopriv[j].argval == arg[i])
          {
            state = privcases (mode, argtopriv[j].bit);
            break;
          }

      /* extra handling for values with state unkept  */
      switch (arg[i])
        {







          case 1048: /* alternative cursor save */
            if (option (Opt_secondaryScreen))
              if (mode == 0)
                scr_cursor (RESTORE);
              else if (mode == 1)
                scr_cursor (SAVE);
            break;
        }

      if (state >= 0)
        /* extra handling for values with valid 0 or 1 state */
        switch (arg[i])
          {
              /* case 1:	- application cursor keys */
            case 2: /* VT52 mode */
              /* oddball mode.  should be set regardless of set/reset
               * parameter.  Return from VT52 mode with an ESC < from
               * within VT52 mode
               */
              set_privmode ((1UL<<18), 1);
              break;
            case 3: /* 80/132 */
              if (priv_modes & (1UL<<1))
                set_widthheight ((state ? 132 : 80) * fwidth, 24 * fheight);
              break;
            case 4: /* smooth scrolling */
              set_option (Opt_jumpScroll, !state);
              break;
            case 5: /* reverse video */
              scr_rvideo_mode (state);
              break;
            case 6: /* relative/absolute origins  */
              scr_relative_origin (state);
              break;
            case 7: /* autowrap */
              scr_autowrap (state);
              break;
            /* case 8:	- auto repeat, can't do on a per window basis */
            case 9: /* X10 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<13)|(1UL<<20)|(1UL<<21));
              break;

            case 30:
              if (scrollBar.map (state))
                {
                  resize_all_windows (0, 0, 0);
                  scr_touch (true);
                }
              break;

            case 25: /* visible/invisible cursor */
              scr_cursor_visible (state);
              break;
            /* case 35:	- shift keys */
            /* case 40:	- 80 <--> 132 mode */
            case 47: /* secondary screen */
              scr_change_screen (state);
              break;
            /* case 66:	- application key pad */
            /* case 67:	- backspace key */
            case 1000: /* X11 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<12)|(1UL<<20)|(1UL<<21));
              break;
            case 1002:
            case 1003:
              if (state)
                {
                  priv_modes &= ~((1UL<<12)|(1UL<<13));
                  priv_modes &= arg[i] == 1003 ? ~(1UL<<20) : ~(1UL<<21);
                  vt_emask_mouse = (1L<<6);
                }
              else
                vt_emask_mouse = 0L;

              vt_select_input ();
              break;
            case 1010: /* scroll to bottom on TTY output inhibit */
              set_option (Opt_scrollTtyOutput, !state);
              break;
            case 1011: /* scroll to bottom on key press */
              set_option (Opt_scrollTtyKeypress, state);
              break;
            case 1047: /* secondary screen w/ clearing last */
              if (option (Opt_secondaryScreen))
                if (!state)
                  scr_erase_screen (2);

              scr_change_screen (state);
              break;
            case 1049: /* secondary screen w/ clearing first */
              if (option (Opt_secondaryScreen))
                if (state)
                  scr_cursor (SAVE);

              scr_change_screen (state);

              if (option (Opt_secondaryScreen))
                if (state)
                  scr_erase_screen (2);
                else
                  scr_cursor (RESTORE);
              break;
            default:
              break;
          }
    }
}
/*}}} */

/*{{{ process sgr sequences */
void
rxvt_term::process_sgr_mode (unsigned int nargs, const int *arg)
{
  unsigned int i;
  short rendset;
  int rendstyle;

  if (nargs == 0)
    {
      scr_rendition (0, ~0);
      return;
    }

  for (i = 0; i < nargs; i++)
    {
      rendset = -1;
      switch (arg[i])
        {
          case 0:
            rendset = 0, rendstyle = ~0;
            break;
          case 1:
            rendset = 1, rendstyle = 0x00004000UL /* value 1*/;
            break;
          //case 2: // low intensity
          case 3:
            rendset = 1, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 4:
            rendset = 1, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 5: // slowly blinking
          case 6: // rapidly blinking
            rendset = 1, rendstyle = 0x00010000UL /* blink*/;
            break;
          //case 6: // scoansi light background
          case 7:
            rendset = 1, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          case 8:
            // invisible. NYI
            break;
          //case 9: // crossed out
          //case 10: // scoansi acs off, primary font
          //case 11: // scoansi acs on, first alt font
          //case 12: // scoansi acs on, |0x80, second alt font
          //...
          //case 19: // ninth alt font
          //case 20: // gothic
          case 21: // disable bold, faint, sometimes doubly underlined (iso 8613)
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
          case 22: // normal intensity
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
          case 23: // disable italic
            rendset = 0, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 24:
            rendset = 0, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 25:
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 26: // variable spacing (iso 8613)
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 27:
            rendset = 0, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          //case 28: // visible. NYI
          //case 29: // not crossed-out
        }

      if (rendset != -1)
        {
          scr_rendition (rendset, rendstyle);
          continue; /* for (;i;) */
        }

      switch (arg[i])
        {
          case 30:
          case 31: /* set fg color */
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
            scr_color ((unsigned int) (minCOLOR + (arg[i] - 30)), Color_fg);
            break;
          case 38: // set fg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5)
              {
                scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_fg);
                i += 2;
              }
            break;
          case 39: /* default fg */
            scr_color (Color_fg, Color_fg);
            break;

          case 40:
          case 41: /* set bg color */
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
            scr_color ((unsigned int) (minCOLOR + (arg[i] - 40)), Color_bg);
            break;
          case 48: // set bg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5)
              {
                scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_bg);
                i += 2;
              }
            break;
          case 49: /* default bg */
            scr_color (Color_bg, Color_bg);
            break;

          //case 50: // not variable spacing
# 3926 "command.C"
        }
    }
}
/*}}} */

/*{{{ (do not) process Rob Nation's own graphics mode sequences */
void
rxvt_term::process_graphics ()
{
  unicode_t ch, cmd = cmd_getc ();

  if (cmd == 'Q')
    {
      /* query graphics */
      tt_printf ("\033G0\012"); /* no graphics */
      return;
    }
  /* swallow other graphics sequences until terminating ':' */
  do
    ch = cmd_getc ();
  while (ch != ':');
}
/*}}} */

/* ------------------------------------------------------------------------- */

/*
 * Send printf () formatted output to the command.
 * Only use for small amounts of data.
 */
void
rxvt_term::tt_printf (const char *fmt,...)
{
  va_list arg_ptr;
  char buf[256];

  __builtin_va_start(arg_ptr,fmt);
  vsnprintf ((char *)buf, 256, fmt, arg_ptr);
  __builtin_va_end(arg_ptr);
  tt_write (buf, (strlen)(buf));
}

/* ---------------------------------------------------------------------- */
/* Write data to the pty as typed by the user, pasted with the mouse,
 * or generated by us in response to a query ESC sequence.
 */
const unsigned int MAX_PTY_WRITE = 255; // minimum MAX_INPUT

void
rxvt_term::tt_write (const char *data, unsigned int len)
{
  if (false)
    return;

  if (pty->pty < 0)
    return;

  if (v_buflen == 0)
    {
      ssize_t written = write (pty->pty, data, min (len, MAX_PTY_WRITE));

      if ((unsigned int)written == len)
        return;

      data += written;
      len -= written;
    }

  v_buffer = (char *)realloc (v_buffer, v_buflen + len);

  (memcpy)(v_buffer + v_buflen,data,len);
  v_buflen += len;

  pty_ev.set (ev::READ | ev::WRITE);
}

void rxvt_term::pty_write ()
{
  int written = write (pty->pty, v_buffer, min (v_buflen, MAX_PTY_WRITE));

  if (written > 0)
    {
      v_buflen -= written;

      if (v_buflen == 0)
        {
          free (v_buffer);
          v_buffer = 0;

          pty_ev.set (ev::READ);
          return;
        }

      memmove (v_buffer, v_buffer + written, v_buflen);
    }
  else if (written != -1 || ((*__error()) != 35 /* Resource temporarily unavailable */ && (*__error()) != 4 /* Interrupted system call */))
    pty_ev.set (ev::READ);
}

/*----------------------- end-of-file (C source) -----------------------*/
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C | wc -l
    3175
bash-3.2$ ./strip_to_orig_file_only.bash src/command.C_exp.C command.C | wc -l
    3175
bash-3.2$ cd src/
bash-3.2$ ../clean-file.bash command.C
.C
../clean-file.bash: line 25: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
sed: 4: "/(else|[)])[ ]*$/ {\nN\ns ...": extra characters at the end of } command
  C-c C-c
bash-3.2$ ../clean-file.bash command.C
.C
../clean-file.bash: line 25: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
sed: 4: "/(else|[)])[ ]*$/ {\nN\ns ...": extra characters at the end of } command
  C-c C-c
bash-3.2$ ../clean-file.bash command.C
.C
../clean-file.bash: line 25: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ cd ..
bash-3.2$ ../clean-file.bash command.C
bash: ../clean-file.bash: No such file or directory
bash-3.2$ ./clean-file.bash command.C
.C
./print_after.bash: line 12: .C: syntax error: operand expected (error token is ".C")
cat: : No such file or directory
./print_after.bash: line 21: 0-: syntax error: operand expected (error token is "-")

  C-c C-c
bash-3.2$ ./clean-file.bash command.C
.C
./print_after.bash: line 12: .C: syntax error: operand expected (error token is ".C")
cat: : No such file or directory
./print_after.bash: line 21: 0-: syntax error: operand expected (error token is "-")
  C-c C-c
bash-3.2$ cd src/
bash-3.2$ ../clean-file.bash command.C
.C
../clean-file.bash: line 26: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
.C
../clean-file.bash: line 26: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
.C
../clean-file.bash: line 26: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ dirname `pwd`
/Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
../clean-file.bash
.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
../clean-file.bash
.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ dirname
usage: dirname path
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
..
.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
../
.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
../
.C
.././strip_to_orig_file_only.bash asdfafs 
.././strip_to_orig_file_only.bash: line 13: ./print_after.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
../clean-file.bash
../
.C
.././strip_to_orig_file_only.bash: line 13: ./print_after.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ dirname `pwd`
/Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf
bash-3.2$ pwd
/Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf/src
bash-3.2$ pwd
/Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf/src
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
.././strip_to_orig_file_only.bash: line 13: ./print_after.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
.././strip_to_orig_file_only.bash: line 13: ./print_after.bash: No such file or directory
cat: multi-line.test: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
.././strip_to_orig_file_only.bash: line 13: ./print_after.bash: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C

// Get rid of those macros defined in <signal.h> in lieu of real functions.


namespace std
{
  using ::sig_atomic_t;
  using ::signal;
  using ::raise;
}
# 60 "command.C" 2





/*----------------------------------------------------------------------*/
# 78 "command.C"
static unsigned short iso14755_symtab[] = {
  // keysym,		unicode
  0xff51 /* Move left, left arrow */, 0x2190,
  0xff96, 0x2190,
  0xff52 /* Move up, up arrow */, 0x2191,
  0xff97, 0x2191,
  0xff53 /* Move right, right arrow */, 0x2192,
  0xff98, 0x2192,
  0xff54 /* Move down, down arrow */, 0x2193,
  0xff99, 0x2193,
  0xff0a /* Linefeed, LF */, 0x21b4,
  0xff0d /* Return, enter */, 0x21b5,
  0xff8d /* Enter */, 0x21b5,

  0xff55 /* Prior, previous */, 0x21de,
  0xff56 /* Next */, 0x21df,
  0xff09, 0x21e5,
  0xfe20, 0x21e6,
  0xffe1 /* Left shift */, 0x21e7,
  0xffe2 /* Right shift */, 0x21e7,

  0xffe6 /* Shift lock */, 0x21eb,
  0xfe01, 0x21eb,
  0xffe5 /* Caps lock */, 0x21ec,
  0xff7f, 0x21ed,
  0xfe03, 0x21ee,
  0xfe05, 0x21ef,
  0xfe07, 0x21f0,
  0xff50, 0x21f1,
  0xff57 /* EOL */, 0x21f2,

  0xff62 /* Execute, run, do */, 0x2318,
  0xff58 /* BOL */, 0x2320,
  0xffff /* Delete, rubout */, 0x2326,
  0xff0b, 0x2327,
  0xff08 /* Back space, back char */, 0x232b,
  0xff63 /* Insert, insert here */, 0x2380,
  0xffe3 /* Left control */, 0x2388,
  0xffe4 /* Right control */, 0x2388,
  0xff13 /* Pause, hold */, 0x2389,
  0xff6b, 0x238a,
  0xff1b, 0x238b,
  0xff65, 0x238c,
  0xff61, 0x2399,

  0x0020 /* U+0020 SPACE */, 0x2423,


  0xff9a, 0x21de,
  0xff9b, 0x21df,
  0xff9d, 0x2320,
  0xff9e, 0x2380,
  0xff9f, 0x2326,
  0xff80 /* Space */, 0x2422,

  0,
};

void
rxvt_term::iso14755_54 (int x, int y)
{
  x = ((int32_t)((int32_t)(x)) / (int32_t)fwidth);
  y = ((int32_t)((int32_t)(y)) / (int32_t)fheight);

  if (!((unsigned int)(x) - (unsigned int)(0) < (unsigned int)(ncol) - (unsigned int)(0))
      || !((unsigned int)(y) - (unsigned int)(0) < (unsigned int)(nrow) - (unsigned int)(0)))
    return;

  for (;;)
    {
      const line_t &l = (this)->row_buf [(((((this))->term_start + int(y + view_start)) + (((this))->total_rows)) % (((this))->total_rows))];

      text_t t = l.t[x];

      if (t != NOCHAR || !x)
        {
          iso14755_51 (l.t[x], l.r[x], x, y);
          iso14755buf = 0x10000000UL /* code feedback (section 5.4)*/;
          break;
        }

      x--;
    }
}

void
rxvt_term::iso14755_51 (unicode_t ch, rend_t r, int x, int y)
{
  rxvt_fontset *fs = (this)->fontset[0];
  rxvt_font *f = (*fs)[fs->find_font (ch)];
  wchar_t *chr, *alloc, ch2, *fname;
  int len;

  fname = rxvt_utf8towcs (f->name);
# 182 "command.C"
    {
      ch2 = ch;

      alloc = 0;
      chr = &ch2;
      len = 1;
    }

  char attr[80]; // plenty

  sprintf (attr, "%08x = fg %d bg %d%s%s%s%s%s%s",
           (int)r,
           fgcolor_of (r), bgcolor_of (r),
           r & 0x00004000UL /* value 1*/ ? " bold" : "",
           r & 0x00008000UL /* value 2*/ ? " italic" : "",
           r & 0x00010000UL /* blink*/ ? " blink" : "",
           r & 0x00020000UL /* reverse video*/ ? " rvid" : "",
           r & 0x00040000UL /* underline*/ ? " uline" : "",
           r & 0x80000000UL /* be careful when drawing these */ ? " careful" : "");

  int width = wcswidth (fname, wcslen (fname));

  max_it (width, 8+5); // for char + hex
  max_it (width, (strlen)(attr));

  if (y >= 0)
    {
      y = (y >= nrow - len - 4 && x < width + 2) ? 0 : -1;
      x = 0;
    }

  scr_overlay_new (x, y, width, len + 2);

  r = ((((0 | Color_Black | (Color_Yellow << 7 /* 0 .. maxTermCOLOR*/))) & ~(0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) | (((((r) & (0x00004000UL /* value 1*/ | 0x00008000UL /* value 2*/)) >> 14)) << 14));

  for (int y = 0; y < len; y++)
    {
      char buf[9];

      ch = *chr++;

      sprintf (buf, "%8x", ch);
      scr_overlay_set (0, y, buf);
      scr_overlay_set (9, y, '=');

      if (ch >= 0x10000)
        ch = 0xfffd;

      scr_overlay_set (11, y, ch, r);

      if ((((unsigned int)(ch) - (unsigned int)(0x20) <= (unsigned int)(0x7e) - (unsigned int)(0x20)) ? 1 : wcwidth (ch)) >= 2)
        scr_overlay_set (12, y, NOCHAR, r);
    }

//  {
//    char buf[4+4+3+1];
//    snprintf (buf, sizeof (buf), "(%.4d|%.4d)", x, y);
//    scr_overlay_set (0, 0, buf);
//  }
  scr_overlay_set (0, len , attr);
  scr_overlay_set (0, len + 1, fname);

  free (fname);





}


void
rxvt_term::commit_iso14755 ()
{
  wchar_t ch[2];

  ch[0] = iso14755buf & 0x0fffffffUL;
  ch[1] = 0;

  if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/)
    {
      char mb[16];
      int len;

      // allow verbatim 0-bytes and control-bytes to be entered
      if (ch[0] >= 0x20)
        len = wcstombs (mb, ch, 16);
      else
        {
          mb[0] = ch[0];
          len = 1;
        }

      if (len > 0)
        tt_write (mb, len);
      else
        scr_bell ();
    }

  iso14755buf = 0;
}

static int
hex_keyval (XKeyEvent &ev)
{
  // check wether this event corresponds to a hex digit
  // if the modifiers had not been pressed.
  for (int index = 0; index < 8; index++)
    {
      KeySym k = XLookupKeysym (&ev, index);

      if (k >= 0xffb0 && k <= 0xffb9) return k - 0xffb0;
      else if (k >= 0x0030 /* U+0030 DIGIT ZERO */ && k <= 0x0039 /* U+0039 DIGIT NINE */) return k - 0x0030 /* U+0030 DIGIT ZERO */;
      else if (k >= 0x0061 /* U+0061 LATIN SMALL LETTER A */ && k <= 0x0066 /* U+0066 LATIN SMALL LETTER F */) return k - 0x0061 /* U+0061 LATIN SMALL LETTER A */ + 10;
      else if (k >= 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ && k <= 0x0046 /* U+0046 LATIN CAPITAL LETTER F */) return k - 0x0041 /* U+0041 LATIN CAPITAL LETTER A */ + 10;
    }

  return -1;
}


static inline KeySym
translate_keypad (KeySym keysym, bool kp)
{

  static const KeySym keypadtrans[] = {
    0xffb7, // XK_KP_Home
    0xffb4, // XK_KP_Left
    0xffb8, // XK_KP_Up
    0xffb6, // XK_KP_Right
    0xffb2, // XK_KP_Down

    0xffb9, // XK_KP_Prior
    0xffb3, // XK_KP_Next




    0xffb1, // XK_KP_End
    0xffb5, // XK_KP_Begin
  };

  if (((unsigned int)(keysym) - (unsigned int)(0xff95) <= (unsigned int)(0xff9d) - (unsigned int)(0xff95)))
    {
      unsigned int index = keysym - 0xff95;
      keysym = kp ? keypadtrans[index] : 0xff50 + index;
    }
  else if (keysym == 0xff9e)
    keysym = kp ? 0xffb0 : 0xff63 /* Insert, insert here */;





  return keysym;
}

static inline int
map_function_key (KeySym keysym)
{
  int param = 0;

  if (((unsigned int)(keysym) - (unsigned int)(0xffbe) <= (unsigned int)(0xffe0) - (unsigned int)(0xffbe)))
    {
      param = 11 + keysym - 0xffbe;
      if (keysym >= 0xffce)
        param += 4;
      else if (keysym >= 0xffcc)
        param += 3;
      else if (keysym >= 0xffc8)
        param += 2;
      else if (keysym >= 0xffc3)
        param += 1;
    }
  else
    switch (keysym)
      {
        case 0xff68 /* Find, search */:
          param = 1;
          break;
        case 0xff63 /* Insert, insert here */:
          param = 2;
          break;



        case 0xff62 /* Execute, run, do */:
          param = 3;
          break;
        case 0xff60 /* Select, mark */:
          param = 4;
          break;

        case 0xff55 /* Prior, previous */:
          param = 5;
          break;
        case 0xff56 /* Next */:
          param = 6;
          break;
        case 0xff50:
          param = 7;
          break;
        case 0xff57 /* EOL */:
          param = 8;
          break;

        case 0xff6a /* Help */:
          param = 28;
          break;
        case 0xff67:
          param = 29;
          break;
      }
  return param;
}

void
rxvt_term::key_press (XKeyEvent &ev)
{
  int ctrl, meta, shft, len;
  KeySym keysym;
  int valid_keysym;
  char kbuf[512 /* size of keyboard mapping buffer*/];


  if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/)
    return;


  /*
   * use Num_Lock to toggle Keypad on/off.  If Num_Lock is off, allow an
   * escape sequence to toggle the Keypad.
   *
   * Always permit `shift' to override the current setting
   */
  shft = ev.state & (1<<0);
  ctrl = ev.state & (1<<2);
  meta = ev.state & ModMetaMask;

  if (numlock_state || (ev.state & ModNumLockMask))
    {
      numlock_state = (ev.state & ModNumLockMask);
      set_privmode ((1UL<<7), !numlock_state);
    }

  kbuf[0] = 0;
# 483 "command.C"
    {
      len = XLookupString (&ev, kbuf, 512 /* size of keyboard mapping buffer*/, &keysym, &compose);
      valid_keysym = keysym != 0L /* special KeySym */;
    }

  if (valid_keysym)
    {





      if (saveLines)
        {



          if ((((shft) || 0 || 0) && (!0 && !(ctrl) && !(meta))))

            {
              int lnsppg;


              lnsppg = nrow - 1;



              if (keysym == 0xff55 /* Prior, previous */)
                {
                  scr_page (UP, lnsppg);
                  return;
                }
              else if (keysym == 0xff56 /* Next */)
                {
                  scr_page (DN, lnsppg);
                  return;
                }
            }
# 551 "command.C"
        }

      if (shft)
        {
          /* Shift + F1 - F10 generates F11 - F20 */
          if (keysym >= 0xffbe && keysym <= 0xffc7)
            {
              keysym += (0xffc8 - 0xffbe);
              shft = 0; /* turn off Shift */
            }
          else if (!ctrl && !meta && (priv_modes & (1UL<<10)))
            {
              switch (keysym)
                {
                    /* normal XTerm key bindings */
                  case 0xff63 /* Insert, insert here */: /* Shift+Insert = paste mouse selection */
                    selection_request (ev.time);
                    return;
# 578 "command.C"
                }
            }
        }


      // ISO 14755 support
      if (shft && ctrl)
        {
          int hv;

          if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/
              && (keysym == 0x0020 /* U+0020 SPACE */ || keysym == 0xff80 /* Space */
                  || keysym == 0xff0d /* Return, enter */ || keysym == 0xff8d /* Enter */))
            {
              commit_iso14755 ();
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (0);

              return;
            }
          else if (keysym == 0xff08 /* Back space, back char */)
            {
              iso14755buf = ((iso14755buf & 0x0fffffffUL) >> 4) | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else if ((hv = hex_keyval (ev)) >= 0)
            {
              iso14755buf = ((iso14755buf << 4) & 0x0fffffffUL)
                          | hv | 0x40000000UL /* basic (section 5.1)*/;

              iso14755_51 (iso14755buf & 0x0fffffffUL);

              return;
            }
          else
            {

              scr_overlay_off ();

              iso14755buf = 0;
            }
        }
      else if ((ctrl && (keysym == 0xffe1 /* Left shift */ || keysym == 0xffe2 /* Right shift */))
               || (shft && (keysym == 0xffe3 /* Left control */ || keysym == 0xffe4 /* Right control */)))
        if (!(iso14755buf & 0x80000000UL))
          {
            iso14755buf |= 0x80000000UL;

            scr_overlay_new (0, -1, sizeof ("ISO 14755 mode") - 1, 1);
            scr_overlay_set (0, 0, "ISO 14755 mode");

          }



      if (keysym == 0xff61)
        {
          scr_printscreen (ctrl | shft);
          return;
        }


      if (keysym >= 0xFF00 && keysym <= 0xFFFF)
        {
          bool kp = priv_modes & (1UL<<7) ? !shft : shft;
          unsigned int newlen = 1;

          switch (translate_keypad (keysym, kp))
            {
# 668 "command.C"
              case 0xff09:
                if (shft)
                  (strcpy)(kbuf,"\033[Z");
                else
                  {
# 681 "command.C"
                    newlen = 0;
                  }
                break;

              case 0xff52 /* Move up, up arrow */: /* "\033[A" */
              case 0xff54 /* Move down, down arrow */: /* "\033[B" */
              case 0xff53 /* Move right, right arrow */: /* "\033[C" */
              case 0xff51 /* Move left, left arrow */: /* "\033[D" */
                (strcpy)(kbuf,"\033[Z");
                kbuf[2] = "DACB"[keysym - 0xff51 /* Move left, left arrow */];
                /* do Shift first */
                if (shft)
                  kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                else if (ctrl)
                  {
                    kbuf[1] = 'O';
                    kbuf[2] = "dacb"[keysym - 0xff51 /* Move left, left arrow */];
                  }
                else if (priv_modes & (1UL<<6))
                  kbuf[1] = 'O';
                break;

              case 0xff8d /* Enter */:
                /* allow shift to override */
                if (kp)
                  {
                    (strcpy)(kbuf,"\033OM");
                    break;
                  }

                /* FALLTHROUGH */

              case 0xff0d /* Return, enter */:
                if (priv_modes & (1UL<<19))
                  {
                    kbuf[0] = '\015';
                    kbuf[1] = '\012';
                    kbuf[2] = '\0';
                  }
                else
                  {
                    kbuf[0] = '\015';
                    kbuf[1] = '\0';
                  }
                break;

              case 0xff91 /* PF1, KP_A, ... */: /* "\033OP" */
              case 0xff92: /* "\033OQ" */
              case 0xff93: /* "\033OR" */
              case 0xff94: /* "\033OS" */
                (strcpy)(kbuf,"\033OP");
                kbuf[2] += (keysym - 0xff91 /* PF1, KP_A, ... */);
                break;

              case 0xffaa: /* "\033Oj" : "*" */
              case 0xffab: /* "\033Ok" : "+" */
              case 0xffac /* Separator, often comma */: /* "\033Ol" : "," */
              case 0xffad: /* "\033Om" : "-" */
              case 0xffae: /* "\033On" : "." */
              case 0xffaf: /* "\033Oo" : "/" */
              case 0xffb0: /* "\033Op" : "0" */
              case 0xffb1: /* "\033Oq" : "1" */
              case 0xffb2: /* "\033Or" : "2" */
              case 0xffb3: /* "\033Os" : "3" */
              case 0xffb4: /* "\033Ot" : "4" */
              case 0xffb5: /* "\033Ou" : "5" */
              case 0xffb6: /* "\033Ov" : "6" */
              case 0xffb7: /* "\033Ow" : "7" */
              case 0xffb8: /* "\033Ox" : "8" */
              case 0xffb9: /* "\033Oy" : "9" */
                /* allow shift to override */
                if (kp)
                  {
                    (strcpy)(kbuf,"\033Oj");
                    kbuf[2] += (keysym - 0xffaa);
                  }
                else
                  {
                    kbuf[0] = ('*' + (keysym - 0xffaa));
                    kbuf[1] = '\0';
                  }
                break;

              default:
                {
                  int param = map_function_key (keysym);
                  if (param > 0)
                    sprintf (kbuf,"\033[%d~", param);
                  else
                    newlen = 0;
                }
                break;
            }

          if (newlen)
            len = (strlen)(kbuf);

          /*
           * Pass meta for all function keys, if 'meta' option set
           */

          if (meta && (meta_char == 0x80) && len > 0)
            kbuf[len - 1] |= 0x80;


        }
      else if (ctrl && keysym == 0x002d /* U+002D HYPHEN-MINUS */)
        {
          len = 1;
          kbuf[0] = '\037'; /* Ctrl-Minus generates ^_ (31) */
        }
      else if (keysym == 0xfe20)
        {
          (strcpy)(kbuf,"\033[Z");
          len = 3;
        }
      else
        {

          /* set 8-bit on */
          if (meta && (meta_char == 0x80))
            {
              char *ch;

              for (ch = kbuf; ch < kbuf + len; ch++)
                *ch |= 0x80;

              meta = 0;
            }

          /* nil */ ;
        }
    }

  if (false)
    return;

  if (len <= 0)
    return; /* not mapped */

  if (option (Opt_scrollTtyKeypress))
    if (view_start)
      {
        view_start = 0;
        want_refresh = 1;
      }

  /*
   * these modifications only affect the static keybuffer
   * pass Shift/Control indicators for function keys ending with `~'
   *
   * eg,
   *   Prior = "ESC[5~"
   *   Shift+Prior = "ESC[5$"
   *   Ctrl+Prior = "ESC[5^"
   *   Ctrl+Shift+Prior = "ESC[5@"
   * Meta adds an Escape prefix (with META8_OPTION, if meta == <escape>).
   */
  if (kbuf[0] == C0_ESC && kbuf[1] == '[' && kbuf[len - 1] == '~')
    kbuf[len - 1] = (shft ? (ctrl ? '@' : '$') : (ctrl ? '^' : '~'));

  /* escape prefix */
  if (meta

      && meta_char == C0_ESC

     )
    {
      const char ch = C0_ESC;
      tt_write (&ch, 1);
    }

  tt_write (kbuf, (unsigned int)len);
}

void
rxvt_term::key_release (XKeyEvent &ev)
{

  KeySym keysym;

  keysym = XLookupKeysym (&ev, ev.state & (1<<0) ? 1 : 0); // sorry, only shift supported :/



  // ISO 14755 support
  if (iso14755buf)
    if (iso14755buf & 0x20000000UL /* keycap (section 5.2)*/)
      {

        scr_overlay_off ();


        // iso14755 part 5.2 handling: release time
        // first: controls
        if ((ev.state & (1<<2))
             && ((keysym >= 0x40 && keysym <= 0x5f)
                 || (keysym >= 0x61 && keysym <= 0x7f)))
          {
            iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | 0x2400 | (keysym & 0x1f);
            commit_iso14755 ();

            return;
          }

        for (unsigned short *i = iso14755_symtab; i[0]; i+= 2)
          if (i[0] == keysym)
            {
              iso14755buf = 0x40000000UL /* basic (section 5.1)*/ | i[1];
              commit_iso14755 ();

              return;
            }

        scr_bell ();

        iso14755buf = 0;

        return;
      }
    else if ((ev.state & ((1<<0) | (1<<2))) != ((1<<0) | (1<<2)))
      {

        scr_overlay_off ();

        if (iso14755buf & 0x40000000UL /* basic (section 5.1)*/)
          commit_iso14755 ();

        else if (option (Opt_iso14755_52) && iso14755buf & 0x80000000UL)
          {
            iso14755buf = 0x20000000UL /* keycap (section 5.2)*/; // iso14755 part 5.2: remember empty begin/end pair

            scr_overlay_new (0, -1, sizeof ("KEYCAP PICTURE INSERT MODE") - 1, 1);
            scr_overlay_set (0, 0, "KEYCAP PICTURE INSERT MODE");
          }

        else
          iso14755buf = 0;
      }


  if (false)
    return;







}
# 966 "command.C"
void
rxvt_term::flush ()
{
  flush_ev.stop ();
# 979 "command.C"
  if (want_refresh)
    {
      if (false)
        {
          int row = view_start;
          int end_row = row + nrow;

          while (row > top_row && (this)->row_buf [(((((this))->term_start + int(row - 1)) + (((this))->total_rows)) % (((this))->total_rows))].is_longer ())
            --row;

          do
            {
              int start_row = row;
              line_t *l;

              do
                {
                  l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];

                  if (!(l->f & 0x0002 /* line has been filtered*/))
                    {
                      // line not filtered, mark it as filtered
                      l->f |= 0x0002 /* line has been filtered*/;
                      while (l->is_longer ())
                        {
                          l = &(this)->row_buf [(((((this))->term_start + int(row++)) + (((this))->total_rows)) % (((this))->total_rows))];
                          l->f |= 0x0002 /* line has been filtered*/;
                        }

                      // and filter it
                      false;

                      break;
                    }
                }
              while (l->is_longer () && row < end_row);
            }
          while (row < end_row);
        }

      scr_refresh ();
      scrollBar.show (1);



    }

  display->flush ();
}

/* checks wether a refresh is requested and starts the refresh timer */
void
rxvt_term::refresh_check ()
{
  if (want_refresh && !flush_ev.is_active ())
    flush_ev.start (1. / 60.); // refresh at max. 60 Hz normally

  display->flush ();
}

void
rxvt_term::flush_cb (ev::timer &w, int revents)
{
  make_current ();

  refresh_count = 0;
  flush ();
}
# 1059 "command.C"
void
rxvt_term::text_blink_cb (ev::timer &w, int revents)
{
  if (scr_refresh_rend (0x00010000UL /* blink*/, 0x00010000UL /* blink*/))
    {
      hidden_text = !hidden_text;
      want_refresh = 1;
      refresh_check ();
    }
  else
    w.stop ();
}
# 1149 "command.C"
bool
rxvt_term::pty_fill ()
{
  ssize_t n = cmdbuf_endp - cmdbuf_ptr;

  if (2048 /* size of command buffer*/ == n)
    {
      rxvt_warn ("PLEASE REPORT: pty_fill on full buffer, draining input, continuing.\n");
      n = 0;
    }

  memmove (cmdbuf_base, cmdbuf_ptr, n);
  cmdbuf_ptr = cmdbuf_base;
  cmdbuf_endp = cmdbuf_ptr + n;

  ssize_t r = read (pty->pty, cmdbuf_endp, 2048 /* size of command buffer*/ - n);

  if (r > 0)
    {
      cmdbuf_endp += r;
      return true;
    }
  else if (r < 0 && ((*__error()) == 35 /* Resource temporarily unavailable */ || (*__error()) == 4 /* Interrupted system call */))
    {




    }
  else
    {
      pty_ev.stop ();

      if (!option (Opt_hold))
        destroy ();
    }

  return false;
}

void
rxvt_term::pty_cb (ev::io &w, int revents)
{
  make_current ();

  if (revents & ev::READ)
    // loop, but don't allow a single term to monopolize us
    for (int i = 8 /* never call pty_fill/cmd_parse more than this often in a row*/; i-- && pty_fill (); )
      cmd_parse ();

  if (revents & ev::WRITE)
    pty_write ();

  refresh_check ();
}

void
rxvt_term::pointer_unblank ()
{
  XDefineCursor (dpy, vt, TermWin_cursor);
  recolour_cursor ();







}
# 1241 "command.C"
void
rxvt_term::mouse_report (XButtonEvent &ev)
{
  int button_number, key_state = 0;
  int x, y;
  int code = 32;

  x = ((int32_t)((int32_t)(ev.x)) / (int32_t)fwidth);
  y = ((int32_t)((int32_t)(ev.y)) / (int32_t)fheight);
  if (ev.type == 6)
    {
      if (x == mouse_row && y == mouse_col)
        return;
      mouse_row = x;
      mouse_col = y;
      code += 32;
    }

  if (MEvent.button == 0L /* special Button Code, passed to GrabButton */)
    button_number = 3;
  else
    {
      button_number = MEvent.button - 1;
      /* add 0x3D for wheel events, like xterm does */
      if (button_number >= 3)
        button_number += (64 - 3);
    }

  if (priv_modes & (1UL<<12))
    {
      /*
       * do not report ButtonRelease
       * no state info allowed
       */
      key_state = 0;
      if (button_number == 3)
        return;
    }
  else
    {
      /* XTerm mouse reporting needs these values:
       *   4 = Shift
       *   8 = Meta
       *  16 = Control
       * plus will add in our own Double-Click reporting
       *  32 = Double Click
       */
      key_state = ((MEvent.state & (1<<0)) ? 4 : 0)
                  + ((MEvent.state & ModMetaMask) ? 8 : 0)
                  + ((MEvent.state & (1<<2)) ? 16 : 0);



    }
# 1312 "command.C"
  tt_printf ("\033[M%c%c%c",
            (code + button_number + key_state),
            (32 + x + 1),
            (32 + y + 1));
}

/*{{{ process an X event */
void
rxvt_term::x_cb (XEvent &ev)
{
  make_current ();

  Display * const dpy = this->dpy;

  if (ev.xany.window == vt
      && false
      && false)
    return;

  // for XQueryPointer
  Window unused_root, unused_child;
  int unused_root_x, unused_root_y;
  unsigned int unused_mask;

  switch (ev.type)
    {
      case 2:
        key_press (ev.xkey);
        break;

      case 3:
        key_release (ev.xkey);
        break;

      case 4:
        button_press (ev.xbutton);
        break;

      case 5:
        button_release (ev.xbutton);
        break;

      case 33:
        if (ev.xclient.format == 32
            && !false)
          {
            if (ev.xclient.message_type == xa[XA_WM_PROTOCOLS])
              {
                if (!false)
                  {
                    if (ev.xclient.data.l[0] == xa[XA_WM_DELETE_WINDOW])
                      {
                        if (!false)
                          destroy ();
                      }






                  }
              }
# 1384 "command.C"
          }
        break;

        /*
         * XXX: this is not the _current_ arrangement
         * Here's my conclusion:
         * If the window is completely unobscured, use bitblt's
         * to scroll. Even then, they're only used when doing partial
         * screen scrolling. When partially obscured, we have to fill
         * in the GraphicsExpose parts, which means that after each refresh,
         * we need to wait for the graphics expose or Noexpose events,
         * which ought to make things real slow!
         */
      case 15:
        switch (ev.xvisibility.state)
          {
            case 0:
              refresh_type = FAST_REFRESH;
              break;
            case 1:
              refresh_type = SLOW_REFRESH;
              break;
            default:
              refresh_type = NO_REFRESH;
              break;
          }
        break;

      case 9:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_in ();
        break;

      case 10:
        if (ev.xfocus.detail != 2
            && ev.xfocus.detail != 5
            && ev.xfocus.mode != 1)
          focus_out ();
        break;

      case 22:
        /*fprintf (stderr, "ConfigureNotify for %X, parent is %X, geom is %dx%d%+d%+d, old geom was %dx%d\n",
              ev.xconfigure.window, parent[0], ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y,
              szHint.width, szHint.height);*/
        if (ev.xconfigure.window == parent[0])
          {
            while (XCheckTypedWindowEvent (dpy, ev.xconfigure.window, 22, &ev))
              ;

            if (szHint.width != ev.xconfigure.width || szHint.height != ev.xconfigure.height)
              {
                seen_resize = 1;
                resize_all_windows (ev.xconfigure.width, ev.xconfigure.height, 1);
              }
            else
              {
# 1451 "command.C"
              }

            false;
          }
        break;

      case 28:
        if (!false)
          if (ev.xproperty.atom == xa[XA_VT_SELECTION]
              && ev.xproperty.state == 0)
            selection_property (ev.xproperty.window, ev.xproperty.atom);

        break;

      case 29:
        selection_clear ();
        break;

      case 31:
        if (selection_wait == 0x01 /* normal selection */)
          selection_paste (ev.xselection.requestor, ev.xselection.property, true);
        break;

      case 30:
        selection_send (ev.xselectionrequest);
        break;

      case 19:
# 1495 "command.C"
        mapped = 1;

        text_blink_ev.start ();

        false;
        break;

      case 18:
        mapped = 0;

        text_blink_ev.stop ();

        false;
        break;

      case 13:
      case 12:
        if (ev.xany.window == vt)
          {
            do
              {
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }
            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev));

            ev.xany.type = ev.xany.type == 12 ? 13 : 12;

            while (XCheckTypedWindowEvent (dpy, vt, ev.xany.type, &ev))
              {
                scr_expose (ev.xexpose.x, ev.xexpose.y,
                            ev.xexpose.width, ev.xexpose.height, 0);
              }

            want_refresh = 1;
          }
        else
          {
            XEvent unused_event;

            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 12, &unused_event))
              ;
            while (XCheckTypedWindowEvent (dpy, ev.xany.window, 13, &unused_event))
              ;

            if (scrollBar.state && ev.xany.window == scrollBar.win)
              {
                scrollBar.state = STATE_IDLE;
                scrollBar.show (0);
              }
          }
        break;

      case 6:




        if ((priv_modes & (1UL<<20) && ev.xbutton.state & ((1<<8)|(1<<9)|(1<<10)))
            || priv_modes & (1UL<<21))
          mouse_report (ev.xbutton);
        if ((priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))) && !bypass_keystate)
          break;

        if (ev.xany.window == vt)
          {
            if (false
                && false)
              ; // nop
            else if (ev.xbutton.state & ((1<<8) | (1<<10)))
              {
                while (XCheckTypedWindowEvent (dpy, vt, 6, &ev))
                  ;

                XQueryPointer (dpy, vt,
                               &unused_root, &unused_child,
                               &unused_root_x, &unused_root_y,
                               &ev.xbutton.x, &ev.xbutton.y,
                               &ev.xbutton.state);

                /* deal with a `jumpy' mouse */
                if ((ev.xmotion.time - MEvent.time) > 50)
                  {


                    // 5.4
                    if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
                      {
                        iso14755_54 (ev.xbutton.x, ev.xbutton.y);
                        break;
                      }

                    selection_extend (ev.xbutton.x, ev.xbutton.y,
                                      ev.xbutton.state & (1<<10) ? 2 : 0);
# 1636 "command.C"
                  }

              }
          }
        else if (scrollBar.state == STATE_MOTION && ev.xany.window == scrollBar.win)
          {
            while (XCheckTypedWindowEvent (dpy, scrollBar.win,
                                           6, &ev))
              ;

            XQueryPointer (dpy, scrollBar.win,
                          &unused_root, &unused_child,
                          &unused_root_x, &unused_root_y,
                          &ev.xbutton.x, &ev.xbutton.y,
                          &unused_mask);
            scr_move_to (((ev.xbutton.y) - scrollBar.beg) - csrO,
                         scrollBar.size ());
            want_refresh = 1;
            scrollBar.show (1);
          }
        break;
    }
# 1686 "command.C"
  refresh_check ();
}
# 1705 "command.C"
void
rxvt_term::focus_in ()
{
  if (!focus)
    {
      focus = 1;
      want_refresh = 1;
# 1736 "command.C"
      false;
    }
}

void
rxvt_term::focus_out ()
{
  if (focus)
    {
      focus = 0;
      want_refresh = 1;






      if (iso14755buf)
        {
          iso14755buf = 0;

          scr_overlay_off ();

        }
# 1779 "command.C"
      false;
    }
}

void
rxvt_term::update_fade_color (unsigned int idx)
{
# 1794 "command.C"
}
# 1829 "command.C"
void
rxvt_term::button_press (XButtonEvent &ev)
{
  int reportmode = 0, clickintime;

  bypass_keystate = ev.state & (ModMetaMask | (1<<0));

  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  /*
   * VT window processing of button press
   */
  if (ev.window == vt)
    {
      if (false)
        return;


      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
        {
          iso14755_54 (ev.x, ev.y);
          return;
        }


      clickintime = ev.time - MEvent.time < 500;

      if (reportmode)
        {
          /* mouse report from vt window */
          /* save the xbutton state (for ButtonRelease) */
          MEvent.state = ev.state;
# 1888 "command.C"
          MEvent.button = ev.button;
          mouse_report (ev);


        }
      else
        {
          if (ev.button != MEvent.button)
            MEvent.clicks = 0;

          switch (ev.button)
            {
              case 1:
                /* allow meta + click to select rectangular areas */
                /* should be done in screen.C */



                selection.rect = false;


                /* allow shift+left click to extend selection */
                if (ev.state & (1<<0) && !(priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))))
                  {
                    if (MEvent.button == 1 && clickintime)
                      selection_rotate (ev.x, ev.y);
                    else
                      selection_extend (ev.x, ev.y, 1);
                  }
                else
                  {
                    if (MEvent.button == 1 && clickintime)
                      MEvent.clicks++;
                    else
                      MEvent.clicks = 1;

                    selection_click (MEvent.clicks, ev.x, ev.y);
                  }

                MEvent.button = 1;
                break;

              case 3:
                if (MEvent.button == 3 && clickintime)
                  selection_rotate (ev.x, ev.y);
                else
                  selection_extend (ev.x, ev.y, 1);

                MEvent.button = 3;
                break;
            }
        }

      MEvent.time = ev.time;
      return;
    }

  /*
   * Scrollbar window processing of button press
   */
  if (scrollBar.state && ev.window == scrollBar.win)
    {
      page_dirn direction = NO_DIR;

      if (scrollBar.upButton (ev.y))
        direction = UP; /* up */
      else if (scrollBar.dnButton (ev.y))
        direction = DN; /* down */

      scrollBar.state = STATE_IDLE;
      /*
       * Rxvt-style scrollbar:
       * move up if mouse is above slider
       * move dn if mouse is below slider
       *
       * XTerm-style scrollbar:
       * Move display proportional to pointer location
       * pointer near top -> scroll one line
       * pointer near bot -> scroll full page
       */

      if (reportmode)
        {
          /*
           * Mouse report disabled scrollbar:
           * arrow buttons - send up/down
           * click on scrollbar - send pageup/down
           */
          if (direction == UP)
            tt_printf ("\033[A");
          else if (direction == DN)
            tt_printf ("\033[B");
          else
            switch (ev.button)
              {
                case 2:
                  tt_printf ("\014");
                  break;
                case 1:
                  tt_printf ("\033[6~");
                  break;
                case 3:
                  tt_printf ("\033[5~");
                  break;
              }
        }
      else

        {
          if (direction != NO_DIR)
            {




              if (scr_page (direction, 1))
                {
                  if (direction == UP)
                    scrollBar.state = STATE_UP;
                  else
                    scrollBar.state = STATE_DOWN;
                }
            }
          else
            switch (ev.button)
              {
                case 2:
                  switch (scrollBar.align)
                    {
                      case 1:
                        csrO = 0;
                        break;
                      case 0:
                        csrO = (scrollBar.bot - scrollBar.top) / 2;
                        break;
                      case 2:
                        csrO = scrollBar.bot - scrollBar.top;
                        break;
                    }

                  if (scrollBar.style == 2
                      || ((ev.y) < scrollBar.top)
                      || ((ev.y) > scrollBar.bot))
                    scr_move_to (((ev.y) - scrollBar.beg) - csrO, scrollBar.size ());

                  scrollBar.state = STATE_MOTION;
                  break;

                case 1:
                  if (scrollBar.align == 0)
                    csrO = ev.y - scrollBar.top;
                  /* FALLTHROUGH */

                case 3:
                  if (scrollBar.style != 2)
                    {
                      if (((ev.y) < scrollBar.top))

                        scr_page (UP, nrow - 1);



                      else if (((ev.y) > scrollBar.bot))

                        scr_page (DN, nrow - 1);



                      else
                        scrollBar.state = STATE_MOTION;
                    }
                  else
                    {
                      scr_page ((ev.button == 1 ? DN : UP),
                                (nrow
                                 * ((ev.y) - scrollBar.beg)
                                 / scrollBar.size ()));
                    }

                  break;
              }
        }

      return;
    }
}

void
rxvt_term::button_release (XButtonEvent &ev)
{
  int reportmode = 0;

  csrO = 0; /* reset csr Offset */
  if (!bypass_keystate)
    reportmode = !! (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21)));

  if (scrollBar.state == STATE_UP || scrollBar.state == STATE_DOWN)
    {
      scrollBar.state = STATE_IDLE;
      scrollBar.show (0);
    }





  if (ev.window == vt)
    {
      if (false)
        return;


      // 5.4
      if (iso14755buf & (0x80000000UL | 0x10000000UL /* code feedback (section 5.4)*/))
        return;


      if (reportmode)
        {
          /* mouse report from vt window */
          /* don't report release of wheel "buttons" */
          if (ev.button >= 4)
            return;
# 2123 "command.C"
          MEvent.button = 0L /* special Button Code, passed to GrabButton */;
          mouse_report (ev);

          return;
        }

      /*
       * dumb hack to compensate for the failure of click-and-drag
       * when overriding mouse reporting
       */
      if (priv_modes & ((1UL<<12)|(1UL<<13)|(1UL<<20)|(1UL<<21))
          && bypass_keystate
          && ev.button == 1 && MEvent.clicks <= 1)
        selection_extend (ev.x, ev.y, 0);

      switch (ev.button)
        {
          case 1:
          case 3:
            selection_make (ev.time);
            break;

          case 2:
            if (((unsigned int)(ev.x) - (unsigned int)(0) < (unsigned int)(width) - (unsigned int)(0)) && ((unsigned int)(ev.y) - (unsigned int)(0) < (unsigned int)(height) - (unsigned int)(0))) // inside window?
       selection_request (ev.time, ev.state & ModMetaMask ? 0x03 : 0x01);
            break;
# 2185 "command.C"
        }
    }
}

/*}}} */

void
rxvt_term::cmd_parse ()
{
  wchar_t ch = NOCHAR;
  char *seq_begin; // remember start of esc-sequence here

  for (;;)
    {
      if (__builtin_expect (((ch == NOCHAR) != 0),(0)))
        {
          seq_begin = cmdbuf_ptr;
          ch = next_char ();

          if (ch == NOCHAR)
            break;
        }

      if (__builtin_expect (((!!((ch) & 0xffffff60UL) || ch == C0_LF || ch == C0_CR || ch == C0_HT) != 0),(1)))
        {
          if (__builtin_expect (((!seen_input) != 0),(0)))
            {
              seen_input = 1;
              // many badly-written programs (e.g. jed) contain a race condition:
              // they first read the screensize and then install a SIGWINCH handler.
              // some window managers resize the window early, and these programs
              // then sometimes get the size wrong.
              // unfortunately other programs are even more buggy and dislike
              // being sent SIGWINCH, so only do it when we were in fact being
              // resized.
              if (seen_resize && cmd_pid)
                kill (-cmd_pid, 28 /* window size changes */);
            }

          /* Read a text string from the input buffer */
          wchar_t buf[2048 /* character buffer*/];
          bool refreshnow = false;
          int nlines = 0;
          wchar_t *str = buf;
          wchar_t *eol = str + min (ncol, 2048 /* character buffer*/);

          for (;;)
            {
              if (__builtin_expect (((ch == NOCHAR || (!((ch) & 0xffffff60UL) && ch != C0_LF && ch != C0_CR && ch != C0_HT)) != 0),(0)))
                break;

              *str++ = ch;

              if (__builtin_expect (((ch == C0_LF || str >= eol) != 0),(0)))
                {
                  if (ch == C0_LF)
                    nlines++;

                  refresh_count++;

                  if (!option (Opt_jumpScroll) || refresh_count >= nrow - 1)
                    {
                      refresh_count = 0;

                      if (!option (Opt_skipScroll) || ev_time () > ev::now () + 1. / 60.)
                        {
                          refreshnow = true;
                          ch = NOCHAR;
                          break;
                        }
                    }

                  // scr_add_lines only works for nlines <= nrow - 1.
                  if (nlines >= nrow - 1)
                    {
                      if (!(false
                            && false))
                        scr_add_lines (buf, str - buf, nlines);

                      nlines = 0;
                      str = buf;
                      eol = str + min (ncol, 2048 /* character buffer*/);
                    }

                  if (str >= eol)
                    {
                      if (eol >= buf + 2048 /* character buffer*/)
                        {
                          ch = NOCHAR;
                          break;
                        }
                      else
                        eol = min (eol + ncol, buf + 2048 /* character buffer*/);
                    }

                }

              seq_begin = cmdbuf_ptr;
              ch = next_char ();
            }

          if (!(false
                && false))
            scr_add_lines (buf, str - buf, nlines);

          /*
           * If there have been a lot of new lines, then update the screen
           * What the heck we'll cheat and only refresh less than every page-full.
           * if skipScroll is enabled.
           */
          if (refreshnow)
            {
              scr_refresh ();
              want_refresh = 1;
            }
        }
      else
        {
          try
            {
              process_nonprinting (ch);
            }
          catch (const class out_of_input &o)
            {
              // we ran out of input, retry later
              cmdbuf_ptr = seq_begin;
              break;
            }

          ch = NOCHAR;
        }
    }
}

// read the next character
wchar_t
rxvt_term::next_char ()
{
  while (cmdbuf_ptr < cmdbuf_endp)
    {
      // assume 7-bit to be ascii ALWAYS
      if (__builtin_expect ((((unsigned char)*cmdbuf_ptr <= 0x7f && *cmdbuf_ptr != 0x1b) != 0),(1)))
        return *cmdbuf_ptr++;

      wchar_t wc;
      size_t len = mbrtowc (&wc, cmdbuf_ptr, cmdbuf_endp - cmdbuf_ptr, mbstate);

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }

      if (len == (size_t)-1)
        {
          mbrtowc (0, 0, 0, mbstate); // reset now undefined conversion state
          return (unsigned char)*cmdbuf_ptr++; // the _occasional_ latin1 character is allowed to slip through
        }

      // assume wchar == unicode
      cmdbuf_ptr += len;
      return wc & 0x1fffffUL;
    }

  return NOCHAR;
}

// read the next octet
uint32_t
rxvt_term::next_octet ()
{
  return cmdbuf_ptr < cmdbuf_endp
         ? (unsigned char)*cmdbuf_ptr++
         : NOCHAR;
}

static class out_of_input out_of_input;

/* rxvt_cmd_getc () - Return next input character */
/*
 * Return the next input character after first passing any keyboard input
 * to the command.
 */
wchar_t
rxvt_term::cmd_getc ()
{
  wchar_t c = next_char ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

uint32_t
rxvt_term::cmd_get8 ()
{
  uint32_t c = next_octet ();

  if (c == NOCHAR)
    throw out_of_input;

  return c;
}

/*{{{ print pipe */
/*----------------------------------------------------------------------*/

FILE *
rxvt_term::popen_printer ()
{
  FILE *stream = popen (rs[Rs_print_pipe] ? rs[Rs_print_pipe] : "lpr", "w");

  if (stream == __null)
    rxvt_warn ("can't open printer pipe, not printing.\n");

  return stream;
}

int
rxvt_term::pclose_printer (FILE *stream)
{
  fflush (stream);
  return pclose (stream);
}

/*
 * simulate attached vt100 printer
 */
void
rxvt_term::process_print_pipe ()
{
  FILE *fd = popen_printer ();

  if (!fd)
    return;

  /*
   * Send all input to the printer until either ESC[4i or ESC[?4i
   * is received.
   */
  for (int done = 0; !done; )
    {
      unsigned char buf[8];
      unicode_t ch;
      unsigned int i, len;

      if ((ch = cmd_getc ()) != C0_ESC)
        {
          if (putc (ch, fd) == (-1))
            break; /* done = 1 */
        }
      else
        {
          len = 0;
          buf[len++] = ch;

          if ((buf[len++] = cmd_getc ()) == '[')
            {
              if ((ch = cmd_getc ()) == '?')
                {
                  buf[len++] = '?';
                  ch = cmd_getc ();
                }
              if ((buf[len++] = ch) == '4')
                {
                  if ((buf[len++] = cmd_getc ()) == 'i')
                    break; /* done = 1 */
                }
            }

          for (i = 0; i < len; i++)
            if (putc (buf[i], fd) == (-1))
              {
                done = 1;
                break;
              }
        }
    }

  pclose_printer (fd);
}

/*}}} */

/* *INDENT-OFF* */
enum {
  C1_40 = 0x40,
          C1_41 , C1_BPH, C1_NBH, C1_44 , C1_NEL, C1_SSA, C1_ESA,
  C1_HTS, C1_HTJ, C1_VTS, C1_PLD, C1_PLU, C1_RI , C1_SS2, C1_SS3,
  C1_DCS, C1_PU1, C1_PU2, C1_STS, C1_CCH, C1_MW , C1_SPA, C1_EPA,
  C1_SOS, C1_59 , C1_SCI, C1_CSI, CS_ST , C1_OSC, C1_PM , C1_APC,
};
/* *INDENT-ON* */

/*{{{ process non-printing single characters */
void
rxvt_term::process_nonprinting (unicode_t ch)
{
  switch (ch)
    {
      case C0_ESC:
        process_escape_seq ();
        break;
      case C0_ENQ: /* terminal Status */
        if (rs[Rs_answerbackstring])
          tt_write (rs [Rs_answerbackstring], (strlen)(rs [Rs_answerbackstring]));
        else
          tt_write ("\033[?1;2c" /* vt100 answerback */, (strlen)("\033[?1;2c" /* vt100 answerback */));
        break;
      case C0_BEL: /* bell */
        scr_bell ();
        break;
      case C0_BS: /* backspace */
        scr_backspace ();
        break;
      case C0_HT: /* tab */
        scr_tab (1);
        break;
      case C0_CR: /* carriage return */
        scr_gotorc (0, 0, R_RELATIVE);
        break;
      case C0_VT: /* vertical tab, form feed */
      case C0_FF:
      case C0_LF: /* line feed */
        scr_index (UP);
        break;
      case C0_SO: /* shift out - acs */
        scr_charset_choose (1);
        break;
      case C0_SI: /* shift in - acs */
        scr_charset_choose (0);
        break;
# 2532 "command.C"
    }
}
/*}}} */


/*{{{ process VT52 escape sequences */
void
rxvt_term::process_escape_vt52 (unicode_t ch)
{
  int row, col;

  switch (ch)
    {
      case 'A': /* cursor up */
        scr_gotorc (-1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'B': /* cursor down */
        scr_gotorc (1, 0, R_RELATIVE | C_RELATIVE);
        break;
      case 'C': /* cursor right */
        scr_gotorc (0, 1, R_RELATIVE | C_RELATIVE);
        break;
      case 'D': /* cursor left */
        scr_gotorc (0, -1, R_RELATIVE | C_RELATIVE);
        break;
      case 'H': /* cursor home */
        scr_gotorc (0, 0, 0);
        break;
      case 'I': /* cursor up and scroll down if needed */
        scr_index (DN);
        break;
      case 'J': /* erase to end of screen */
        scr_erase_screen (0);
        break;
      case 'K': /* erase to end of line */
        scr_erase_line (0);
        break;
      case 'Y': /* move to specified row and col */
        /* full command is 'ESC Y row col' where row and col
         * are encoded by adding 32 and sending the ascii
         * character.  eg. SPACE = 0, '+' = 13, '0' = 18,
         * etc. */
        row = cmd_getc () - ' ';
        col = cmd_getc () - ' ';
        scr_gotorc (row, col, 0);
        break;
      case 'Z': /* identify the terminal type */
        tt_printf ("\033/Z"); /* I am a VT100 emulating a VT52 */
        break;
      case '<': /* turn off VT52 mode */
        set_privmode ((1UL<<18), 0);
        break;
      case 'F': /* use special graphics character set */
      case 'G': /* use regular character set */
        /* unimplemented */
        break;
      case '=': /* use alternate keypad mode */
      case '>': /* use regular keypad mode */
        /* unimplemented */
        break;
    }
}
/*}}} */


/*{{{ process escape sequences */
void
rxvt_term::process_escape_seq ()
{
  unicode_t ch = cmd_getc ();

  if (priv_modes & (1UL<<18))
    {
      process_escape_vt52 (ch);
      return;
    }

  switch (ch)
    {
        /* case 1:        do_tek_mode (); break; */
      case '#':
        if (cmd_getc () == '8')
          scr_E ();
        break;
      case '(':
        scr_charset_set (0, (unsigned int)cmd_getc ());
        break;
      case ')':
        scr_charset_set (1, (unsigned int)cmd_getc ());
        break;
      case '*':
        scr_charset_set (2, (unsigned int)cmd_getc ());
        break;
      case '+':
        scr_charset_set (3, (unsigned int)cmd_getc ());
        break;





      case '7':
        scr_cursor (SAVE);
        break;
      case '8':
        scr_cursor (RESTORE);
        break;





      case '=':
      case '>':
        set_privmode ((1UL<<7), ch == '=');
        break;

      case C1_40:
        cmd_getc ();
        break;
      case C1_44:
        scr_index (UP);
        break;

        /* 8.3.87: NEXT LINE */
      case C1_NEL: /* ESC E */
        {
          wchar_t nlcr[] = { C0_LF, C0_CR };
          scr_add_lines (nlcr, sizeof (nlcr) / sizeof (nlcr [0]), 1);
        }
        break;

        /* kidnapped escape sequence: Should be 8.3.48 */
      case C1_ESA: /* ESC G */
        process_graphics ();
        break;

        /* 8.3.63: CHARACTER TABULATION SET */
      case C1_HTS: /* ESC H */
        scr_set_tab (1);
        break;

        /* 8.3.105: REVERSE LINE FEED */
      case C1_RI: /* ESC M */
        scr_index (DN);
        break;

        /* 8.3.142: SINGLE-SHIFT TWO */
      /*case C1_SS2: scr_single_shift (2);   break; */

        /* 8.3.143: SINGLE-SHIFT THREE */
      /*case C1_SS3: scr_single_shift (3);   break; */

        /* 8.3.27: DEVICE CONTROL STRING */
      case C1_DCS: /* ESC P */
        process_dcs_seq ();
        break;

        /* 8.3.110: SINGLE CHARACTER INTRODUCER */
      case C1_SCI: /* ESC Z */
        tt_write ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */, sizeof ("\033[?1;2c" /* vt100 answerback */ /* obsolete ANSI ESC[c */) - 1);
        break; /* steal obsolete ESC [ c */

        /* 8.3.16: CONTROL SEQUENCE INTRODUCER (CSI) */
      case C1_CSI: /* ESC [ */
        process_csi_seq ();
        break;

        /* 8.3.90: OPERATING SYSTEM COMMAND (OSC) */
      case C1_OSC: /* ESC ] */
        process_osc_seq ();
        break;

        /* 8.3.106: RESET TO INITIAL STATE (RIS) */
      case 'c':
        mbstate.reset ();
        scr_poweron ();
        scrollBar.show (1);
        break;

        /* 8.3.79: LOCKING-SHIFT TWO (see ISO2022) */
      case 'n':
        scr_charset_choose (2);
        break;

        /* 8.3.81: LOCKING-SHIFT THREE (see ISO2022) */
      case 'o':
        scr_charset_choose (3);
        break;
    }
}
/*}}} */

/*{{{ process CONTROL SEQUENCE INTRODUCER (CSI) sequences `ESC[' */
/* *INDENT-OFF* */
enum {
  CSI_ICH = 0x40,
           CSI_CUU, CSI_CUD, CSI_CUF, CSI_CUB, CSI_CNL, CSI_CPL, CSI_CHA,
  CSI_CUP, CSI_CHT, CSI_ED , CSI_EL , CSI_IL , CSI_DL , CSI_EF , CSI_EA ,
  CSI_DCH, CSI_SEE, CSI_CPR, CSI_SU , CSI_SD , CSI_NP , CSI_PP , CSI_CTC,
  CSI_ECH, CSI_CVT, CSI_CBT, CSI_SRS, CSI_PTX, CSI_SDS, CSI_SIMD, CSI_5F,
  CSI_HPA, CSI_HPR, CSI_REP, CSI_DA , CSI_VPA, CSI_VPR, CSI_HVP, CSI_TBC,
  CSI_SM , CSI_MC , CSI_HPB, CSI_VPB, CSI_RM , CSI_SGR, CSI_DSR, CSI_DAQ,
  CSI_70 , CSI_71 , CSI_72 , CSI_73 , CSI_74 , CSI_75 , CSI_76 , CSI_77 ,
  CSI_78 , CSI_79 , CSI_7A , CSI_7B , CSI_7C , CSI_7D , CSI_7E , CSI_7F
};







const unsigned char csi_defaults[] =
  {
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (1)), /* @, A, B, C, D, E, F, G, */
    (((1) << 7) | ((1) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((0) << 1) | (0)), /* H, I, J, K, L, M, N, O, */
    (((1) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* P, Q, R, S, T, U, V, W, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((1) << 1) | (0)), /* X, Y, Z, [, \, ], ^, _, */
    (((1) << 7) | ((1) << 6) | ((1) << 5) | ((0) << 4) | ((1) << 3) | ((1) << 2) | ((1) << 1) | (0)), /* `, a, b, c, d, e, f, g, */
    (((0) << 7) | ((0) << 6) | ((1) << 5) | ((1) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* h, i, j, k, l, m, n, o, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* p, q, r, s, t, u, v, w, */
    (((0) << 7) | ((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | ((0) << 2) | ((0) << 1) | (0)), /* x, y, z, {, |, }, ~,    */
  };
/* *INDENT-ON* */

void
rxvt_term::process_csi_seq ()
{
  unicode_t ch, priv, i;
  unsigned int nargs, p;
  int n, ndef;
  int arg[32 /* max # of args for esc sequences */] = { };

  nargs = 0;

  priv = 0;
  ch = cmd_getc ();
  if ((ch >= '<' && ch <= '?') || ch == '!')
    {
      /* '<' '=' '>' '?' '!' */
      priv = ch;
      ch = cmd_getc ();
    }

  /* read any numerical arguments */
  for (n = -1; ch < CSI_ICH; )
    {
      if (isdigit (ch))
        {
          if (n < 0)
            n = ch - '0';
          else
            n = n * 10 + ch - '0';
        }
      else if (ch == ';')
        {
          if (nargs < 32 /* max # of args for esc sequences */)
            arg[nargs++] = n;
          n = -1;
        }
      else if (!((ch) & 0xffffff60UL))
        process_nonprinting (ch);

      ch = cmd_getc ();
    }

  if (ch > CSI_7F)
    return;

  if (nargs < 32 /* max # of args for esc sequences */)
    arg[nargs++] = n;

  i = ch - CSI_ICH;
  ndef = (!! ((csi_defaults)[ (i) / 8] & (128 >> ((i) & 7))));
  for (p = 0; p < nargs; p++)
    if (arg[p] == -1)
      arg[p] = ndef;

  /*
   * private mode handling
   */
  if (priv)
    {
      switch (priv)
        {
          case '>':
            if (ch == CSI_DA) /* secondary device attributes */
              {
                // first parameter is normally 0 for vt100, 1 for vt220, 'R' for rxvt,
                // 'U' for rxvt-unicode != 7.[34] (where it was broken).
                //
                // second parameter is xterm patch level for xterm, MMmmpp (e.g. 20703) for rxvt
                // and Mm (e.g. 72 for 7.2) for urxvt <= 7.2, 94 for urxvt <= 8.3, and 95 for later
                // versions.
                //
                tt_printf ("\033[>%d;95;0c", 'U');
              }
            break;

          case '?':
            if (ch == 'h' || ch == 'l' || ch == 'r' || ch == 's' || ch == 't')
              process_terminal_mode (ch, priv, nargs, arg);
            break;

          case '!':
            if (ch == CSI_70)
              {
                /* DECSTR: soft terminal reset, used by our terminfo since 9.06 */
                scr_soft_reset ();

                static const int pm_h[] = { 7, 25 };
                static const int pm_l[] = { 1, 3, 4, 5, 6, 9, 66, 1000, 1001, 1049 };

                process_terminal_mode ('h', 0, sizeof (pm_h) / sizeof (pm_h[0]), pm_h);
                process_terminal_mode ('l', 0, sizeof (pm_l) / sizeof (pm_l[0]), pm_l);
              }
          break;
        }

      return;
    }

  switch (ch)
    {
        /*
         * ISO/IEC 6429:1992 (E) CSI sequences (defaults in parentheses)
         */

      case CSI_MC: /* 8.3.83: (0) MEDIA COPY */
        switch (arg[0])
          {
            case 0: /* initiate transfer to primary aux device */
              scr_printscreen (0);
              break;
            case 5: /* start relay to primary aux device */
              process_print_pipe ();
              break;
          }
        break;


      case CSI_CUU: /* 8.3.22: (1) CURSOR UP */
      case CSI_VPR: /* 8.3.161: (1) LINE POSITION FORWARD */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CUD: /* 8.3.19: (1) CURSOR DOWN */
      case CSI_VPB: /* 8.3.160: (1) LINE POSITION BACKWARD */
        scr_gotorc (arg[0], 0, RELATIVE);
        break;

      case CSI_CUB: /* 8.3.18: (1) CURSOR LEFT */
      case CSI_HPB: /* 8.3.59: (1) CHARACTER POSITION BACKWARD */



        arg[0] = arg[0] ? -arg[0] : -1;

        /* FALLTHROUGH */
      case CSI_CUF: /* 8.3.20: (1) CURSOR RIGHT */
      case CSI_HPR: /* 8.3.60: (1) CHARACTER POSITION FORWARD */



        scr_gotorc (0, arg[0] ? arg[0] : 1, RELATIVE);

        break;

      case CSI_CPL: /* 8.3.13: (1) CURSOR PRECEDING LINE */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CNL: /* 8.3.12: (1) CURSOR NEXT LINE */
        scr_gotorc (arg[0], 0, R_RELATIVE);
        break;

      case CSI_CHA: /* 8.3.9: (1) CURSOR CHARACTER ABSOLUTE */
      case CSI_HPA: /* 8.3.58: (1) CURSOR POSITION ABSOLUTE */
        scr_gotorc (0, arg[0] - 1, R_RELATIVE);
        break;

      case CSI_VPA: /* 8.3.159: (1) LINE POSITION ABSOLUTE */
        scr_gotorc (arg[0] - 1, 0, C_RELATIVE);
        break;

      case CSI_CUP: /* 8.3.21: (1,1) CURSOR POSITION */
      case CSI_HVP: /* 8.3.64: (1,1) CHARACTER AND LINE POSITION */
        scr_gotorc (arg[0] - 1, nargs < 2 ? 0 : (arg[1] - 1), 0);
        break;

      case CSI_CBT: /* 8.3.7: (1) CURSOR BACKWARD TABULATION */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_CHT: /* 8.3.10: (1) CURSOR FORWARD TABULATION */
        scr_tab (arg[0]);
        break;

      case CSI_ED: /* 8.3.40: (0) ERASE IN PAGE */
        scr_erase_screen (arg[0]);
        break;

      case CSI_EL: /* 8.3.42: (0) ERASE IN LINE */
        scr_erase_line (arg[0]);
        break;

      case CSI_ICH: /* 8.3.65: (1) INSERT CHARACTER */
        scr_insdel_chars (arg[0], INSERT);
        break;

      case CSI_IL: /* 8.3.68: (1) INSERT LINE */
        scr_insdel_lines (arg[0], INSERT);
        break;

      case CSI_DL: /* 8.3.33: (1) DELETE LINE */
        scr_insdel_lines (arg[0], DELETE);
        break;

      case CSI_ECH: /* 8.3.39: (1) ERASE CHARACTER */
        scr_insdel_chars (arg[0], ERASE);
        break;

      case CSI_DCH: /* 8.3.26: (1) DELETE CHARACTER */
        scr_insdel_chars (arg[0], DELETE);
        break;

      case CSI_SD: /* 8.3.114: (1) SCROLL DOWN */
        arg[0] = -arg[0];
        /* FALLTHROUGH */
      case CSI_SU: /* 8.3.148: (1) SCROLL UP */
        scr_scroll_text (screen.tscroll, screen.bscroll, arg[0]);
        break;

      case CSI_DA: /* 8.3.24: (0) DEVICE ATTRIBUTES */
        tt_write ("\033[?1;2c" /* vt100 answerback */, sizeof ("\033[?1;2c" /* vt100 answerback */) - 1);
        break;

      case CSI_SGR: /* 8.3.118: (0) SELECT GRAPHIC RENDITION */
        process_sgr_mode (nargs, arg);
        break;

      case CSI_DSR: /* 8.3.36: (0) DEVICE STATUS REPORT */
        switch (arg[0])
          {
            case 5: /* DSR requested */
              tt_printf ("\033[0n");
              break;
            case 6: /* CPR requested */
              scr_report_position ();
              break;
            case 7: /* unofficial extension */
              if (option (Opt_insecure))
                tt_printf ("%-.250s\012", rs[Rs_display_name]);
              break;
            case 8: /* unofficial extension */
              process_xterm_seq (XTerm_title, "urxvt" "-" "9.06", 0x9c /* 0234 */);
              break;
          }
        break;

      case CSI_TBC: /* 8.3.155: (0) TABULATION CLEAR */
        switch (arg[0])
          {
            case 0: /* char tab stop cleared at active position */
              scr_set_tab (0);
              break;
              /* case 1: */ /* line tab stop cleared in active line */
              /* case 2: */ /* char tab stops cleared in active line */
            case 3: /* all char tab stops are cleared */
              /* case 4: */ /* all line tab stops are cleared */
            case 5: /* all tab stops are cleared */
              scr_set_tab (-1);
              break;
          }
        break;

      case CSI_CTC: /* 8.3.17: (0) CURSOR TABULATION CONTROL */
        switch (arg[0])
          {
            case 0: /* char tab stop set at active position */
              scr_set_tab (1);
              break; /* = ESC H */
              /* case 1: */ /* line tab stop set at active line */
            case 2: /* char tab stop cleared at active position */
              scr_set_tab (0);
              break; /* = ESC [ 0 g */
              /* case 3: */ /* line tab stop cleared at active line */
              /* case 4: */ /* char tab stops cleared at active line */
            case 5: /* all char tab stops are cleared */
              scr_set_tab (-1);
              break; /* = ESC [ 3 g */
              /* case 6: */ /* all line tab stops are cleared */
          }
        break;

      case CSI_RM: /* 8.3.107: RESET MODE */
        if (arg[0] == 4)
          scr_insert_mode (0);
        else if (arg[0] == 20)
          priv_modes &= ~(1UL<<19);
        break;

      case CSI_SM: /* 8.3.126: SET MODE */
        if (arg[0] == 4)
          scr_insert_mode (1);
        else if (arg[0] == 20)
          priv_modes |= (1UL<<19);
        break;

        /*
         * PRIVATE USE beyond this point.  All CSI_7? sequences here
         */
      case CSI_72: /* DECSTBM: set top and bottom margins */
        if (nargs == 1)
          scr_scroll_region (arg[0] - 1, 10000 - 1);
        else if (nargs == 0 || arg[0] >= arg[1])
          scr_scroll_region (0, 10000 - 1);
        else
          scr_scroll_region (arg[0] - 1, arg[1] - 1);
        break;

      case CSI_73:
        scr_cursor (SAVE);
        break;
      case CSI_75:
        scr_cursor (RESTORE);
        break;







      case CSI_78: /* DECREQTPARM */
        if (arg[0] == 0 || arg[0] == 1)
          tt_printf ("\033[%d;1;1;128;128;1;0x", arg[0] + 2);
        break;

      default:
        break;
    }
}
/*}}} */
# 3171 "command.C"
/*----------------------------------------------------------------------*/
/*
 * get input up until STRING TERMINATOR (or BEL)
 * ends_how is terminator used. returned input must be free()'d
 */
char *
rxvt_term::get_to_st (unicode_t &ends_how)
{
  unicode_t ch;
  bool seen_esc = false;
  unsigned int n = 0;
  wchar_t string[2048 /* max string size for process_rxvt_xterm_seq() */];

  while ((ch = cmd_getc ()) != NOCHAR)
    {
      if (seen_esc)
        {
          if (ch == 0x5c) /* 7bit ST */
            break;
          else
            return __null;
        }
      else if (ch == C0_ESC)
        {
          seen_esc = true;
          continue;
        }
      else if (ch == C0_BEL || ch == 0x9c /* 0234 */)
        break;
      else if (ch == C0_SYN)
        ch = cmd_get8 ();
      else if (ch < 0x20)
        return __null; /* other control character - exit */

      seen_esc = false;

      if (n >= 2048 /* max string size for process_rxvt_xterm_seq() */ - 1)
        // stop at some sane length
        return __null;

      string[n++] = ch;
    }

  string[n++] = '\0';

  ends_how = (ch == 0x5c ? C0_ESC : ch);

  return rxvt_wcstombs (string);
}

/*----------------------------------------------------------------------*/
/*
 * process DEVICE CONTROL STRING `ESC P ... (ST|BEL)' or `0x90 ... (ST|BEL)'
 */
void
rxvt_term::process_dcs_seq ()
{
  char *s;
  unicode_t eh;

  /*
   * Not handled yet
   */
  s = get_to_st (eh);
  if (s)
    free (s);

  return;
}

/*----------------------------------------------------------------------*/
/*
 * process OPERATING SYSTEM COMMAND sequence `ESC ] Ps ; Pt (ST|BEL)'
 */
void
rxvt_term::process_osc_seq ()
{
  unicode_t ch, eh;
  int arg;

  ch = cmd_getc ();
  for (arg = 0; isdigit (ch); ch = cmd_getc ())
    arg = arg * 10 + (ch - '0');

  if (ch == ';')
    {
      char *s = get_to_st (eh);

      if (s)
        {
          process_xterm_seq (arg, s, eh);
          free (s);
        }
    }
}

void
rxvt_term::process_color_seq (int report, int color, const char *str, char resp)
{
  if (str[0] == '?' && !str[1])
    {
      rgba c;
      pix_colors_focused[color].get (c);






        tt_printf ("\033]%d;rgb:%04x/%04x/%04x%c", report, c.r, c.g, c.b, resp);
    }
  else
    set_window_color (color, str);
}

/*
 * XTerm escape sequences: ESC ] Ps;Pt (ST|BEL)
 */
void
rxvt_term::process_xterm_seq (int op, const char *str, char resp)
{
  int color;
  char *buf, *name;
  bool query = str[0] == '?' && !str[1];
  int saveop = op;

  Display * const dpy = this->dpy;

  (__builtin_expect(!(str != __null), 0) ? __assert_rtn(__func__, "command.C", 3299, "str != NULL") : (void)0);

  if (false)
    return;

  switch (op)
    {
      case XTerm_name:
        set_title (str);
        /* FALLTHROUGH */
      case XTerm_iconName:
        set_icon_name (str);
        break;
      case XTerm_title:
        set_title (str);
        break;
      case XTerm_property:
        if (str[0] == '?')
          {
            Atom prop = display->atom (str + 1);
            Atom actual_type;
            int actual_format;
            unsigned long nitems;
            unsigned long bytes_after;
            unsigned char *value = 0;
            const char *str = "";

            if (prop
                && XGetWindowProperty (dpy, parent[0],
                                       prop, 0, 1<<16, 0, 0L /* special Atom, passed to GetProperty */,
                                       &actual_type, &actual_format,
                                       &nitems, &bytes_after, &value) == 0 /* everything's okay */
                && actual_type != 0L /* universal null resource or null atom */
                && actual_format == 8)
              str = (const char *)(value);

            tt_printf ("\033]%d;%s%c", op, str, resp);

            XFree (value);
          }
        else
          {
            char *eq = strchr (str, '='); // constness lost, but verified to be ok

            if (eq)
              {
                *eq = 0;
                set_utf8_property (display->atom (str), eq + 1);
              }
            else
              XDeleteProperty (dpy, parent[0],
                               display->atom (str));
          }
        break;

      case XTerm_Color:
        for (buf = (char *)str; buf && *buf;)
          {
            if ((name = strchr (buf, ';')) == __null)
              break;

            *name++ = '\0';
            color = atoi (buf) + minCOLOR;

            if (!((unsigned int)(color) - (unsigned int)(minCOLOR) <= (unsigned int)(maxTermCOLOR) - (unsigned int)(minCOLOR)))
              break;

            if ((buf = strchr (name, ';')) != __null)
              *buf++ = '\0';

            process_color_seq (op, color, name, resp);
          }
        break;
      case Rxvt_restoreFG:
      case XTerm_Color00:
        process_color_seq (op, Color_fg, str, resp);
        break;
      case Rxvt_restoreBG:
      case XTerm_Color01:
        process_color_seq (op, Color_bg, str, resp);
        break;

      case XTerm_Color_cursor:
        process_color_seq (op, Color_cursor, str, resp);
        break;

      case XTerm_Color_pointer_fg:
        process_color_seq (op, Color_pointer_fg, str, resp);
        break;
      case XTerm_Color_pointer_bg:
        process_color_seq (op, Color_pointer_bg, str, resp);
        break;

      case XTerm_Color_RV:
        process_color_seq (op, Color_RV, str, resp);
        break;
      case Rxvt_Color_BD:
      case URxvt_Color_BD:
        process_color_seq (op, Color_BD, str, resp);
        break;
      case Rxvt_Color_UL:
      case URxvt_Color_UL:
        process_color_seq (op, Color_UL, str, resp);
        break;
      case URxvt_Color_IT:
        process_color_seq (op, Color_IT, str, resp);
        break;

      case URxvt_Color_border:
        process_color_seq (op, Color_border, str, resp);
        break;
# 3468 "command.C"
      case XTerm_logfile:
        // TODO, when secure mode?
        break;
# 3484 "command.C"
      case XTerm_font:
        op = URxvt_font;
      case URxvt_font:





        if (query)
          tt_printf ("\33]%d;%-.250s%c", saveop,
                     option (Opt_insecure) && fontset[op - URxvt_font]->fontdesc
                       ? fontset[op - URxvt_font]->fontdesc : "",
                     resp);
        else
          {
            const char *&res = rs[Rs_font + (op - URxvt_font)];

            res = strdup (str);
            allocated.push_back ((void *)res);
            set_fonts ();
          }
        break;

      case URxvt_version:
        if (query)
          tt_printf ("\33]%d;rxvt-unicode;%-.20s;%c;%c%c",
                     op,
                     rs[Rs_name], "9.06"[0], "9.06"[2],
                     resp);
        break;
# 3546 "command.C"
    }
}
/*----------------------------------------------------------------------*/

/*{{{ process DEC private mode sequences `ESC [ ? Ps mode' */
/*
 * mode can only have the following values:
 *      'l' = low
 *      'h' = high
 *      's' = save
 *      'r' = restore
 *      't' = toggle
 * so no need for fancy checking
 */
int
rxvt_term::privcases (int mode, unsigned long bit)
{
  int state;

  if (mode == 's')
    {
      SavedModes |= (priv_modes & bit);
      return -1;
    }
  else
    {
      if (mode == 'r')
        state = (SavedModes & bit) ? 1 : 0; /* no overlapping */
      else
        state = (mode == 't') ? ! (priv_modes & bit) : mode;
      set_privmode (bit, state);
    }

  return state;
}

/* we're not using priv _yet_ */
void
rxvt_term::process_terminal_mode (int mode, int priv __attribute__((unused)), unsigned int nargs, const int *arg)
{
  unsigned int i, j;
  int state;

  static const struct
  {
    const int argval;
    const unsigned long bit;
  } argtopriv[] = {
                  { 1, (1UL<<6) }, // DECCKM
                  { 2, (1UL<<18) },
                  { 3, (1UL<<0) }, // DECCOLM
                  { 4, (1UL<<17) }, // DECSCLM
                  { 5, (1UL<<2) }, // DECSCNM
                  { 6, (1UL<<3) }, // DECOM
                  { 7, (1UL<<5) }, // DECAWM
                 // 8, auto-repeat keys         // DECARM
                  { 9, (1UL<<12) },
                 // 18 end FF to printer after print screen
                 // 19 Print screen prints full screen/scorll region
                  { 25, (1UL<<11) }, // cnorm/cvvis/civis

                  { 30, (1UL<<14) },

                  { 35, (1UL<<10) }, // rxvt extension
                 // 38, tektronix mode          // DECTEK
                  { 40, (1UL<<1) },
                 // 41 xterm more fixes NYI
                 // 45 margin bell NYI
                 // 46 start logging
                  { 47, (1UL<<4) },
                  { 66, (1UL<<7) }, // DECPAM/DECPNM



                  { 1000, (1UL<<13) },
                  { 1002, (1UL<<20) },
                  { 1003, (1UL<<21) },
                  { 1010, (1UL<<15) }, // rxvt extension
                  { 1011, (1UL<<16) }, // rxvt extension
                 // 1035 enable modifiers for alt, numlock NYI
                 // 1036 send ESC for meta keys NYI
                 // 1037 send DEL for keypad delete NYI
                  { 1047, (1UL<<4) },
                 // 1048 save and restore cursor
                  { 1049, (1UL<<4) }, /* xterm extension, clear screen on ti rather than te */
                 // 1051, 1052, 1060, 1061 keyboard emulation NYI
                  { 2004, (1UL<<22) },
                };

  if (nargs == 0)
    return;

  /* make lo/hi boolean */
  if (mode == 'l')
    mode = 0; /* reset */
  else if (mode == 'h')
    mode = 1; /* set */

  for (i = 0; i < nargs; i++)
    {
      state = -1;

      /* basic handling */
      for (j = 0; j < (sizeof (argtopriv)/sizeof (argtopriv[0])); j++)
        if (argtopriv[j].argval == arg[i])
          {
            state = privcases (mode, argtopriv[j].bit);
            break;
          }

      /* extra handling for values with state unkept  */
      switch (arg[i])
        {







          case 1048: /* alternative cursor save */
            if (option (Opt_secondaryScreen))
              if (mode == 0)
                scr_cursor (RESTORE);
              else if (mode == 1)
                scr_cursor (SAVE);
            break;
        }

      if (state >= 0)
        /* extra handling for values with valid 0 or 1 state */
        switch (arg[i])
          {
              /* case 1:	- application cursor keys */
            case 2: /* VT52 mode */
              /* oddball mode.  should be set regardless of set/reset
               * parameter.  Return from VT52 mode with an ESC < from
               * within VT52 mode
               */
              set_privmode ((1UL<<18), 1);
              break;
            case 3: /* 80/132 */
              if (priv_modes & (1UL<<1))
                set_widthheight ((state ? 132 : 80) * fwidth, 24 * fheight);
              break;
            case 4: /* smooth scrolling */
              set_option (Opt_jumpScroll, !state);
              break;
            case 5: /* reverse video */
              scr_rvideo_mode (state);
              break;
            case 6: /* relative/absolute origins  */
              scr_relative_origin (state);
              break;
            case 7: /* autowrap */
              scr_autowrap (state);
              break;
            /* case 8:	- auto repeat, can't do on a per window basis */
            case 9: /* X10 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<13)|(1UL<<20)|(1UL<<21));
              break;

            case 30:
              if (scrollBar.map (state))
                {
                  resize_all_windows (0, 0, 0);
                  scr_touch (true);
                }
              break;

            case 25: /* visible/invisible cursor */
              scr_cursor_visible (state);
              break;
            /* case 35:	- shift keys */
            /* case 40:	- 80 <--> 132 mode */
            case 47: /* secondary screen */
              scr_change_screen (state);
              break;
            /* case 66:	- application key pad */
            /* case 67:	- backspace key */
            case 1000: /* X11 mouse reporting */
              if (state) /* orthogonal */
                priv_modes &= ~((1UL<<12)|(1UL<<20)|(1UL<<21));
              break;
            case 1002:
            case 1003:
              if (state)
                {
                  priv_modes &= ~((1UL<<12)|(1UL<<13));
                  priv_modes &= arg[i] == 1003 ? ~(1UL<<20) : ~(1UL<<21);
                  vt_emask_mouse = (1L<<6);
                }
              else
                vt_emask_mouse = 0L;

              vt_select_input ();
              break;
            case 1010: /* scroll to bottom on TTY output inhibit */
              set_option (Opt_scrollTtyOutput, !state);
              break;
            case 1011: /* scroll to bottom on key press */
              set_option (Opt_scrollTtyKeypress, state);
              break;
            case 1047: /* secondary screen w/ clearing last */
              if (option (Opt_secondaryScreen))
                if (!state)
                  scr_erase_screen (2);

              scr_change_screen (state);
              break;
            case 1049: /* secondary screen w/ clearing first */
              if (option (Opt_secondaryScreen))
                if (state)
                  scr_cursor (SAVE);

              scr_change_screen (state);

              if (option (Opt_secondaryScreen))
                if (state)
                  scr_erase_screen (2);
                else
                  scr_cursor (RESTORE);
              break;
            default:
              break;
          }
    }
}
/*}}} */

/*{{{ process sgr sequences */
void
rxvt_term::process_sgr_mode (unsigned int nargs, const int *arg)
{
  unsigned int i;
  short rendset;
  int rendstyle;

  if (nargs == 0)
    {
      scr_rendition (0, ~0);
      return;
    }

  for (i = 0; i < nargs; i++)
    {
      rendset = -1;
      switch (arg[i])
        {
          case 0:
            rendset = 0, rendstyle = ~0;
            break;
          case 1:
            rendset = 1, rendstyle = 0x00004000UL /* value 1*/;
            break;
          //case 2: // low intensity
          case 3:
            rendset = 1, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 4:
            rendset = 1, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 5: // slowly blinking
          case 6: // rapidly blinking
            rendset = 1, rendstyle = 0x00010000UL /* blink*/;
            break;
          //case 6: // scoansi light background
          case 7:
            rendset = 1, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          case 8:
            // invisible. NYI
            break;
          //case 9: // crossed out
          //case 10: // scoansi acs off, primary font
          //case 11: // scoansi acs on, first alt font
          //case 12: // scoansi acs on, |0x80, second alt font
          //...
          //case 19: // ninth alt font
          //case 20: // gothic
          case 21: // disable bold, faint, sometimes doubly underlined (iso 8613)
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
          case 22: // normal intensity
            rendset = 0, rendstyle = 0x00004000UL /* value 1*/;
            break;
          case 23: // disable italic
            rendset = 0, rendstyle = 0x00008000UL /* value 2*/;
            break;
          case 24:
            rendset = 0, rendstyle = 0x00040000UL /* underline*/;
            break;
          case 25:
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 26: // variable spacing (iso 8613)
            rendset = 0, rendstyle = 0x00010000UL /* blink*/;
            break;
          case 27:
            rendset = 0, rendstyle = 0x00020000UL /* reverse video*/;
            break;
          //case 28: // visible. NYI
          //case 29: // not crossed-out
        }

      if (rendset != -1)
        {
          scr_rendition (rendset, rendstyle);
          continue; /* for (;i;) */
        }

      switch (arg[i])
        {
          case 30:
          case 31: /* set fg color */
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
            scr_color ((unsigned int) (minCOLOR + (arg[i] - 30)), Color_fg);
            break;
          case 38: // set fg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5)
              {
                scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_fg);
                i += 2;
              }
            break;
          case 39: /* default fg */
            scr_color (Color_fg, Color_fg);
            break;

          case 40:
          case 41: /* set bg color */
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
            scr_color ((unsigned int) (minCOLOR + (arg[i] - 40)), Color_bg);
            break;
          case 48: // set bg color, ISO 8613-6
            if (nargs > i + 2 && arg[i + 1] == 5)
              {
                scr_color ((unsigned int) (minCOLOR + arg[i + 2]), Color_bg);
                i += 2;
              }
            break;
          case 49: /* default bg */
            scr_color (Color_bg, Color_bg);
            break;

          //case 50: // not variable spacing
# 3926 "command.C"
        }
    }
}
/*}}} */

/*{{{ (do not) process Rob Nation's own graphics mode sequences */
void
rxvt_term::process_graphics ()
{
  unicode_t ch, cmd = cmd_getc ();

  if (cmd == 'Q')
    {
      /* query graphics */
      tt_printf ("\033G0\012"); /* no graphics */
      return;
    }
  /* swallow other graphics sequences until terminating ':' */
  do
    ch = cmd_getc ();
  while (ch != ':');
}
/*}}} */

/* ------------------------------------------------------------------------- */

/*
 * Send printf () formatted output to the command.
 * Only use for small amounts of data.
 */
void
rxvt_term::tt_printf (const char *fmt,...)
{
  va_list arg_ptr;
  char buf[256];

  __builtin_va_start(arg_ptr,fmt);
  vsnprintf ((char *)buf, 256, fmt, arg_ptr);
  __builtin_va_end(arg_ptr);
  tt_write (buf, (strlen)(buf));
}

/* ---------------------------------------------------------------------- */
/* Write data to the pty as typed by the user, pasted with the mouse,
 * or generated by us in response to a query ESC sequence.
 */
const unsigned int MAX_PTY_WRITE = 255; // minimum MAX_INPUT

void
rxvt_term::tt_write (const char *data, unsigned int len)
{
  if (false)
    return;

  if (pty->pty < 0)
    return;

  if (v_buflen == 0)
    {
      ssize_t written = write (pty->pty, data, min (len, MAX_PTY_WRITE));

      if ((unsigned int)written == len)
        return;

      data += written;
      len -= written;
    }

  v_buffer = (char *)realloc (v_buffer, v_buflen + len);

  (memcpy)(v_buffer + v_buflen,data,len);
  v_buflen += len;

  pty_ev.set (ev::READ | ev::WRITE);
}

void rxvt_term::pty_write ()
{
  int written = write (pty->pty, v_buffer, min (v_buflen, MAX_PTY_WRITE));

  if (written > 0)
    {
      v_buflen -= written;

      if (v_buflen == 0)
        {
          free (v_buffer);
          v_buffer = 0;

          pty_ev.set (ev::READ);
          return;
        }

      memmove (v_buffer, v_buffer + written, v_buflen);
    }
  else if (written != -1 || ((*__error()) != 35 /* Resource temporarily unavailable */ && (*__error()) != 4 /* Interrupted system call */))
    pty_ev.set (ev::READ);
}

/*----------------------- end-of-file (C source) -----------------------*/
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
sed: 1: "s/^\([#] [0-9]+ .*\)/\/ ...": \1 not defined in the RE
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
../clean-file.bash: line 28: ./strip_to_orig_file_only.bash: No such file or directory
sed: 1: "s:^\([#] [0-9]+ .*\)/\/ ...": unterminated substitute in regular expression
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
sed: 1: "s:^\([#] [0-9]+ .*\)/\/ ...": unterminated substitute in regular expression
bash-3.2$ ../clean-file.bash command.C
command.C_exp.C
command.C_exp.C_strp.C
sed: 3: "/(else|[)])[ ]*$/ {\nN\ns ...": \1 not defined in the RE
bash-3.2$ cd ..
bash-3.2$ chmod +x strip_macro_defs
bash-3.2$ cat multi-line.test | ./strip_macro_defs
sed: ]*$/: No such file or directory
sed: {: No such file or directory
./strip_macro_defs: line 8: N: command not found
./strip_macro_defs: line 9: s:"$block_start"n[: command not found
./strip_macro_defs: line 10: unexpected EOF while looking for matching `''
./strip_macro_defs: line 11: syntax error: unexpected end of file
bash-3.2$ cat multi-line.test | ./strip_macro_defs
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./strip_macro_defs
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./strip_macro_defs
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
/\1
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
/\1
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./strip_macro_defs
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
 //     # 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
 //     # 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat strip_macro_defs
#!/bin/bash
### takes lines lines like  '# 38 "command.c"' and outputs lines like '//# "command.c"/

base_dir=`dirname "$0"`/
source "$base_dir"regex_vars


sed -e 's:^\([#] [0-9]\{1,\} .*\):      \/\/     \1:' 
bash-3.2$ cat strip_macro_defs
#!/bin/bash
### takes lines lines like  '# 38 "command.c"' and outputs lines like '//# "command.c"/

base_dir=`dirname "$0"`/
source "$base_dir"regex_vars


sed -e 's:^\([#] [0-9]\{1,\} .*\):      \/\/     \1:' 
bash-3.2$ cat multi-line.test | ./reformat_braces 
bash: ./reformat_braces: Permission denied
bash-3.2$ chmod +x reformat_braces 
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 1: "s:"$block_start"[\n": unbalanced brackets ([])
./reformat_braces: line 7: N: command not found
./reformat_braces: line 8: s:"$block_start"n[: command not found
./reformat_braces: line 9: unexpected EOF while looking for matching `''
./reformat_braces: line 10: syntax error: unexpected end of file
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 1: "s:(else|[)])[ ]*$/ {\nN\n ...": unterminated substitute pattern
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 1: "s:\(else|[)]\)[ ]*$/ {\n ...": unterminated substitute pattern
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 1: "s:\(else|[)]\)[ ]*$: {\n ...": unescaped newline inside substitute pattern
bash-3.2$ cat multi-line.test | ./reformat_braces 
./reformat_braces: line 8: unexpected EOF while looking for matching ``'
./reformat_braces: line 22: syntax error: unexpected end of file
bash-3.2$ cat multi-line.test | ./reformat_braces 
./reformat_braces: line 8: unexpected EOF while looking for matching ``'
./reformat_braces: line 22: syntax error: unexpected end of file
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 2: "$block_start`[ ]*$ {    ...": undefined label 'lock_start`[ ]*$ {   N                         s:\(else|[)]\).*{:\1{:      }'
bash-3.2$ cat multi-line.test | ./reformat_braces 
./reformat_braces: line 7: [: missing `]'
sed: 1: "\(else|[)]\)[\n": unbalanced brackets ([])
bash-3.2$ cat multi-line.test | ./reformat_braces 
./reformat_braces: line 7: [: missing `]'
sed: 1: "\(else|[)]\)[\n": unbalanced brackets ([])
bash-3.2$ cat multi-line.test | ./reformat_braces 
sed: 1: "\(else|)\) *$ {N s:\(el ...": unterminated regular expression
bash-3.2$ cat multi-line.test | sed 's:{'@:'
> '
sed: 1: "s:{@:\n": unescaped newline inside substitute pattern
bash-3.2$ cat multi-line.test | sed 's:{:@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
@
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
@

      if (len == (size_t)-2)
        @
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        @
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
@


bash-3.2$ cat multi-line.test | sed 's:\({|}\):\1@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\([{}]\):\1@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{@
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{@

      if (len == (size_t)-2)
        {@
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }@


      else
        {@
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{@


bash-3.2$ cat multi-line.test | sed 's:\((\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (@@XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse (@@)
{

      if (@@len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char (@@)
{


bash-3.2$ cat multi-line.test | sed 's:\()\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)@@
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()@@
{

      if (len == (size_t)@@-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()@@
{


bash-3.2$ cat multi-line.test | sed 's:\()|else\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else@@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else|)\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else|if\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\((else|if)\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else\):\1@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else@@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:(else|if):@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:(else):@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else\):@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else|if\):@@:'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed 's:\(else|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed -r 's:\(else|if\):@@:g'
sed: illegal option -- r
usage: sed script [-Ealn] [-i extension] [file ...]
       sed [-Ealn] [-i extension] [-e script] ... [-f script_file] ... [file ...]
bash-3.2$ cat multi-line.test | sed -E 's:\(else|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ 
bash-3.2$ cat multi-line.test | sed  's:\(else\|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed  's:(else\|if):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed  's:(else):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed  's:\(else\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | sed  's:\(else\|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ gsed
bash: gsed: command not found
bash-3.2$ pat
bash: pat: command not found
bash-3.2$ apt
  C-c C-cbash-3.2$ apt-get install gsed
E: Could not open lock file /sw/var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/sw/var/lib/dpkg/), are you root?
bash-3.2$ sudo apt-get install gsed
Password:
Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list file: unstable/crypto Packages (/sw/var/lib/apt/lists/_sw_fink_dists_unstable_crypto_binary-darwin-i386_Packages) - stat (2 No such file or directory)
W: Couldn't stat source package list file: unstable/crypto Packages (/sw/var/lib/apt/lists/_sw_fink_dists_unstable_crypto_binary-darwin-i386_Packages) - stat (2 No such file or directory)
W: You may want to run apt-get update to correct these problems
E: Couldn't find package gsed
bash-3.2$port

  C-c C-c
bash-3.2$ bash-3.2$ port help
port
        [-bcdfiknopqRstuvx] [-D portdir] [-F cmdfile] action [privopts] [actionflags]
        [[portname|pseudo-portname|port-url] [@version] [+-variant]... [option=value]...]...
     
Supported commands
------------------
activate, archive, build, cat, cd, checksum, clean, compact, configure,
contents, deactivate, dependents, deps, destroot, dir, distcheck, dmg,
dpkg, echo, ed, edit, exit, extract, fetch, file, gohome, help, info,
install, installed, lint, list, livecheck, location, mdmg, mirror, mpkg,
outdated, patch, pkg, provides, quit, rpm, search, selfupdate, srpm,
submit, sync, test, trace, unarchive, uncompact, uninstall, upgrade,
url, usage, variants, version, work
 
Pseudo-portnames
----------------
Pseudo-portnames are words that may be used in place of a portname, and
which expand to some set of ports. The common pseudo-portnames are:
all, current, active, inactive, installed, uninstalled, and outdated.
These pseudo-portnames expand to the set of ports named.

Additional pseudo-portnames start with...
variants:, variant:, description:, portdir:, homepage:, epoch:,
platforms:, platform:, name:, long_description:, maintainers:,
maintainer:, categories:, category:, version:, and revision:.
These each select a set of ports based on a regex search of metadata
about the ports. In all such cases, a standard regex pattern following
the colon will be used to select the set of ports to which the
pseudo-portname expands.

Portnames that contain standard glob characters will be expanded to the
set of ports matching the glob pattern.
    
Port expressions
----------------
Portnames, port glob patterns, and pseudo-portnames may be logically
combined using expressions consisting of and, or, not, !, (, and ).
    
For more information
--------------------
See man pages: port(1), macports.conf(5), portfile(7), portgroup(7),
porthier(7), portstyle(7). Also, see http://www.macports.org.
    
bash-3.2$ port help list
port
        [-bcdfiknopqRstuvx] [-D portdir] [-F cmdfile] action [privopts] [actionflags]
        [[portname|pseudo-portname|port-url] [@version] [+-variant]... [option=value]...]...
     
Supported commands
------------------
activate, archive, build, cat, cd, checksum, clean, compact, configure,
contents, deactivate, dependents, deps, destroot, dir, distcheck, dmg,
dpkg, echo, ed, edit, exit, extract, fetch, file, gohome, help, info,
install, installed, lint, list, livecheck, location, mdmg, mirror, mpkg,
outdated, patch, pkg, provides, quit, rpm, search, selfupdate, srpm,
submit, sync, test, trace, unarchive, uncompact, uninstall, upgrade,
url, usage, variants, version, work
 
Pseudo-portnames
----------------
Pseudo-portnames are words that may be used in place of a portname, and
which expand to some set of ports. The common pseudo-portnames are:
all, current, active, inactive, installed, uninstalled, and outdated.
These pseudo-portnames expand to the set of ports named.

Additional pseudo-portnames start with...
variants:, variant:, description:, portdir:, homepage:, epoch:,
platforms:, platform:, name:, long_description:, maintainers:,
maintainer:, categories:, category:, version:, and revision:.
These each select a set of ports based on a regex search of metadata
about the ports. In all such cases, a standard regex pattern following
the colon will be used to select the set of ports to which the
pseudo-portname expands.

Portnames that contain standard glob characters will be expanded to the
set of ports matching the glob pattern.
    
Port expressions
----------------
Portnames, port glob patterns, and pseudo-portnames may be logically
combined using expressions consisting of and, or, not, !, (, and ).
    
For more information
--------------------
See man pages: port(1), macports.conf(5), portfile(7), portgroup(7),
porthier(7), portstyle(7). Also, see http://www.macports.org.
    
bash-3.2$ sudo port update
Unrecognized action "update"
bash-3.2$ sudo port upgrade
Can't map the URL 'file://.' to a port description file ("Could not find Portfile in /Users/patrickmullen/temp/downloads/rxvt/urxvt-my-conf").
Please verify that the directory and portfile syntax are correct.
To use the current port, you must be in a port's directory.
(you might also see this message if a pseudo-port such as
outdated or installed expands to no ports).
Error: No port  found.
bash-3.2$ sudo port version
Version: 1.600
bash-3.2$ sudo port selfupdate

MacPorts base version 1.600 installed

Downloaded MacPorts base version 1.700
Configuring, Building and Installing new MacPorts base
selfupdate done!
bash-3.2$ sudo port install gsed
--->  Fetching gsed
--->  Attempting to fetch sed-4.1.5.tar.gz from http://mirrors.ibiblio.org/pub/mirrors/gnu/ftp/gnu/sed
--->  Verifying checksum(s) for gsed
--->  Extracting gsed
--->  Applying patches to gsed
--->  Configuring gsed
--->  Building gsed
--->  Staging gsed into destroot
--->  Installing gsed @4.1.5_3
--->  Activating gsed @4.1.5_3
--->  Cleaning gsed
bash-3.2$ cat multi-line.test | gsed  -r 's:\(else\|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | gsed  -r 's:\(else|if\):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | gsed  -r 's:.*\(else|if\).*:@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | gsed  -r 's:.*(else|if).*:@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

@@
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


@@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | gsed  -r 's:.(else|if):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

     @@ (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


     @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | gsed  -r 's:.(else|\)):@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &e@@
{
# 2185 "command.C"
void
rxvt_term::cmd_parse @@
{

      if (len == (size_@@-@@
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


     @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char @@
{


bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 1: unknown command: `-'
bash-3.2$ cat multi-line.test | gsed  -e -r 's:.(else|\)):@@:g'
gsed: -e expression #1, char 1: unknown command: `-'
bash-3.2$ cat multi-line.test | gsed  -er 's:.(else|\)):@@:g'
gsed: can't read s:.(else|\)):@@:g: No such file or directory
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 1: unknown command: `('
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 12: unknown command: `*'
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 12: unknown command: `*'
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 13: unknown command: `]'
bash-3.2$ cat multi-line.test | gsed  -er 's:.(else|\))[ ]*:@@:g'
gsed: can't read s:.(else|\))[ ]*:@@:g: No such file or directory
bash-3.2$ cat multi-line.test | gsed  -r 's:.(else|\))[ ]*:@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &e@@
{
# 2185 "command.C"
void
rxvt_term::cmd_parse @@
{

      if (len == (size_@@-@@
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


     @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char @@
{


bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 13: unknown command: `]'
bash-3.2$ cat multi-line.test | gsed  -r 's:.(else|\))[ ]*$:@@:g'
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &e@@
{
# 2185 "command.C"
void
rxvt_term::cmd_parse @@
{

      if (len == (size_t)-@@
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


     @@
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char @@
{


bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 13: unknown command: `]'
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 13: : doesn't want any addresses
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 15: unterminated `s' command
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 13: : doesn't want any addresses
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 1: unknown command: `('
bash-3.2$ ./test_multiline 
bash: ./test_multiline: Permission denied
bash-3.2$ chmod +x test_multiline 
bash-3.2$ ./test_multiline 
a
xy
bash-3.2$ ./test_multiline 
a
xy
bash-3.2$ ./test_multiline 
a
xy
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 44: Unmatched \{
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 40: Unmatched \{
bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ ./test_multiline
a
xy
bash-3.2$ ./test_multiline
a
xy
a
x
bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ ls
#README.configure#		COPYING				Makefile			aclocal.m4			config.guess			config.sub			libev				print_after.bash~		regex_vars~			strip_macro_defs~		update_ptytty
#clean-file.bash#		CVS				Makefile.in			autoconf			config.h			configure			multi-line.test			ptytty.m4			remove-comment.bash		strip_to_orig_file_only.bash
#my-minimal-config-flags.txt#	Changes				README.FAQ			autogen.sh			config.h.in			configure.ac			multi-line.test~		reformat_braces			remove-comment.bash~		strip_to_orig_file_only.bash~
#regex_vars#			INSTALL				README.configure		clean-file.bash			config.log			doc				my-convert.bash			reformat_braces~		src				test_multiline
#strip_macro_defs#		MANIFEST			W11				clean-file.bash~		config.status			install-sh			print_after.bash		regex_vars			strip_macro_defs		test_multiline~
bash-3.2$ cat my-convert.bash 
#!/bin/bash

./configure --disable-backspace-key                        --disable-swapscreen                           --disable-resources                            --disable-delete-key                           --disable-xft --disable-font-styles --disable-xim --disable-combining --disable-fallback--disable-utmp --disable-wtmp --disable-lastlog --disable-afterimage --disable-transparency --disable-fading --disable-rxvt-scroll --disable-next-scroll --disable-frills --disable-keepscrolling --disable-selectionscrolling --disable-mousewheel --disable-slipwheeling --disable-pointer-blank --disable-perl 

make exp

c_kws_regex="(void|char|unsigned|int |short|static|rend_t|unicode_t)" 
sed  -E '/.*'"$c_kws_regex"'.*/{h;x;s/^/\/\//;p;x;s/'"$c_kws_regex"'//g;}'bash-3.2$ 
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else  
{
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if ()  
 { 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
gsed: -e expression #1, char 15: Unmatched ) or \)
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
gsed: -e expression #1, char 45: Unmatched \{
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (else{ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (else{ 
  else{ 
y
  if (else{ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (else{ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if ()   
	{ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 59: invalid reference \1 on `s' command's RHS
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 59: invalid reference \1 on `s' command's RHS
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
bash-3.2$ cat multi-line.test | ./reformat_braces
gsed: -e expression #1, char 59: invalid reference \1 on `s' command's RHS
bash-3.2$ ./test_multiline
a
xy
a
x
else{
y
  else{
y
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
 adding shell variables 
  if (){ 
  else{ 
y
bash-3.2$ cat multi-line.test | ./reformat_braces
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev){
# 2185 "command.C"
void
rxvt_term::cmd_parse (){

      if (len == (size_t)-2){
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else{
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char (){


bash-3.2$ cat multi-line.test 
void
   rxvt::


void
rxvt_term::button_release (XButtonEvent &ev)
{
# 2185 "command.C"
void
rxvt_term::cmd_parse ()
{

      if (len == (size_t)-2)
        {
          // the mbstate stores incomplete sequences. didn't know this :/
          cmdbuf_ptr = cmdbuf_endp;
          break;
        }


      else
        {
          len = 0;
# 2185 "command.C"
          buf[len++] = ch;


wchar_t
rxvt_term::next_char ()
{


bash-3.2$ echo " 	

> > "
 	


bash-3.2$ echo " 	" | gsed 's/[:space:]/******/g'
 	
bash-3.2$ echo " 	" | gsed -r 's/[:space:]/******/g'
 	
bash-3.2$ echo " 	" | gsed -r 's/[:space:]*/******/g'
****** ******	******
bash-3.2$ echo "aaaa 	" | gsed -r 's/(a+)/******/g'
****** 	
bash-3.2$ echo "aaaa 	" | gsed -r 's/(a+)//g'
 	
bash-3.2$ echo "aaaa 	aaaaaa" | gsed -r 's/(a+)/jjj/g'
jjj 	jjj
bash-3.2$ chmod +x one_line_functions
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
asdf
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
asdf
rxvt_term::next_char ()
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
asdf
rxvt_term::next_char ()
wchar_t
rxvt_term::next_char ()
bash-3.2$ ./one_line_functions
a
x
 adding shell variables 
  if (){ 
  else{ 
y
  if (){ 
  else{ 
y
asdf
rxvt_term::next_char ()
wchar_t rxvt_term::next_char ()
bash-3.2$ 